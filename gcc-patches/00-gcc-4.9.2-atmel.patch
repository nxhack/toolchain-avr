diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index b6654c6..eac162e 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,284 @@
+2015-05-25  Pitchumani Sivanupandi  <pitchumani.s@atmel.com>
+
+	* config/avr/avr.c (avr_out_load_psi_reg_no_disp_tiny): Restore base
+	register if not marked dead/unused, before return.
+
+2015-04-27  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	PR target/65895
+	* config/avr/gen-avr-mmcu-specs.c (print_mcu): Close file.
+	Add hint how to use own spec file.
+
+2015-04-17  Sivanupandi Pitchumani <Pitchumani.Sivanupandi@atmel.com>
+
+	PR target/65296
+	* config/avr/gen-avr-mmcu-specs.c (*avrlibc_startfile): Adjust
+	to new AVR-LibC file layout (bug #44574).
+	(*avrlibc_devicelib): Same.
+	* config/avr/avr-mcus.def: Adjust comments.
+	* config/avr/avr.opt (nodevicelib): Adjust help.
+
+2014-09-11  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/63223
+	* config/avr/avr.md (*tablejump.3byte-pc): New insn.
+	(*tablejump): Restrict to !AVR_HAVE_EIJMP_EICALL.  Add void clobber.
+	(casesi): Expand to *tablejump.3byte-pc if AVR_HAVE_EIJMP_EICALL.
+
+2015-04-09  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* config/avr/driver-avr.c (avr_devicespecs_file): Don't specify a
+	device specs file if "device-specs%s" didn't resolve to a path.
+
+2015-03-23  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* config/avr/driver-avr.c (avr_devicespecs_file): Allow to specify
+	the same -mmcu=MCU more than once.
+
+2015-03-16  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* config/avr/avr.opt (-nodevicelib): New option.
+	* doc/invoke.texi (AVR Options): Document it.
+	* config/avr/avrlibc.h (LIB_SPEC, LIBGCC_SPEC) [avr1]: Don't link
+	libgcc.a, libc.a, libm.a.
+	* config/avr/specs.h: Same.
+	* config/avr/gen-avr-mmcu-specs.c (print_mcu): Don't print specs
+	which don't (directly) depend on the device.  Print more help.
+	(*avrlibc_devicelib) [-nodevicelib]: Don't link libdev.a.
+	(*cpp): Don't define __AVR_DEV_LIB_NAME__.
+	* config/avr/driver-avr.c: Remove -nodevicelib from option list in
+	case of an error.
+	(avr_devicespecs_file): Use suffix "%s" instead of absolute path
+	for specs file name.
+	* config/avr/avr-arch.h (avr_mcu_t) [.library_name]: Remove.
+	* config/avr/avr-mcus.def: Adjust initializers and comments.
+
+2015-03-10  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* configure.ac [avr]: Check as for options -mrmw, --mlink-relax.
+	* configure: Regenerate.
+	* config.in: Regenerate.
+	* doc/invoke.texi (AVR Options) [-mrmw]: Document it.
+	[-mn-flash]: Document it.
+	[__AVR_ARCH__]: Document avrtiny.
+
+	* config/avr/gen-avr-mmcu-specs.c (config.h): Include it.
+	(*asm_relax): Only define spec if HAVE_AS_AVR_MLINK_RELAX_OPTION.
+	(*asm_rmw): Only define spec if HAVE_AS_AVR_MRMW_OPTION.
+
+2015-03-10  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* config.gcc (extra_options) [avr]: Remove.
+	(extra_gcc_objs) [avr]: Use driver-avr.o, avr-devices.o.
+	(tm_file) [avr]: Add avr/specs.h after avr/avr.h.
+	(tm_defines) [avr-*-rtems*]: Add WITH_RTEMS.
+
+	* config/avr/avr.opt (config/avr/avr-arch.h): Remove include.
+	(-mmcu=): Add Var and MissingArgError properties.
+	(-march=): Remove.
+	* config/avr/genmultilib.awk: Use -mmcu= instead of -march=.
+	* config/avr/t-multilib: Regenerate.
+	* config/avr/specs.h: New file.
+	* config/avr/driver-avr.c: New file.
+	* config/avr/genopt.sh: Remove file.
+	* config/avr/avr-tables.opt: Remove file.
+	* config/avr/predicates.md (avr_current_arch): Rename to avr_arch.
+	* config/avr/avr-c.c: Same.
+	* avr-arch.h: Same.
+	(avr_current_device): Remove proto.
+	* config/avr/avr.h (avr_current_arch): Rename to avr_arch.
+	(AVR_HAVE_8BIT_SP): Don't depend on avr_current_device.
+	(EXTRA_SPEC_FUNCTIONS): Define.
+	(avr_devicespecs_file): New specs function proto.
+	(DRIVER_SELF_SPECS): Use device-specs-file spec function.
+	* config/avr/avr.c (avr_current_arch): Rename to avr_arch.
+	(avr_current_device): Remove definition and usage.
+	(avr_set_core_architecture): New static function.
+	(avr_option_override): Use it.
+	* config/avr/avr-devices.c (diagnostic.h, avr-arch.h): Include them.
+	(mcu_name): New static array.
+	(comparator, avr_archs_str, avr_mcus_str): New static functions.
+	(avr_inform_devices, avr_inform_core_architectures): New functions.
+	* config/avr/gen-avr-mmcu-specs.c (avr-arch.h, specs.h): Include.
+	(avrlibc.h) [WITH_AVRLIBC]: Include.
+	(../rtems.h, rtems.h) [WITH_RTEMS]: Include.
+	(print_mcu): Rewrite from scratch.
+	* config/avr/avrlibc.h (LIB_SPEC, LIBGCC_SPEC, STARTFILE_SPEC):
+	Forward to avr-specific specs defined in device-specs file.
+	* config/avr/t-avr (driver-avr.o): New rule.
+	(avr-devices.o): Depend on avr-arch.h.
+	(avr-mcus): No more depend on avr-tables.opt.
+	(avr-tables.opt): Remove rule.
+	(install-device-specs): Use INSTALL_DATA, not INSTALL_PROGRAM.
+
+2015-03-03  Georg-Johann Lay  <avr@gjlay.de>
+
+	Fix various problems with specs file generation.
+
+	PR target/65296
+	* config.gcc (extra_gcc_objs) [avr]: Remove.
+	* config/avr/driver-avr.c: Remove file.
+	* config/avr/t-avr (driver-avr.o): Remove rule.
+	(gen-avr-mmcu-specs): Use CXX_FOR_BUILD, CXXFLAGS_FOR_BUILD and
+	INCLUDES to build.  Depend on TM_H.
+	* config/avr/gen-avr-mmcu-specs.c: Tidy up code.  Fix various
+	build warnings.  Fix non-matching types and non-existing %-codes.
+	(tm.h): Include.
+	(*lib) [!WITH_AVRLIBC]: Don't link libdev.a.
+	(*libgcc) [WITH_AVRLIBC]: Add "-lm".
+	* config/avr/avrlibc.h (LIBGCC_SPEC): Remove definition.
+	* config/avr/avr.h (DRIVER_SELF_SPECS): Fix handling of -march=.
+	(CPP_SPEC, CC1PLUS_SPEC, ASM_SPEC, LINK_SPEC, LIB_SPEC)
+	(LIBGCC_SPEC): Remove definitions.
+
+2015-02-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65192
+	* config/avr/avr-protos.h (tiny_valid_direct_memory_access_range):
+	Remove.
+	* config/avr/avr.c: Same.
+	(avr_legitimate_address_p) <AVR_TINY, CONSTANT_ADDRESS_P>:
+	Refuse any constant address not in 0..0xbf.
+	* config/avr/avr.md (*mov<mode>, *movsf): Remove
+	tiny_valid_direct_memory_access_range from insn conditions.
+	(mov<mode>): Don't special-case expansion of avrtiny addresses.
+
+2015-02-25  Georg-Johann Lay  <avr@gjlay.de>
+
+	Use variadic macros with avr-log.c.
+
+	* config/avr/avr-protos.h (avr_vdump): New prototype.
+	(avr_log_set_caller_e, avr_log_set_caller_f): Remove protos.
+	(avr_edump, avr_fdump, avr_dump): (Re)define to use avr_vdump.
+	* config/avr/avr-log.c: Adjust comments.
+	(avr_vdump): New function.
+	(avr_vadump): Pass caller as 2nd argument instead of format string.
+	(avr_log_caller, avr_log_fdump_e, avr_log_fdump_f)
+	(avr_log_set_caller_e, avr_log_set_caller_f): Remove.
+
+2015-02-24  Georg-Johann Lay  <avr@gjlay.de>
+
+	* config/avr/stdfix.h [__WITH_AVRLIBC__]: Include <stdfix-avrlibc.h>.
+
+2014-10-09  Joern Rennecke  <joern.rennecke@embecosm.com>
+
+	* config/avr/avr.opt (mmcu=): Change to have a string value.
+	(mn-flash=, mskip-bug, march=, mrmw): New options.
+	(HeaderInclude): New.
+	(mmcu=): Remove Var / Init clauses.
+	* config/avr/avr.h (DRIVER_SELF_SPECS): Translate -mmcu into a
+	-specs option.
+	(SYMBOL_FLAG_IO, SYMBOL_FLAG_ADDRESS): Define.
+	(ASM_OUTPUT_ALIGNED_BSS): Use avr_asm_asm_output_aligned_bss.
+	(SYMBOL_FLAG_IO_LOW): Define.
+	(avr_device_to_as, avr_device_to_ld): Don't declare.
+	(avr_device_to_data_start, avr_device_to_startfiles): Likewise.
+	(avr_device_to_devicelib, avr_device_to_sp8): Likewise.
+	(EXTRA_SPEC_FUNCTIONS): Don't define.
+	(ASM_SPEC): Translate -arch= option to -mmcu= option.
+	(LINK_SPEC): Translate -arch= option to -m= option.
+	Don't use device_to_ld / device_to_data_start.
+	(STARTFILE_SPEC): Now empty.
+	(ASM_SPEC): Add -%{mrelax: --mlink-relax}.
+	* config/avr/gen-avr-mmcu-specs.c: New file.
+	* config/avr/t-avr (gen-avr-mmcu-specs$(build_exeext)): New rule.
+	(s-device-specs): Likewise.
+	(GCC_PASSES): Add s-device-specs.
+	(install-driver): Depend on install-device-specs.
+	(install-device-specs): New rule.
+	* config/avr/avr.c (avr_option_override): Look up mcu arch by
+	avr_arch_index and provide fallback initialization for avr_n_flash.
+	(varasm.h): #include.
+	(avr_print_operand) <i>: Allow SYMBOL_REF with SYMBOL_FLAG_IO;
+	(avr_handle_addr_attribute, avr_eval_addr_attrib): New functions.
+	(avr_attribute_table): Add "io", "address" and "io_low".
+	(avr_asm_output_aligned_decl_common): Change type of decl to tree.
+	Add special handling for symbols with "io" and/or "address" attributes.
+	(avr_asm_asm_output_aligned_bss): New function.
+	(avr_encode_section_info): Set SYMBOL_FLAG_IO and SYMBOL_FLAG_ADDRESS
+	as appropriate.  Handle io_low attribute.
+	(avr_out_sbxx_branch): Handle symbolic io addresses.
+	(avr_xload_libgcc_p, avr_nonconst_pointer_addrspace): Use
+	avr_n_flash instead of avr_current_device->n_flash.
+	(avr_pgm_check_var_decl, avr_insert_attributes): Likewise.
+	(avr_emit_movmemhi): Likewise.
+	* config/avr/avr-c.c (avr_cpu_cpp_builtins): Likewise.
+	Use TARGET_RMW instead of avr_current_device->dev_attributes.
+	Don't define avr_current_device->macro (that's the specfile's job).
+	Use TARGET_SKIP_BUG instead of avr_current_device->errata_skip.
+	* config/avr/avr.c (avr_2word_insn_p): Likewise.
+	* config/avr/avr.md (*cpse.ne): Likewise.
+	(mov<mode>): Use avr_eval_addr_attrib.
+	(cbi): Change constraint for low_io_address_operand operand to "i".
+	(sbi, sbix_branch, sbix_branch_bit7, insv.io, insv.not.io): Likewise.
+	* config/avr/predicates.md (io_address_operand):
+	Allow SYMBOL_REF with SYMBOL_FLAG_IO.
+	(low_io_address_operand): Allow SYMBOL_REF with SYMBOL_FLAG_IO_LOW.
+	* config/avr/avr-protos.h (avr_asm_output_aligned_decl_common):
+	Update prototype.
+	(avr_eval_addr_attrib, avr_asm_asm_output_aligned_bss): Prototype.
+	* config/avr/genmultilib.awk: Use -march=.
+	Remove Multilib matches processing.
+	* config/avr/t-multilib, config/avr/avr-tables.opt: Regenerate.
+	* config/avr/avr-arch.h: Add double include guard.
+	(avr_mcu_t) <library_name>: Update comment.
+	* config/avr/driver-avr.c (avr_device_to_as): Delete.
+	(avr_device_to_ld, avr_device_to_data_start): Likewise.
+	(avr_device_to_startfiles, avr_device_to_devicelib): Likewise.
+	(avr_device_to_sp8): Likewise.
+	* config/avr/genopt.sh:  Instead avr_mcu, emit an Enum for avr_arch.
+
+	* doc/extend.texi (io, address): Document new AVR variable attributes.
+	(io_low): Likewise.
+
+2015-03-03  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/64331
+	* config/avr/avr.c (context.h, tree-pass.h): Include them.
+	(avr_pass_data_recompute_notes): New static variable.
+	(avr_pass_recompute_notes): New class.
+	(avr_register_passes): New static function.
+	(avr_option_override): Call it.
+
+2015-02-25  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65196
+	* config/avr/avr.c (avr_adjust_insn_length): Call recog_memoized
+	only with NONDEBUG_INSN_P.
+
+2015-02-20  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2015-02-20 trunk r220847.
+
+	PR target/64452
+	* config/avr/avr.md (pushhi_insn): New insn.
+	(push<mode>1): Push virtual regs in one chunk using pushhi1_insn.
+
+2014-10-30  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR63633
+	* config/avr/avr-protos.h (regmask): New inline function.
+	(avr_fix_inputs, avr_emit3_fix_outputs): New protos.
+	* config/avr/avr.c (avr_fix_operands, avr_move_fixed_operands)
+	(avr_fix_inputs, avr_emit3_fix_outputs): New functions.
+	* config/avr/avr-fixed.md (mulqq3_nomul, muluqq3_nomul)
+	(mul<ALL2QA>3, mul<ALL4A>3, <usdiv><ALL1Q>3, <usdiv><ALL2QA>3)
+	(<usdiv><ALL4A>3, round<ALL124QA>3): Fix input operands.
+	* config/avr/avr-dimode.md (add<ALL8>3, sub<ALL8>3)
+	(<ss_addsub><ALL8S>3, <us_addsub><ALL8U>3, cbranch<ALL8>4)
+	(<di_shifts><ALL8>3, <any_extend>mulsidi3): Fix input operands.
+	* config/avr/avr.md (mulqi3_call, mulhi3_call, mulsi3, mulpsi3)
+	(mulu<QIHI>si3, muls<QIHI>si3, mulohisi3, <any_extend>mulhisi3)
+	(usmulhisi3, <any_extend>mulhi3_highpart, mulsqipsi3)
+	(fmul, fmuls, fmulsu): Fix operands.  Turn insn into expander as
+	needed.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 14511e1..2948617 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -3908,10 +3908,7 @@ expand_debug_expr (tree exp)
 	  op0 = plus_constant (inner_mode, op0, INTVAL (op1));
 	}
 
-      if (POINTER_TYPE_P (TREE_TYPE (exp)))
-	as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));
-      else
-	as = ADDR_SPACE_GENERIC;
+      as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))));
 
       op0 = convert_debug_memory_address (targetm.addr_space.address_mode (as),
 					  op0, as);
@@ -4434,7 +4431,7 @@ expand_debug_expr (tree exp)
 	  return NULL;
 	}
 
-      as = TYPE_ADDR_SPACE (TREE_TYPE (exp));
+      as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));
       op0 = convert_debug_memory_address (mode, XEXP (op0, 0), as);
 
       return op0;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 9d3fa57..d013822 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -341,7 +341,6 @@ avr-*-*)
 	cpu_type=avr
 	c_target_objs="avr-c.o"
 	cxx_target_objs="avr-c.o"
-	extra_options="${extra_options} avr/avr-tables.opt"
 	;;
 bfin*-*)
 	cpu_type=bfin
@@ -1073,13 +1072,14 @@ arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-rtems*)
 	tm_file="${tm_file} arm/aout.h vxworks-dummy.h arm/arm.h"
 	;;
 avr-*-rtems*)
-	tm_file="elfos.h avr/elf.h avr/avr-arch.h avr/avr.h dbxelf.h avr/rtems.h rtems.h newlib-stdint.h"
+	tm_file="elfos.h avr/elf.h avr/avr-arch.h avr/avr.h avr/specs.h dbxelf.h avr/rtems.h rtems.h newlib-stdint.h"
+	tm_defines="${tm_defines} WITH_RTEMS"
 	tmake_file="${tmake_file} avr/t-avr avr/t-multilib avr/t-rtems"
 	extra_gcc_objs="driver-avr.o avr-devices.o"
 	extra_objs="avr-devices.o avr-log.o"
 	;;
 avr-*-*)
-	tm_file="elfos.h avr/elf.h avr/avr-arch.h avr/avr.h dbxelf.h avr/avr-stdint.h"
+	tm_file="elfos.h avr/elf.h avr/avr-arch.h avr/avr.h avr/specs.h dbxelf.h avr/avr-stdint.h"
 	if test x${with_avrlibc} != xno; then
 	    tm_file="${tm_file} ${cpu_type}/avrlibc.h"
 	    tm_defines="${tm_defines} WITH_AVRLIBC"
diff --git a/gcc/config.in b/gcc/config.in
index 1e85325..690242a 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -211,6 +211,18 @@
 #endif
 
 
+/* Define if your avr assembler supports --mlink-relax option. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_AVR_MLINK_RELAX_OPTION
+#endif
+
+
+/* Define if your avr assembler supports -mrmw option. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_AVR_MRMW_OPTION
+#endif
+
+
 /* Define if your assembler supports cmpb. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_CMPB
diff --git a/gcc/config/avr/avr-arch.h b/gcc/config/avr/avr-arch.h
index b3c7cc0..b2a242e 100644
--- a/gcc/config/avr/avr-arch.h
+++ b/gcc/config/avr/avr-arch.h
@@ -19,10 +19,14 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#ifndef AVR_ARCH_H
+#define AVR_ARCH_H
+
+#define AVR_MMCU_DEFAULT "avr2"
 
 /* This enum supplies indices into the avr_arch_types[] table below. */
 
-enum avr_arch
+enum avr_arch_id
 {
   ARCH_UNKNOWN,
   ARCH_AVR1,
@@ -35,6 +39,7 @@ enum avr_arch
   ARCH_AVR5,
   ARCH_AVR51,
   ARCH_AVR6,
+  ARCH_AVRTINY,
   ARCH_AVRXMEGA2,
   ARCH_AVRXMEGA4,
   ARCH_AVRXMEGA5,
@@ -75,6 +80,9 @@ typedef struct
      and thus also the RAMPX, RAMPY and RAMPZ registers.  */
   int have_rampd;
 
+  /* This is a TINY core. */
+  int tiny_p;
+
   /* Default start of data section address for architecture.  */
   int default_data_section_start;
 
@@ -86,7 +94,7 @@ typedef struct
   const char *const macro;
 
   /* Architecture name.  */
-  const char *const arch_name;
+  const char *const name;
 } avr_arch_t;
 
 
@@ -98,7 +106,7 @@ typedef struct
   const char *const name;
 
   /* Index in avr_arch_types[].  */
-  enum avr_arch arch;
+  enum avr_arch_id arch_id;
 
   /* device specific feature */
   int dev_attribute;
@@ -109,11 +117,11 @@ typedef struct
   /* Start of data section.  */
   int data_section_start;
 
+  /* Start of text section. */
+  int text_section_start;
+
   /* Number of 64k segments in the flash.  */
   int n_flash;
-
-  /* Name of device library.  */
-  const char *const library_name;
 } avr_mcu_t;
 
 /* AVR device specific features.
@@ -157,7 +165,7 @@ enum avr_device_specific_features
 typedef struct
 {
   /* Architecture ID.  */
-  enum avr_arch arch;
+  enum avr_arch_id arch_id;
 
   /* textinfo source to describe the archtiecture.  */
   const char *texinfo;
@@ -166,7 +174,11 @@ typedef struct
 /* Preprocessor macros to define depending on MCU type.  */
 
 extern const avr_arch_t avr_arch_types[];
-extern const avr_arch_t *avr_current_arch;
+extern const avr_arch_t *avr_arch;
 
 extern const avr_mcu_t avr_mcu_types[];
-extern const avr_mcu_t *avr_current_device;
+
+extern void avr_inform_devices (void);
+extern void avr_inform_core_architectures (void);
+
+#endif /* AVR_ARCH_H */
diff --git a/gcc/config/avr/avr-c.c b/gcc/config/avr/avr-c.c
index c6a2f1f..12cb766 100644
--- a/gcc/config/avr/avr-c.c
+++ b/gcc/config/avr/avr-c.c
@@ -296,10 +296,11 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)
 
   builtin_define_std ("AVR");
 
-  if (avr_current_arch->macro)
-    cpp_define_formatted (pfile, "__AVR_ARCH__=%s", avr_current_arch->macro);
-  if (avr_current_device->macro)
-    cpp_define (pfile, avr_current_device->macro);
+  /* __AVR_DEVICE_NAME__ and  avr_mcu_types[].macro like __AVR_ATmega8__
+	 are defined by -D command option, see device-specs file.  */
+
+  if (avr_arch->macro)
+    cpp_define_formatted (pfile, "__AVR_ARCH__=%s", avr_arch->macro);
   if (AVR_HAVE_RAMPD)    cpp_define (pfile, "__AVR_HAVE_RAMPD__");
   if (AVR_HAVE_RAMPX)    cpp_define (pfile, "__AVR_HAVE_RAMPX__");
   if (AVR_HAVE_RAMPY)    cpp_define (pfile, "__AVR_HAVE_RAMPY__");
@@ -309,21 +310,38 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)
   if (AVR_HAVE_MOVW)     cpp_define (pfile, "__AVR_HAVE_MOVW__");
   if (AVR_HAVE_LPMX)     cpp_define (pfile, "__AVR_HAVE_LPMX__");
 
-  if (avr_current_arch->asm_only)
+  if (avr_arch->asm_only)
     cpp_define (pfile, "__AVR_ASM_ONLY__");
   if (AVR_HAVE_MUL)
     {
       cpp_define (pfile, "__AVR_ENHANCED__");
       cpp_define (pfile, "__AVR_HAVE_MUL__");
     }
-  if (avr_current_arch->have_jmp_call)
+  if (avr_arch->have_jmp_call)
     {
       cpp_define (pfile, "__AVR_MEGA__");
       cpp_define (pfile, "__AVR_HAVE_JMP_CALL__");
     }
   if (AVR_XMEGA)
     cpp_define (pfile, "__AVR_XMEGA__");
-  if (avr_current_arch->have_eijmp_eicall)
+
+  if (AVR_TINY)
+    {
+      cpp_define (pfile, "__AVR_TINY__");
+
+      /* Define macro "__AVR_TINY_PM_BASE_ADDRESS__" with mapped program memory
+         start address.  This macro shall be used where mapped program
+         memory is accessed, eg. copying data section (__do_copy_data)
+         contents to data memory region.
+         NOTE:
+         Program memory of AVR_TINY devices cannot be accessed directly,
+         it has been mapped to the data memory.  For AVR_TINY devices
+         (ATtiny4/5/9/10/20 and 40) mapped program memory starts at 0x4000. */
+
+      cpp_define (pfile, "__AVR_TINY_PM_BASE_ADDRESS__=0x4000");
+    }
+
+  if (AVR_HAVE_EIJMP_EICALL)
     {
       cpp_define (pfile, "__AVR_HAVE_EIJMP_EICALL__");
       cpp_define (pfile, "__AVR_3_BYTE_PC__");
@@ -338,28 +356,27 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)
   else
     cpp_define (pfile, "__AVR_HAVE_16BIT_SP__");
 
-  if (avr_sp8)
-    cpp_define (pfile, "__AVR_SP8__");
-
   if (AVR_HAVE_SPH)
     cpp_define (pfile, "__AVR_HAVE_SPH__");
+  else
+    cpp_define (pfile, "__AVR_SP8__");
 
   if (TARGET_NO_INTERRUPTS)
     cpp_define (pfile, "__NO_INTERRUPTS__");
 
-  if (avr_current_device->dev_attribute & AVR_ERRATA_SKIP)
+  if (TARGET_SKIP_BUG)
     {
       cpp_define (pfile, "__AVR_ERRATA_SKIP__");
 
-      if (avr_current_arch->have_jmp_call)
+      if (AVR_HAVE_JMP_CALL)
         cpp_define (pfile, "__AVR_ERRATA_SKIP_JMP_CALL__");
     }
 
-  if (avr_current_device->dev_attribute & AVR_ISA_RMW)
+  if (TARGET_RMW)
     cpp_define (pfile, "__AVR_ISA_RMW__");
 
   cpp_define_formatted (pfile, "__AVR_SFR_OFFSET__=0x%x",
-                        avr_current_arch->sfr_offset);
+                        avr_arch->sfr_offset);
 
 #ifdef WITH_AVRLIBC
   cpp_define (pfile, "__WITH_AVRLIBC__");
@@ -378,7 +395,9 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)
             /* Only supply __FLASH<n> macro if the address space is reasonable
                for this target.  The address space qualifier itself is still
                supported, but using it will throw an error.  */
-            && avr_addrspace[i].segment < avr_current_device->n_flash)
+            && avr_addrspace[i].segment < avr_n_flash
+            /* Only support __MEMX macro if we have LPM.  */
+            && (AVR_HAVE_LPM || avr_addrspace[i].pointer_size <= 2))
           {
             const char *name = avr_addrspace[i].name;
             char *Name = (char*) alloca (1 + strlen (name));
diff --git a/gcc/config/avr/avr-devices.c b/gcc/config/avr/avr-devices.c
index 2485cad..95933ee 100644
--- a/gcc/config/avr/avr-devices.c
+++ b/gcc/config/avr/avr-devices.c
@@ -21,9 +21,12 @@
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "diagnostic.h"
 #include "tm.h"
 #endif /* IN_GEN_AVR_MMCU_TEXI */
 
+#include "avr-arch.h"
+
 /* List of all known AVR MCU architectures.
    Order as of enum avr_arch from avr.h.  */
 
@@ -31,29 +34,30 @@ const avr_arch_t
 avr_arch_types[] =
 {
   /* unknown device specified */
-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,              "avr2"  },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL, AVR_MMCU_DEFAULT },
   /*
-    A  M  J  LM E  E  E  X  R   d S   S O   A
-    S  U  M  PO L  L  I  M  A   a t   F ff  r
-    M  L  P  MV P  P  J  E  M   t a   R s   c
-             XW M  M  M  G  P   a r     e   h
-                   X  P  A  D     t     t   ID   */
-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "1",   "avr1"  },
-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "2",   "avr2"  },
-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "25",  "avr25" },
-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "3",   "avr3"  },
-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, "31",  "avr31" },
-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, "35",  "avr35" },
-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "4",   "avr4"  },
-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, "5",   "avr5"  },
-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, "51",  "avr51" },
-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, "6",   "avr6"  },
-
-  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0x2000,  0, "102", "avrxmega2" },
-  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0x2000,  0, "104", "avrxmega4" },
-  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0x2000,  0, "105", "avrxmega5" },
-  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, "106", "avrxmega6" },
-  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0x2000,  0, "107", "avrxmega7" }
+    A  M  J  LM E  E  E  X  R  T  d S   S O   A
+    S  U  M  PO L  L  I  M  A  I  a t   F ff  r
+    M  L  P  MV P  P  J  E  M  N  t a   R s   c
+             XW M  M  M  G  P  Y  a r     e   h
+                   X  P  A  D       t     t   ID   */
+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "1",   "avr1"  },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "2",   "avr2"  },
+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "25",  "avr25" },
+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "3",   "avr3"  },
+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "31",  "avr31" },
+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "35",  "avr35" },
+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "4",   "avr4"  },
+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "5",   "avr5"  },
+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0x0060, 32, "51",  "avr51" },
+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, "6",   "avr6"  },
+
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x0040,  0, "100", "avrtiny" },
+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000,  0, "102", "avrxmega2" },
+  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0x2000,  0, "104", "avrxmega4" },
+  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0x2000,  0, "105", "avrxmega5" },
+  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0x2000,  0, "106", "avrxmega6" },
+  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, "107", "avrxmega7" }
 };
 
 const avr_arch_info_t
@@ -85,6 +89,9 @@ avr_texinfo[] =
   { ARCH_AVR6,
     "``Enhanced'' devices with 3-byte PC, i.e.@: with more than 128@tie{}KiB "
     "of program memory." },
+  { ARCH_AVRTINY,
+    "``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of "
+    "program memory." },
   { ARCH_AVRXMEGA2,
     "``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB "
     "of program memory." },
@@ -104,11 +111,106 @@ avr_texinfo[] =
 const avr_mcu_t
 avr_mcu_types[] =
 {
-#define AVR_MCU(NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, N_FLASH, LIBNAME)\
-  { NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, N_FLASH, LIBNAME },
+#define AVR_MCU(NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, N_FLASH)\
+  { NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, TEXT_SEC, N_FLASH },
 #include "avr-mcus.def"
 #undef AVR_MCU
     /* End of list.  */
-  { NULL, ARCH_UNKNOWN, AVR_ISA_NONE, NULL, 0, 0, NULL }
+  { NULL, ARCH_UNKNOWN, AVR_ISA_NONE, NULL, 0, 0, 0 }
 };
 
+
+
+
+#ifndef IN_GEN_AVR_MMCU_TEXI
+
+/* Copy-pastes from `gen-avr-mmcu-texi.c' follow...  */
+
+static const char*
+mcu_name[sizeof avr_mcu_types / sizeof avr_mcu_types[0]];
+
+static int
+comparator (const void *va, const void *vb)
+{
+  const char *a = *(const char* const*) va;
+  const char *b = *(const char* const*) vb;
+
+  while (*a && *b)
+    {
+      /* Make letters smaller than digits so that `atmega16a' follows
+         `atmega16' without `atmega161' etc. between them.  */
+      
+      if (ISALPHA (*a) && ISDIGIT (*b))
+        return -1;
+
+      if (ISDIGIT (*a) && ISALPHA (*b))
+        return 1;
+
+      if (*a != *b)
+        return *a - *b;
+      
+      a++;
+      b++;
+    }
+
+  return *a - *b;
+}
+
+
+static char*
+avr_archs_str (void)
+{
+  char *archs = concat ("", NULL);
+
+  // Build of core architectures' names.
+
+  for (const avr_mcu_t *mcu = avr_mcu_types; mcu->name; mcu++)
+    if (!mcu->macro)
+      archs = concat (archs, " ", avr_arch_types[mcu->arch_id].name, NULL);
+
+  return archs;
+}
+
+  
+static char*
+avr_mcus_str (void)
+{
+  size_t n_mcus = 0;
+  char *mcus = concat ("", NULL);
+
+  // Build array of proper devices' names.
+
+  for (const avr_mcu_t *mcu = avr_mcu_types; mcu->name; mcu++)
+    if (mcu->macro)
+      mcu_name[n_mcus++] = mcu->name;
+
+  // Sort MCUs so that they are displayed in the same canonical order as
+  // in doc/avr-mcus.texi.
+
+  qsort (mcu_name, n_mcus, sizeof (char*), comparator);
+
+  for (size_t i = 0; i < n_mcus; i++)
+    mcus = concat (mcus, " ", mcu_name[i], NULL);
+
+  return mcus;
+}
+
+
+void
+avr_inform_devices (void)
+{
+  char *mcus = avr_mcus_str ();
+  inform (input_location, "devices natively supported:%s", mcus);
+  free (mcus);
+}
+
+
+void
+avr_inform_core_architectures (void)
+{
+  char *archs = avr_archs_str ();
+  inform (input_location, "supported core architectures:%s", archs);
+  free (archs);
+}
+
+#endif // IN_GEN_AVR_MMCU_TEXI
diff --git a/gcc/config/avr/avr-dimode.md b/gcc/config/avr/avr-dimode.md
index 6398105..56cd304 100644
--- a/gcc/config/avr/avr-dimode.md
+++ b/gcc/config/avr/avr-dimode.md
@@ -68,6 +68,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (DImode == <MODE>mode
@@ -145,6 +146,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -201,6 +203,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -249,6 +252,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -338,6 +342,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (s8_operand (operands[2], VOIDmode))
@@ -424,6 +429,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
     emit_move_insn (gen_rtx_REG (QImode, 16), operands[2]);
     emit_insn (gen_<code_stdname><mode>3_insn ());
@@ -457,6 +463,7 @@
               (clobber (any_extend:SI (match_dup 1)))])]
   "avr_have_dimode"
   {
+    avr_fix_inputs (operands, 1 << 2, regmask (SImode, 22));
     emit_move_insn (gen_rtx_REG (SImode, 22), operands[1]);
     emit_move_insn (gen_rtx_REG (SImode, 18), operands[2]);
     emit_insn (gen_<extend_u>mulsidi3_insn());
diff --git a/gcc/config/avr/avr-fixed.md b/gcc/config/avr/avr-fixed.md
index 9c8489e..6763f59 100644
--- a/gcc/config/avr/avr-fixed.md
+++ b/gcc/config/avr/avr-fixed.md
@@ -231,7 +231,11 @@
               (clobber (reg:HI 24))])
    (set (match_operand:QQ 0 "register_operand" "")
         (reg:QQ 23))]
-  "!AVR_HAVE_MUL")
+  "!AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (QQmode, 24));
+  })
+
 
 (define_expand "muluqq3_nomul"
   [(set (reg:UQQ 22)
@@ -246,7 +250,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:UQQ 0 "register_operand" "")
         (reg:UQQ 25))]
-  "!AVR_HAVE_MUL")
+  "!AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (UQQmode, 22));
+  })
 
 (define_insn "*mulqq3.call"
   [(set (reg:QQ 23)
@@ -274,7 +281,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:ALL2QA 0 "register_operand" "")
         (reg:ALL2QA 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 18));
+  })
 
 ;; "*mulhq3.call"  "*muluhq3.call"
 ;; "*mulha3.call"  "*muluha3.call"
@@ -302,7 +312,10 @@
                     (reg:ALL4A 20)))
    (set (match_operand:ALL4A 0 "register_operand" "")
         (reg:ALL4A 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 16));
+  })
 
 ;; "*mulsa3.call" "*mulusa3.call"
 (define_insn "*mul<mode>3.call"
@@ -330,7 +343,12 @@
                                 (reg:ALL1Q 22)))
               (clobber (reg:QI 25))])
    (set (match_operand:ALL1Q 0 "register_operand" "")
-        (reg:ALL1Q 24))])
+        (reg:ALL1Q 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 25));
+  })
+
 
 ;; "*divqq3.call" "*udivuqq3.call"
 (define_insn "*<code><mode>3.call"
@@ -356,7 +374,11 @@
               (clobber (reg:HI 26))
               (clobber (reg:QI 21))])
    (set (match_operand:ALL2QA 0 "register_operand" "")
-        (reg:ALL2QA 24))])
+        (reg:ALL2QA 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 26));
+  })
 
 ;; "*divhq3.call" "*udivuhq3.call"
 ;; "*divha3.call" "*udivuha3.call"
@@ -385,7 +407,11 @@
               (clobber (reg:HI 26))
               (clobber (reg:HI 30))])
    (set (match_operand:ALL4A 0 "register_operand" "")
-        (reg:ALL4A 22))])
+        (reg:ALL4A 22))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 24));
+  })
 
 ;; "*divsa3.call" "*udivusa3.call"
 (define_insn "*<code><mode>3.call"
@@ -435,6 +461,7 @@
 
     operands[3] = gen_rtx_REG (<MODE>mode, regno_out[(size_t) GET_MODE_SIZE (<MODE>mode)]);
     operands[4] = gen_rtx_REG (<MODE>mode,  regno_in[(size_t) GET_MODE_SIZE (<MODE>mode)]);
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, REGNO (operands[4])));
     operands[5] = simplify_gen_subreg (QImode, force_reg (HImode, operands[2]), HImode, 0);
     // $2 is no more needed, but is referenced for expand.
     operands[2] = const0_rtx;
diff --git a/gcc/config/avr/avr-log.c b/gcc/config/avr/avr-log.c
index 8e27cec..1f73fdd 100644
--- a/gcc/config/avr/avr-log.c
+++ b/gcc/config/avr/avr-log.c
@@ -33,13 +33,11 @@
 
 /* This file supplies some functions for AVR back-end developers
    with a printf-like interface.  The functions are called through
-   macros avr_edump or avr_fdump from avr-protos.h:
-
-      avr_edump (const char *fmt, ...);
-
-      avr_fdump (FILE *stream, const char *fmt, ...);
+   macros `avr_dump', `avr_edump' or `avr_fdump' from avr-protos.h:
 
+   avr_fdump (FILE *stream, const char *fmt, ...);
    avr_edump (fmt, ...) is a shortcut for avr_fdump (stderr, fmt, ...)
+   avr_dump (fmt, ...)  is a shortcut for avr_fdump (dump_file, fmt, ...)
 
   == known %-codes ==
 
@@ -75,76 +73,41 @@
 /* Set according to -mlog= option.  */
 avr_log_t avr_log;
 
-/* The caller as of __FUNCTION__ */
-static const char *avr_log_caller = "?";
-
 /* The worker function implementing the %-codes */
 static void avr_log_vadump (FILE*, const char*, va_list);
 
-/* As we have no variadic macros, avr_edump maps to a call to
-   avr_log_set_caller_e which saves __FUNCTION__ to avr_log_caller and
-   returns a function pointer to avr_log_fdump_e.  avr_log_fdump_e
-   gets the printf-like arguments and calls avr_log_vadump, the
-   worker function.  avr_fdump works the same way.  */
-
-/* Provide avr_log_fdump_e/f so that avr_log_set_caller_e/_f can return
-   their address.  */
-
-static int
-avr_log_fdump_e (const char *fmt, ...)
-{
-  va_list ap;
-
-  va_start (ap, fmt);
-  avr_log_vadump (stderr, fmt, ap);
-  va_end (ap);
-
-  return 1;
-}
+/* Wrapper for avr_log_vadump.  If STREAM is NULL we are called by avr_dump,
+   i.e. output to dump_file if available.  The 2nd argument is __FUNCTION__.
+   The 3rd argument is the format string. */
 
-static int
-avr_log_fdump_f (FILE *stream, const char *fmt, ...)
+int
+avr_vdump (FILE *stream, const char *caller, ...)
 {
   va_list ap;
+        
+  if (NULL == stream && dump_file)
+    stream = dump_file;
 
-  va_start (ap, fmt);
+  va_start (ap, caller);
   if (stream)
-    avr_log_vadump (stream, fmt, ap);
+    avr_log_vadump (stream, caller, ap);
   va_end (ap);
 
   return 1;
 }
 
-/* Macros avr_edump/avr_fdump map to calls of the following two functions,
-   respectively.  You don't need to call them directly.  */
-
-int (*
-avr_log_set_caller_e (const char *caller)
-     )(const char*, ...)
-{
-  avr_log_caller = caller;
-
-  return avr_log_fdump_e;
-}
-
-int (*
-avr_log_set_caller_f (const char *caller)
-     )(FILE*, const char*, ...)
-{
-  avr_log_caller = caller;
-
-  return avr_log_fdump_f;
-}
-
 
 /* Worker function implementing the %-codes and forwarding to
    respective print/dump function.  */
 
 static void
-avr_log_vadump (FILE *file, const char *fmt, va_list ap)
+avr_log_vadump (FILE *file, const char *caller, va_list ap)
 {
   char bs[3] = {'\\', '?', '\0'};
 
+  /* 3rd proper argument is always the format string.  */
+  const char *fmt = va_arg (ap, const char*);
+
   while (*fmt)
     {
       switch (*fmt++)
@@ -246,7 +209,7 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)
               break;
 
             case 'F':
-              fputs (avr_log_caller, file);
+              fputs (caller, file);
               break;
 
             case 'H':
@@ -270,7 +233,7 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)
               /* FALLTHRU */
 
             case '?':
-              avr_log_fdump_f (file, "%F[%f:%P]");
+              avr_vdump (file, caller, "%F[%f:%P]");
               break;
 
             case 'P':
@@ -311,6 +274,9 @@ avr_log_set_avr_log (void)
 {
   bool all = TARGET_ALL_DEBUG != 0;
 
+  if (all)
+    avr_log_details = "all";
+	
   if (all || avr_log_details)
     {
       /* Adding , at beginning and end of string makes searching easier.  */
diff --git a/gcc/config/avr/avr-mcus.def b/gcc/config/avr/avr-mcus.def
index 483a303..2c304a1 100644
--- a/gcc/config/avr/avr-mcus.def
+++ b/gcc/config/avr/avr-mcus.def
@@ -24,22 +24,30 @@
    This will regenerate / update the following source files:
 
    -  $(srcdir)/config/avr/t-multilib
-   -  $(srcdir)/config/avr/avr-tables.opt
    -  $(srcdir)/doc/avr-mmcu.texi
 
    After that, rebuild everything and check-in the new sources to the repo.
-   The device list below has to be kept in sync with AVR-LibC.
+   The device list below should be kept in sync with AVR-LibC.
 
+   Device info is used during compiler build when the device specific
+   spec files device-specs/specs-<NAME> are being built.  The compiler proper
+   does not use the device info, it only uses info for the core architecture,
+   i.e. for entries with MACRO = NULL.
 
    Before including this file, define a macro:
 
-   AVR_MCU (NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, N_FLASH, LIBRARY_NAME)
+   AVR_MCU (NAME, ARCH, DEV_ATTRIBUTE, MACRO, DATA_SEC, N_FLASH)
 
    where the arguments are the fields of avr_mcu_t:
    
-       NAME          Accept -mmcu=<NAME>
+       NAME          Name of the device as specified by -mmcu=<NAME>.  Also
+                     used by DRIVER_SELF_SPECS and gen-avr-mmcu-specs.c for
+                     - the name of the device specific specs file
+                       in -specs=device-specs/spec-<NAME>
+                     - the name of the startup file crt<NAME>.o
+                     - to link the device library by means of -l<NAME>
 
-       ARCH          Specifies the multilib variant together with SHORT_SP
+       ARCH          Specifies the multilib variant together with AVR_SHORT_SP
 
        DEV_ATTRIBUTE Specifies the device specific features
                      - additional ISA, short SP, errata skip etc.,
@@ -47,274 +55,301 @@
        MACRO         If NULL, this is a core and not a device.  If non-NULL,
                      supply respective built-in macro.
 
-       DATA_SEC      First address of SRAM, used in  -Tdata=  by the driver.
+       DATA_START    First address of SRAM, used in  -Tdata=<DATA_START>.
 
-       N_FLASH       Number of 64 KiB flash segments, rounded up.
+       TEXT_START    First address of Flash, used in -Ttext=<TEXT_START>.
 
-       LIBRARY_NAME  Used by the driver to linke startup code from avr-libc
-                     as of  crt<LIBRARY_NAME>.o
+       N_FLASH       Number of 64 KiB flash segments, rounded up.  The default
+                     value for -mn-flash=<N_FLASH>.
 
    "avr2" must be first for the "0" default to work as intended.  */
 
 /* Classic, <= 8K.  */
-AVR_MCU ("avr2",                 ARCH_AVR2, AVR_ERRATA_SKIP, NULL,                     0x0060, 6, "s8515")
-AVR_MCU ("at90s2313",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2313__",         0x0060, 1, "s2313")
-AVR_MCU ("at90s2323",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2323__",         0x0060, 1, "s2323")
-AVR_MCU ("at90s2333",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2333__",         0x0060, 1, "s2333")
-AVR_MCU ("at90s2343",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2343__",         0x0060, 1, "s2343")
-AVR_MCU ("attiny22",             ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny22__",          0x0060, 1, "tn22")
-AVR_MCU ("attiny26",             ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny26__",          0x0060, 1, "tn26")
-AVR_MCU ("at90s4414",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4414__",         0x0060, 1, "s4414")
-AVR_MCU ("at90s4433",            ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S4433__",         0x0060, 1, "s4433")
-AVR_MCU ("at90s4434",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4434__",         0x0060, 1, "s4434")
-AVR_MCU ("at90s8515",            ARCH_AVR2, AVR_ERRATA_SKIP, "__AVR_AT90S8515__",      0x0060, 1, "s8515")
-AVR_MCU ("at90c8534",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90C8534__",         0x0060, 1, "c8534")
-AVR_MCU ("at90s8535",            ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S8535__",         0x0060, 1, "s8535")
+AVR_MCU ("avr2",             ARCH_AVR2, AVR_ERRATA_SKIP, NULL,                     0x0060, 0x0, 6)
+AVR_MCU ("at90s2313",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2313__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s2323",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2323__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s2333",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2333__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s2343",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S2343__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny22",         ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny22__",          0x0060, 0x0, 1)
+AVR_MCU ("attiny26",         ARCH_AVR2, AVR_SHORT_SP, "__AVR_ATtiny26__",          0x0060, 0x0, 1)
+AVR_MCU ("at90s4414",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4414__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s4433",        ARCH_AVR2, AVR_SHORT_SP, "__AVR_AT90S4433__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s4434",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S4434__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s8515",        ARCH_AVR2, AVR_ERRATA_SKIP, "__AVR_AT90S8515__",      0x0060, 0x0, 1)
+AVR_MCU ("at90c8534",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90C8534__",         0x0060, 0x0, 1)
+AVR_MCU ("at90s8535",        ARCH_AVR2, AVR_ISA_NONE, "__AVR_AT90S8535__",         0x0060, 0x0, 1)
 /* Classic + MOVW, <= 8K.  */
-AVR_MCU ("avr25",                ARCH_AVR25, AVR_ISA_NONE, NULL,                       0x0060, 1, "tn85")
-AVR_MCU ("ata6289",              ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA6289__",          0x0100, 1, "a6289")
-AVR_MCU ("ata5272",              ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA5272__",          0x0100, 1, "a5272")
-AVR_MCU ("attiny13",             ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13__",         0x0060, 1, "tn13")
-AVR_MCU ("attiny13a",            ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13A__",        0x0060, 1, "tn13a")
-AVR_MCU ("attiny2313",           ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313__",       0x0060, 1, "tn2313")
-AVR_MCU ("attiny2313a",          ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313A__",      0x0060, 1, "tn2313a")
-AVR_MCU ("attiny24",             ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24__",         0x0060, 1, "tn24")
-AVR_MCU ("attiny24a",            ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24A__",        0x0060, 1, "tn24a")
-AVR_MCU ("attiny4313",           ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny4313__",       0x0060, 1, "tn4313")
-AVR_MCU ("attiny44",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44__",         0x0060, 1, "tn44")
-AVR_MCU ("attiny44a",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44A__",        0x0060, 1, "tn44a")
-AVR_MCU ("attiny84",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84__",         0x0060, 1, "tn84")
-AVR_MCU ("attiny84a",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84A__",        0x0060, 1, "tn84")
-AVR_MCU ("attiny25",             ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny25__",         0x0060, 1, "tn25")
-AVR_MCU ("attiny45",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny45__",         0x0060, 1, "tn45")
-AVR_MCU ("attiny85",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny85__",         0x0060, 1, "tn85")
-AVR_MCU ("attiny261",            ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261__",        0x0060, 1, "tn261")
-AVR_MCU ("attiny261a",           ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261A__",       0x0060, 1, "tn261a")
-AVR_MCU ("attiny461",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461__",        0x0060, 1, "tn461")
-AVR_MCU ("attiny461a",           ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461A__",       0x0060, 1, "tn461a")
-AVR_MCU ("attiny861",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861__",        0x0060, 1, "tn861")
-AVR_MCU ("attiny861a",           ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861A__",       0x0060, 1, "tn861a")
-AVR_MCU ("attiny43u",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny43U__",        0x0060, 1, "tn43u")
-AVR_MCU ("attiny87",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny87__",         0x0100, 1, "tn87")
-AVR_MCU ("attiny48",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny48__",         0x0100, 1, "tn48")
-AVR_MCU ("attiny88",             ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny88__",         0x0100, 1, "tn88")
-AVR_MCU ("at86rf401",            ARCH_AVR25, AVR_ISA_NONE, "__AVR_AT86RF401__",        0x0060, 1, "86401")
+AVR_MCU ("avr25",            ARCH_AVR25, AVR_ISA_NONE, NULL,                       0x0060, 0x0, 1)
+AVR_MCU ("ata5272",          ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA5272__",          0x0100, 0x0, 1)
+AVR_MCU ("ata6616c",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATA6616C__",         0x0100, 0x0, 1)
+AVR_MCU ("attiny13",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny13a",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny13A__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny2313",       ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313__",       0x0060, 0x0, 1)
+AVR_MCU ("attiny2313a",      ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny2313A__",      0x0060, 0x0, 1)
+AVR_MCU ("attiny24",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny24a",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny24A__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny4313",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny4313__",       0x0060, 0x0, 1)
+AVR_MCU ("attiny44",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny44a",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny44A__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny441",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny441__",        0x0100, 0x0, 1)
+AVR_MCU ("attiny84",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny84a",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny84A__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny25",         ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny25__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny45",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny45__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny85",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny85__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny261",        ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny261a",       ARCH_AVR25, AVR_SHORT_SP, "__AVR_ATtiny261A__",       0x0060, 0x0, 1)
+AVR_MCU ("attiny461",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny461a",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny461A__",       0x0060, 0x0, 1)
+AVR_MCU ("attiny861",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny861a",       ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny861A__",       0x0060, 0x0, 1)
+AVR_MCU ("attiny43u",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny43U__",        0x0060, 0x0, 1)
+AVR_MCU ("attiny87",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny87__",         0x0100, 0x0, 1)
+AVR_MCU ("attiny48",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny48__",         0x0100, 0x0, 1)
+AVR_MCU ("attiny88",         ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny88__",         0x0100, 0x0, 1)
+AVR_MCU ("attiny828",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny828__",        0x0100, 0x0, 1)
+AVR_MCU ("attiny841",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_ATtiny841__",        0x0100, 0x0, 1)
+AVR_MCU ("at86rf401",        ARCH_AVR25, AVR_ISA_NONE, "__AVR_AT86RF401__",        0x0060, 0x0, 1)
 /* Classic, > 8K, <= 64K.  */
-AVR_MCU ("avr3",                 ARCH_AVR3, AVR_ISA_NONE, NULL,                        0x0060, 1, "43355")
-AVR_MCU ("at43usb355",           ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT43USB355__",        0x0060, 1, "43355")
-AVR_MCU ("at76c711",             ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT76C711__",          0x0060, 1, "76711")
+AVR_MCU ("avr3",             ARCH_AVR3, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1)
+AVR_MCU ("at43usb355",       ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT43USB355__",        0x0060, 0x0, 1)
+AVR_MCU ("at76c711",         ARCH_AVR3, AVR_ISA_NONE, "__AVR_AT76C711__",          0x0060, 0x0, 1)
 /* Classic, == 128K.  */
-AVR_MCU ("avr31",                ARCH_AVR31, AVR_ERRATA_SKIP, NULL,                    0x0060, 2, "m103")
-AVR_MCU ("atmega103",            ARCH_AVR31, AVR_ERRATA_SKIP, "__AVR_ATmega103__",     0x0060, 2, "m103")
-AVR_MCU ("at43usb320",           ARCH_AVR31, AVR_ISA_NONE, "__AVR_AT43USB320__",       0x0060, 2, "43320")
+AVR_MCU ("avr31",            ARCH_AVR31, AVR_ERRATA_SKIP, NULL,                    0x0060, 0x0, 2)
+AVR_MCU ("atmega103",        ARCH_AVR31, AVR_ERRATA_SKIP, "__AVR_ATmega103__",     0x0060, 0x0, 2)
+AVR_MCU ("at43usb320",       ARCH_AVR31, AVR_ISA_NONE, "__AVR_AT43USB320__",       0x0060, 0x0, 2)
 /* Classic + MOVW + JMP/CALL.  */
-AVR_MCU ("avr35",                ARCH_AVR35, AVR_ISA_NONE, NULL,                       0x0100, 1, "usb162")
-AVR_MCU ("ata5505",              ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA5505__",          0x0100, 1, "a5505")
-AVR_MCU ("at90usb82",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB82__",        0x0100, 1, "usb82")
-AVR_MCU ("at90usb162",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB162__",       0x0100, 1, "usb162")
-AVR_MCU ("atmega8u2",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega8U2__",        0x0100, 1, "m8u2")
-AVR_MCU ("atmega16u2",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega16U2__",       0x0100, 1, "m16u2")
-AVR_MCU ("atmega32u2",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega32U2__",       0x0100, 1, "m32u2")
-AVR_MCU ("attiny167",            ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny167__",        0x0100, 1, "tn167")
-AVR_MCU ("attiny1634",           ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny1634__",       0x0100, 1, "tn1634")
+AVR_MCU ("avr35",            ARCH_AVR35, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 1)
+AVR_MCU ("ata5505",          ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA5505__",          0x0100, 0x0, 1)
+AVR_MCU ("ata6617c",         ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA6617C__",         0x0100, 0x0, 1)
+AVR_MCU ("ata664251",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATA664251__",        0x0100, 0x0, 1)
+AVR_MCU ("at90usb82",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB82__",        0x0100, 0x0, 1)
+AVR_MCU ("at90usb162",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_AT90USB162__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega8u2",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega8U2__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega16u2",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega16U2__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega32u2",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATmega32U2__",       0x0100, 0x0, 1)
+AVR_MCU ("attiny167",        ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny167__",        0x0100, 0x0, 1)
+AVR_MCU ("attiny1634",       ARCH_AVR35, AVR_ISA_NONE, "__AVR_ATtiny1634__",       0x0100, 0x0, 1)
 /* Enhanced, <= 8K.  */
-AVR_MCU ("avr4",                 ARCH_AVR4, AVR_ISA_NONE,  NULL,                       0x0060, 1, "m8")
-AVR_MCU ("ata6285",              ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6285__",          0x0100, 1, "a6285")
-AVR_MCU ("ata6286",              ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6286__",          0x0100, 1, "a6286")
-AVR_MCU ("atmega8",              ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8__",          0x0060, 1, "m8")
-AVR_MCU ("atmega8a",             ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8A__",         0x0060, 1, "m8a")
-AVR_MCU ("atmega48",             ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48__",         0x0100, 1, "m48")
-AVR_MCU ("atmega48a",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48A__",        0x0100, 1, "m48a")
-AVR_MCU ("atmega48p",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48P__",        0x0100, 1, "m48p")
-AVR_MCU ("atmega48pa",           ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PA__",       0x0100, 1, "m48pa")
-AVR_MCU ("atmega88",             ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88__",         0x0100, 1, "m88")
-AVR_MCU ("atmega88a",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88A__",        0x0100, 1, "m88a")
-AVR_MCU ("atmega88p",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88P__",        0x0100, 1, "m88p")
-AVR_MCU ("atmega88pa",           ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PA__",       0x0100, 1, "m88pa")
-AVR_MCU ("atmega8515",           ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8515__",       0x0060, 1, "m8515")
-AVR_MCU ("atmega8535",           ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8535__",       0x0060, 1, "m8535")
-AVR_MCU ("atmega8hva",           ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8HVA__",       0x0100, 1, "m8hva")
-AVR_MCU ("at90pwm1",             ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM1__",         0x0100, 1, "90pwm1")
-AVR_MCU ("at90pwm2",             ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2__",         0x0100, 1, "90pwm2")
-AVR_MCU ("at90pwm2b",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2B__",        0x0100, 1, "90pwm2b")
-AVR_MCU ("at90pwm3",             ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3__",         0x0100, 1, "90pwm3")
-AVR_MCU ("at90pwm3b",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3B__",        0x0100, 1, "90pwm3b")
-AVR_MCU ("at90pwm81",            ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM81__",        0x0100, 1, "90pwm81")
+AVR_MCU ("avr4",             ARCH_AVR4, AVR_ISA_NONE,  NULL,                       0x0060, 0x0, 1)
+AVR_MCU ("ata6285",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6285__",          0x0100, 0x0, 1)
+AVR_MCU ("ata6286",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6286__",          0x0100, 0x0, 1)
+AVR_MCU ("ata6289",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6289__",          0x0100, 0x0, 1)
+AVR_MCU ("ata6612c",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATA6612C__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega8",          ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8__",          0x0060, 0x0, 1)
+AVR_MCU ("atmega8a",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8A__",         0x0060, 0x0, 1)
+AVR_MCU ("atmega48",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega48a",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega48p",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega48pa",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega48pb",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega48PB__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega88",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega88a",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega88p",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega88pa",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega88pb",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega88PB__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega8515",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8515__",       0x0060, 0x0, 1)
+AVR_MCU ("atmega8535",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8535__",       0x0060, 0x0, 1)
+AVR_MCU ("atmega8hva",       ARCH_AVR4, AVR_ISA_NONE,  "__AVR_ATmega8HVA__",       0x0100, 0x0, 1)
+AVR_MCU ("at90pwm1",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM1__",         0x0100, 0x0, 1)
+AVR_MCU ("at90pwm2",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2__",         0x0100, 0x0, 1)
+AVR_MCU ("at90pwm2b",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM2B__",        0x0100, 0x0, 1)
+AVR_MCU ("at90pwm3",         ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3__",         0x0100, 0x0, 1)
+AVR_MCU ("at90pwm3b",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM3B__",        0x0100, 0x0, 1)
+AVR_MCU ("at90pwm81",        ARCH_AVR4, AVR_ISA_NONE,  "__AVR_AT90PWM81__",        0x0100, 0x0, 1)
 /* Enhanced, > 8K, <= 64K.  */
-AVR_MCU ("avr5",                 ARCH_AVR5, AVR_ISA_NONE, NULL,                        0x0060, 1, "m16")
-AVR_MCU ("ata5790",              ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790__",           0x0100, 1, "a5790")
-AVR_MCU ("ata5790n",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790N__",          0x0100, 1, "a5790n")
-AVR_MCU ("ata5795",              ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5795__",           0x0100, 1, "a5795")
-AVR_MCU ("atmega16",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16__",          0x0060, 1, "m16")
-AVR_MCU ("atmega16a",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16A__",         0x0060, 1, "m16a")
-AVR_MCU ("atmega161",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega161__",         0x0060, 1, "m161")
-AVR_MCU ("atmega162",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega162__",         0x0100, 1, "m162")
-AVR_MCU ("atmega163",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega163__",         0x0060, 1, "m163")
-AVR_MCU ("atmega164a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164A__",        0x0100, 1, "m164a")
-AVR_MCU ("atmega164p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164P__",        0x0100, 1, "m164p")
-AVR_MCU ("atmega164pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164PA__",       0x0100, 1, "m164pa")
-AVR_MCU ("atmega165",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165__",         0x0100, 1, "m165")
-AVR_MCU ("atmega165a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165A__",        0x0100, 1, "m165a")
-AVR_MCU ("atmega165p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165P__",        0x0100, 1, "m165p")
-AVR_MCU ("atmega165pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165PA__",       0x0100, 1, "m165pa")
-AVR_MCU ("atmega168",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168__",         0x0100, 1, "m168")
-AVR_MCU ("atmega168a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168A__",        0x0100, 1, "m168a")
-AVR_MCU ("atmega168p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168P__",        0x0100, 1, "m168p")
-AVR_MCU ("atmega168pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PA__",       0x0100, 1, "m168pa")
-AVR_MCU ("atmega169",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169__",         0x0100, 1, "m169")
-AVR_MCU ("atmega169a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169A__",        0x0100, 1, "m169a")
-AVR_MCU ("atmega169p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169P__",        0x0100, 1, "m169p")
-AVR_MCU ("atmega169pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169PA__",       0x0100, 1, "m169pa")
-AVR_MCU ("atmega16hvb",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVB__",       0x0100, 1, "m16hvb")
-AVR_MCU ("atmega16hvbrevb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVBREVB__",   0x0100, 1, "m16hvbrevb")
-AVR_MCU ("atmega16m1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16M1__",        0x0100, 1, "m16m1")
-AVR_MCU ("atmega16u4",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16U4__",        0x0100, 1, "m16u4")
-AVR_MCU ("atmega26hvg",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega26HVG__",       0x0100, 1, "m26hvg")
-AVR_MCU ("atmega32a",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32A__",         0x0060, 1, "m32a")
-AVR_MCU ("atmega32",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32__",          0x0060, 1, "m32")
-AVR_MCU ("atmega323",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega323__",         0x0060, 1, "m323")
-AVR_MCU ("atmega324a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324A__",        0x0100, 1, "m324a")
-AVR_MCU ("atmega324p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324P__",        0x0100, 1, "m324p")
-AVR_MCU ("atmega324pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324PA__",       0x0100, 1, "m324pa")
-AVR_MCU ("atmega325",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325__",         0x0100, 1, "m325")
-AVR_MCU ("atmega325a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325A__",        0x0100, 1, "m325a")
-AVR_MCU ("atmega325p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325P__",        0x0100, 1, "m325p")
-AVR_MCU ("atmega3250",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250__",        0x0100, 1, "m3250")
-AVR_MCU ("atmega3250a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250A__",       0x0100, 1, "m3250a")
-AVR_MCU ("atmega3250p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250P__",       0x0100, 1, "m3250p")
-AVR_MCU ("atmega3250pa",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250PA__",      0x0100, 1, "m3250pa")
-AVR_MCU ("atmega328",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328__",         0x0100, 1, "m328")
-AVR_MCU ("atmega328p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328P__",        0x0100, 1, "m328p")
-AVR_MCU ("atmega329",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329__",         0x0100, 1, "m329")
-AVR_MCU ("atmega329a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329A__",        0x0100, 1, "m329a")
-AVR_MCU ("atmega329p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329P__",        0x0100, 1, "m329p")
-AVR_MCU ("atmega329pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329PA__",       0x0100, 1, "m329pa")
-AVR_MCU ("atmega3290",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290__",        0x0100, 1, "m3290")
-AVR_MCU ("atmega3290a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290A__",       0x0100, 1, "m3290a")
-AVR_MCU ("atmega3290p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290P__",       0x0100, 1, "m3290p")
-AVR_MCU ("atmega3290pa",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290PA__",      0x0100, 1, "m3290pa")
-AVR_MCU ("atmega32c1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32C1__",        0x0100, 1, "m32c1")
-AVR_MCU ("atmega32m1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32M1__",        0x0100, 1, "m32m1")
-AVR_MCU ("atmega32u4",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U4__",        0x0100, 1, "m32u4")
-AVR_MCU ("atmega32u6",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U6__",        0x0100, 1, "m32u6")
-AVR_MCU ("atmega406",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega406__",         0x0100, 1, "m406")
-AVR_MCU ("atmega64",             ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64__",          0x0100, 1, "m64")
-AVR_MCU ("atmega64a",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64A__",         0x0100, 1, "m64a")
-AVR_MCU ("atmega640",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega640__",         0x0200, 1, "m640")
-AVR_MCU ("atmega644",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644__",         0x0100, 1, "m644")
-AVR_MCU ("atmega644a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644A__",        0x0100, 1, "m644a")
-AVR_MCU ("atmega644p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644P__",        0x0100, 1, "m644p")
-AVR_MCU ("atmega644pa",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644PA__",       0x0100, 1, "m644pa")
-AVR_MCU ("atmega645",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645__",         0x0100, 1, "m645")
-AVR_MCU ("atmega645a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645A__",        0x0100, 1, "m645a")
-AVR_MCU ("atmega645p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645P__",        0x0100, 1, "m645p")
-AVR_MCU ("atmega6450",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450__",        0x0100, 1, "m6450")
-AVR_MCU ("atmega6450a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450A__",       0x0100, 1, "m6450a")
-AVR_MCU ("atmega6450p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450P__",       0x0100, 1, "m6450p")
-AVR_MCU ("atmega649",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649__",         0x0100, 1, "m649")
-AVR_MCU ("atmega649a",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649A__",        0x0100, 1, "m649a")
-AVR_MCU ("atmega649p",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649P__",        0x0100, 1, "m649p")
-AVR_MCU ("atmega6490",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490__",        0x0100, 1, "m6490")
-AVR_MCU ("atmega16hva",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA__",       0x0100, 1, "m16hva")
-AVR_MCU ("atmega16hva2",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA2__",      0x0100, 1, "m16hva2")
-AVR_MCU ("atmega32hvb",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVB__",       0x0100, 1, "m32hvb")
-AVR_MCU ("atmega6490a",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490A__",       0x0100, 1, "m6490a")
-AVR_MCU ("atmega6490p",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490P__",       0x0100, 1, "m6490p")
-AVR_MCU ("atmega64c1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64C1__",        0x0100, 1, "m64c1")
-AVR_MCU ("atmega64m1",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64M1__",        0x0100, 1, "m64m1")
-AVR_MCU ("atmega64hve",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE__",       0x0100, 1, "m64hve")
-AVR_MCU ("atmega64rfa2",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64RFA2__",      0x0200, 1, "m64rfa2")
-AVR_MCU ("atmega64rfr2",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64RFR2__",      0x0200, 1, "m64rfr2")
-AVR_MCU ("atmega32hvbrevb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVBREVB__",   0x0100, 1, "m32hvbrevb")
-AVR_MCU ("atmega48hvf",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega48HVF__",       0x0100, 1, "m48hvf")
-AVR_MCU ("at90can32",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN32__",         0x0100, 1, "can32")
-AVR_MCU ("at90can64",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN64__",         0x0100, 1, "can64")
-AVR_MCU ("at90pwm161",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM161__",        0x0100, 1, "90pwm161")
-AVR_MCU ("at90pwm216",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM216__",        0x0100, 1, "90pwm216")
-AVR_MCU ("at90pwm316",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM316__",        0x0100, 1, "90pwm316")
-AVR_MCU ("at90scr100",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90SCR100__",        0x0100, 1, "90scr100")
-AVR_MCU ("at90usb646",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB646__",        0x0100, 1, "usb646")
-AVR_MCU ("at90usb647",           ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB647__",        0x0100, 1, "usb647")
-AVR_MCU ("at94k",                ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT94K__",             0x0060, 1, "at94k")
-AVR_MCU ("m3000",                ARCH_AVR5, AVR_ISA_NONE, "__AVR_M3000__",             0x1000, 1, "m3000")
+AVR_MCU ("avr5",             ARCH_AVR5, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1)
+AVR_MCU ("ata5702m322",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5702M322__",       0x0200, 0x0, 1)
+AVR_MCU ("ata5782",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5782__",           0x0200, 0x8000, 1)
+AVR_MCU ("ata5790",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790__",           0x0100, 0x0, 1)
+AVR_MCU ("ata5790n",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5790N__",          0x0100, 0x0, 1)
+AVR_MCU ("ata5791",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5791__",           0x0100, 0x0, 1)
+AVR_MCU ("ata5795",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5795__",           0x0100, 0x0, 1)
+AVR_MCU ("ata5831",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA5831__",           0x0200, 0x8000, 1)
+AVR_MCU ("ata6613c",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6613C__",          0x0100, 0x0, 1)
+AVR_MCU ("ata6614q",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA6614Q__",          0x0100, 0x0, 1)
+AVR_MCU ("ata8210",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA8210__",           0x0200, 0x8000, 1)
+AVR_MCU ("ata8510",          ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATA8510__",           0x0200, 0x8000, 1)
+AVR_MCU ("atmega16",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16__",          0x0060, 0x0, 1)
+AVR_MCU ("atmega16a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16A__",         0x0060, 0x0, 1)
+AVR_MCU ("atmega161",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega161__",         0x0060, 0x0, 1)
+AVR_MCU ("atmega162",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega162__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega163",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega163__",         0x0060, 0x0, 1)
+AVR_MCU ("atmega164a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega164p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega164pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega164PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega165",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega165a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega165p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega165pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega165PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega168",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega168a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega168p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega168pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega168pb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega168PB__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega169",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega169a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega169p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega169pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega169PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega16hvb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVB__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega16hvbrevb",  ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVBREVB__",   0x0100, 0x0, 1)
+AVR_MCU ("atmega16m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16M1__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega16u4",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16U4__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega32a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32A__",         0x0060, 0x0, 1)
+AVR_MCU ("atmega32",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32__",          0x0060, 0x0, 1)
+AVR_MCU ("atmega323",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega323__",         0x0060, 0x0, 1)
+AVR_MCU ("atmega324a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega324p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega324pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega324PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega325",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega325a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega325p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega325pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega325PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega3250",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega3250a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250A__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega3250p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250P__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega3250pa",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3250PA__",      0x0100, 0x0, 1)
+AVR_MCU ("atmega328",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega328p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega328P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega329",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega329a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega329p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega329pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega329PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega3290",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega3290a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290A__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega3290p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290P__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega3290pa",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega3290PA__",      0x0100, 0x0, 1)
+AVR_MCU ("atmega32c1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32C1__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega32m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32M1__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega32u4",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U4__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega32u6",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32U6__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega406",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega406__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega64",         ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64__",          0x0100, 0x0, 1)
+AVR_MCU ("atmega64a",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64A__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega640",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega640__",         0x0200, 0x0, 1)
+AVR_MCU ("atmega644",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega644a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega644p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega644pa",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644PA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega645",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega645a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega645p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega645P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega6450",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega6450a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450A__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega6450p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6450P__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega649",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649__",         0x0100, 0x0, 1)
+AVR_MCU ("atmega649a",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649A__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega649p",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega649P__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega6490",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega16hva",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega16hva2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega16HVA2__",      0x0100, 0x0, 1)
+AVR_MCU ("atmega32hvb",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVB__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega6490a",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490A__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega6490p",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega6490P__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega64c1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64C1__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega64m1",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64M1__",        0x0100, 0x0, 1)
+AVR_MCU ("atmega64hve",      ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE__",       0x0100, 0x0, 1)
+AVR_MCU ("atmega64hve2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64HVE2__",      0x0100, 0x0, 1)
+AVR_MCU ("atmega64rfr2",     ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega64RFR2__",      0x0200, 0x0, 1)
+AVR_MCU ("atmega644rfr2",    ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega644RFR2__",     0x0200, 0x0, 1)
+AVR_MCU ("atmega32hvbrevb",  ARCH_AVR5, AVR_ISA_NONE, "__AVR_ATmega32HVBREVB__",   0x0100, 0x0, 1)
+AVR_MCU ("at90can32",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN32__",         0x0100, 0x0, 1)
+AVR_MCU ("at90can64",        ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90CAN64__",         0x0100, 0x0, 1)
+AVR_MCU ("at90pwm161",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM161__",        0x0100, 0x0, 1)
+AVR_MCU ("at90pwm216",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM216__",        0x0100, 0x0, 1)
+AVR_MCU ("at90pwm316",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90PWM316__",        0x0100, 0x0, 1)
+AVR_MCU ("at90scr100",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90SCR100__",        0x0100, 0x0, 1)
+AVR_MCU ("at90usb646",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB646__",        0x0100, 0x0, 1)
+AVR_MCU ("at90usb647",       ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT90USB647__",        0x0100, 0x0, 1)
+AVR_MCU ("at94k",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_AT94K__",             0x0060, 0x0, 1)
+AVR_MCU ("m3000",            ARCH_AVR5, AVR_ISA_NONE, "__AVR_M3000__",             0x1000, 0x0, 1)
 /* Enhanced, == 128K.  */
-AVR_MCU ("avr51",                ARCH_AVR51, AVR_ISA_NONE, NULL,                       0x0100, 2, "m128")
-AVR_MCU ("atmega128",            ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128__",        0x0100, 2, "m128")
-AVR_MCU ("atmega128a",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128A__",       0x0100, 2, "m128a")
-AVR_MCU ("atmega1280",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1280__",       0x0200, 2, "m1280")
-AVR_MCU ("atmega1281",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1281__",       0x0200, 2, "m1281")
-AVR_MCU ("atmega1284",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284__",       0x0100, 2, "m1284")
-AVR_MCU ("atmega1284p",          ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284P__",      0x0100, 2, "m1284p")
-AVR_MCU ("atmega128rfa1",        ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFA1__",    0x0200, 2, "m128rfa1")
-AVR_MCU ("at90can128",           ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90CAN128__",       0x0100, 2, "can128")
-AVR_MCU ("at90usb1286",          ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1286__",      0x0100, 2, "usb1286")
-AVR_MCU ("at90usb1287",          ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1287__",      0x0100, 2, "usb1287")
+AVR_MCU ("avr51",            ARCH_AVR51, AVR_ISA_NONE, NULL,                       0x0100, 0x0, 2)
+AVR_MCU ("atmega128",        ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128__",        0x0100, 0x0, 2)
+AVR_MCU ("atmega128a",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128A__",       0x0100, 0x0, 2)
+AVR_MCU ("atmega1280",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1280__",       0x0200, 0x0, 2)
+AVR_MCU ("atmega1281",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1281__",       0x0200, 0x0, 2)
+AVR_MCU ("atmega1284",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284__",       0x0100, 0x0, 2)
+AVR_MCU ("atmega1284p",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284P__",      0x0100, 0x0, 2)
+AVR_MCU ("atmega128rfa1",    ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFA1__",    0x0200, 0x0, 2)
+AVR_MCU ("atmega128rfr2",    ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega128RFR2__",    0x0200, 0x0, 2)
+AVR_MCU ("atmega1284rfr2",   ARCH_AVR51, AVR_ISA_NONE, "__AVR_ATmega1284RFR2__",   0x0200, 0x0, 2)
+AVR_MCU ("at90can128",       ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90CAN128__",       0x0100, 0x0, 2)
+AVR_MCU ("at90usb1286",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1286__",      0x0100, 0x0, 2)
+AVR_MCU ("at90usb1287",      ARCH_AVR51, AVR_ISA_NONE, "__AVR_AT90USB1287__",      0x0100, 0x0, 2)
 /* 3-Byte PC.  */
-AVR_MCU ("avr6",                 ARCH_AVR6, AVR_ISA_NONE, NULL,                        0x0200, 4, "m2561")
-AVR_MCU ("atmega2560",           ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2560__",        0x0200, 4, "m2560")
-AVR_MCU ("atmega2561",           ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2561__",        0x0200, 4, "m2561")
+AVR_MCU ("avr6",             ARCH_AVR6, AVR_ISA_NONE, NULL,                        0x0200, 0x0, 4)
+AVR_MCU ("atmega2560",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2560__",        0x0200, 0x0, 4)
+AVR_MCU ("atmega2561",       ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2561__",        0x0200, 0x0, 4)
+AVR_MCU ("atmega256rfr2",    ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega256RFR2__",     0x0200, 0x0, 4)
+AVR_MCU ("atmega2564rfr2",   ARCH_AVR6, AVR_ISA_NONE, "__AVR_ATmega2564RFR2__",    0x0200, 0x0, 4)
 /* Xmega, 16K <= Flash < 64K, RAM <= 64K */
-AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, AVR_ISA_NONE, NULL,                       0x2000, 1, "x32a4")
-AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16A4__",      0x2000, 1, "x16a4")
-AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16D4__",      0x2000, 1, "x16d4")
-AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32A4__",      0x2000, 1, "x32a4")
-AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D4__",      0x2000, 1, "x32d4")
-AVR_MCU ("atxmega32x1",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32X1__",      0x2000, 1, "x32x1")
-AVR_MCU ("atmxt112sl",       ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATMXT112SL__",       0x2000, 1, "mxt112sl")
-AVR_MCU ("atmxt224",         ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATMXT224__",         0x2000, 1, "mxt224")
-AVR_MCU ("atmxt224e",        ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATMXT224E__",        0x2000, 1, "mxt224e")
-AVR_MCU ("atmxt336s",        ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATMXT336S__",        0x2000, 1, "mxt336s")
-AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16A4U__",     0x2000, 1, "x16a4u")
-AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16C4__",      0x2000, 1, "x16c4")
-AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32A4U__",     0x2000, 1, "x32a4u")
-AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C4__",      0x2000, 1, "x32c4")
-AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32E5__",      0x2000, 1, "x32e5")
+AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 1)
+AVR_MCU ("atxmega8e5",       ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega8E5__",   0x2000, 0x0, 1)
+AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16A4__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16D4__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega16e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega16E5__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32A4__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega32c3",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C3__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega32d3",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D3__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32D4__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16A4U__", 0x2000, 0x0, 1)
+AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega16C4__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32A4U__", 0x2000, 0x0, 1)
+AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, AVR_ISA_RMW,  "__AVR_ATxmega32C4__",  0x2000, 0x0, 1)
+AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, AVR_ISA_NONE, "__AVR_ATxmega32E5__",  0x2000, 0x0, 1)
 /* Xmega, 64K < Flash <= 128K, RAM <= 64K */
-AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, AVR_ISA_NONE, NULL,                       0x2000, 2, "x64a4")
-AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64A3__",      0x2000, 2, "x64a3")
-AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D3__",      0x2000, 2, "x64d3")
-AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A3U__",     0x2000, 2, "x64a3u")
-AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A4U__",     0x2000, 2, "x64a4u")
-AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B1__",      0x2000, 2, "x64b1")
-AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B3__",      0x2000, 2, "x64b3")
-AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64C3__",      0x2000, 2, "x64c3")
-AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D4__",      0x2000, 2, "x64d4")
+AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 2)
+AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64A3__",  0x2000, 0x0, 2)
+AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D3__",  0x2000, 0x0, 2)
+AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A3U__", 0x2000, 0x0, 2)
+AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64A4U__", 0x2000, 0x0, 2)
+AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B1__",  0x2000, 0x0, 2)
+AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64B3__",  0x2000, 0x0, 2)
+AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, AVR_ISA_RMW,  "__AVR_ATxmega64C3__",  0x2000, 0x0, 2)
+AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, AVR_ISA_NONE, "__AVR_ATxmega64D4__",  0x2000, 0x0, 2)
 /* Xmega, 64K < Flash <= 128K, RAM > 64K */
-AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, AVR_ISA_NONE, NULL,                       0x2000, 2, "x64a1")
-AVR_MCU ("atxmega64a1",      ARCH_AVRXMEGA5, AVR_ISA_NONE, "__AVR_ATxmega64A1__",      0x2000, 2, "x64a1")
-AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, AVR_ISA_RMW,  "__AVR_ATxmega64A1U__",     0x2000, 2, "x64a1u")
+AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, AVR_ISA_NONE, NULL,                   0x2000, 0x0, 2)
+AVR_MCU ("atxmega64a1",      ARCH_AVRXMEGA5, AVR_ISA_NONE, "__AVR_ATxmega64A1__",  0x2000, 0x0, 2)
+AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, AVR_ISA_RMW,  "__AVR_ATxmega64A1U__", 0x2000, 0x0, 2)
 /* Xmega, 128K < Flash, RAM <= 64K */
-AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, AVR_ISA_NONE, NULL,                       0x2000, 6, "x128a3")
-AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128A3__",     0x2000, 3, "x128a3")
-AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D3__",     0x2000, 3, "x128d3")
-AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192A3__",     0x2000, 4, "x192a3")
-AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192D3__",     0x2000, 4, "x192d3")
-AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3__",     0x2000, 5, "x256a3")
-AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3B__",    0x2000, 5, "x256a3b")
-AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3BU__",   0x2000, 5, "x256a3bu")
-AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256D3__",     0x2000, 5, "x256d3")
-AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW, "__AVR_ATxmega128A3U__",    0x2000, 3, "x128a3u")
-AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B1__",     0x2000, 3, "x128b1")
-AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B3__",     0x2000, 3, "x128b3")
-AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128C3__",     0x2000, 3, "x128c3")
-AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D4__",     0x2000, 3, "x128d4")
-AVR_MCU ("atmxt540s",        ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATMXT540S__",        0x2000, 2, "mxt540s")
-AVR_MCU ("atmxt540sreva",    ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATMXT540SREVA__",    0x2000, 2, "mxt540sreva")
-AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192A3U__",    0x2000, 4, "x192a3u")
-AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192C3__",     0x2000, 4, "x192c3")
-AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3U__",    0x2000, 5, "x256a3u")
-AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256C3__",     0x2000, 5, "x256c3")
-AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega384C3__",     0x2000, 6, "x384c3")
-AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega384D3__",     0x2000, 6, "x384d3")
+AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 6)
+AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128A3__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128A3U__",    0x2000, 0x0, 3)
+AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B1__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128B3__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega128C3__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D3__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega128D4__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192A3__",     0x2000, 0x0, 4)
+AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192A3U__",    0x2000, 0x0, 4)
+AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega192C3__",     0x2000, 0x0, 4)
+AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega192D3__",     0x2000, 0x0, 4)
+AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3__",     0x2000, 0x0, 5)
+AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256A3B__",    0x2000, 0x0, 5)
+AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3BU__",   0x2000, 0x0, 5)
+AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256A3U__",    0x2000, 0x0, 5)
+AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega256C3__",     0x2000, 0x0, 5)
+AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega256D3__",     0x2000, 0x0, 5)
+AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, AVR_ISA_RMW,  "__AVR_ATxmega384C3__",     0x2000, 0x0, 6)
+AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, AVR_ISA_NONE, "__AVR_ATxmega384D3__",     0x2000, 0x0, 6)
 /* Xmega, 128K < Flash, RAM > 64K RAM.  */
-AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, AVR_ISA_NONE, NULL,                       0x2000, 3, "x128a1")
-AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, AVR_ISA_NONE, "__AVR_ATxmega128A1__",     0x2000, 3, "x128a1")
-AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A1U__",    0x2000, 3, "x128a1u")
-AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A4U__",    0x2000, 3, "x128a4u")
+AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, AVR_ISA_NONE, NULL,                       0x2000, 0x0, 3)
+AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, AVR_ISA_NONE, "__AVR_ATxmega128A1__",     0x2000, 0x0, 3)
+AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A1U__",    0x2000, 0x0, 3)
+AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  "__AVR_ATxmega128A4U__",    0x2000, 0x0, 3)
+/* Tiny family */
+AVR_MCU ("avrtiny",          ARCH_AVRTINY, AVR_ISA_NONE, NULL,                     0x0040, 0x0, 1)
+AVR_MCU ("attiny4",          ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny4__",        0x0040, 0x0, 1)
+AVR_MCU ("attiny5",          ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny5__",        0x0040, 0x0, 1)
+AVR_MCU ("attiny9",          ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny9__",        0x0040, 0x0, 1) 
+AVR_MCU ("attiny10",         ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny10__",       0x0040, 0x0, 1)
+AVR_MCU ("attiny20",         ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny20__",       0x0040, 0x0, 1)
+AVR_MCU ("attiny40",         ARCH_AVRTINY, AVR_ISA_NONE, "__AVR_ATtiny40__",       0x0040, 0x0, 1)
 /* Assembler only.  */
-AVR_MCU ("avr1",                 ARCH_AVR1, AVR_ISA_NONE, NULL,                        0x0060, 1, "s1200")
-AVR_MCU ("at90s1200",            ARCH_AVR1, AVR_ISA_NONE, "__AVR_AT90S1200__",         0x0060, 1, "s1200")
-AVR_MCU ("attiny11",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny11__",          0x0060, 1, "tn11")
-AVR_MCU ("attiny12",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny12__",          0x0060, 1, "tn12")
-AVR_MCU ("attiny15",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny15__",          0x0060, 1, "tn15")
-AVR_MCU ("attiny28",             ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny28__",          0x0060, 1, "tn28")
+AVR_MCU ("avr1",             ARCH_AVR1, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1)
+AVR_MCU ("at90s1200",        ARCH_AVR1, AVR_ISA_NONE, "__AVR_AT90S1200__",         0x0060, 0x0, 1)
+AVR_MCU ("attiny11",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny11__",          0x0060, 0x0, 1)
+AVR_MCU ("attiny12",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny12__",          0x0060, 0x0, 1)
+AVR_MCU ("attiny15",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny15__",          0x0060, 0x0, 1)
+AVR_MCU ("attiny28",         ARCH_AVR1, AVR_ISA_NONE, "__AVR_ATtiny28__",          0x0060, 0x0, 1)
diff --git a/gcc/config/avr/avr-protos.h b/gcc/config/avr/avr-protos.h
index c5ce784..82e06e2 100644
--- a/gcc/config/avr/avr-protos.h
+++ b/gcc/config/avr/avr-protos.h
@@ -33,7 +33,8 @@ extern void avr_register_target_pragmas (void);
 extern void avr_init_expanders (void);
 
 #ifdef TREE_CODE
-extern void avr_asm_output_aligned_decl_common (FILE*, const_tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);
+extern void avr_asm_output_aligned_decl_common (FILE*, tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);
+extern void avr_asm_asm_output_aligned_bss (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int, void (*) (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int));
 extern void asm_output_external (FILE *file, tree decl, char *name);
 extern int avr_progmem_p (tree decl, tree attributes);
 
@@ -45,6 +46,7 @@ extern void avr_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx, tree);
 
 #ifdef RTX_CODE
 extern int avr_hard_regno_call_part_clobbered (unsigned, enum machine_mode);
+extern bool tiny_valid_direct_memory_access_range(rtx, enum machine_mode);
 extern const char *output_movqi (rtx insn, rtx operands[], int *l);
 extern const char *output_movhi (rtx insn, rtx operands[], int *l);
 extern const char *output_movsisf (rtx insn, rtx operands[], int *l);
@@ -55,6 +57,7 @@ extern const char *avr_out_compare (rtx, rtx*, int*);
 extern const char *avr_out_compare64 (rtx, rtx*, int*);
 extern const char *ret_cond_branch (rtx x, int len, int reverse);
 extern const char *avr_out_movpsi (rtx, rtx*, int*);
+extern const char *avr_out_sign_extend (rtx, rtx*, int*);
 
 extern const char *ashlqi3_out (rtx insn, rtx operands[], int *len);
 extern const char *ashlhi3_out (rtx insn, rtx operands[], int *len);
@@ -123,6 +126,16 @@ extern bool avr_mem_flash_p (rtx);
 extern bool avr_mem_memx_p (rtx);
 extern bool avr_load_libgcc_p (rtx);
 extern bool avr_xload_libgcc_p (enum machine_mode);
+extern rtx avr_eval_addr_attrib (rtx x);
+
+static inline unsigned
+regmask (enum machine_mode mode, unsigned regno)
+{
+  return ((1u << GET_MODE_SIZE (mode)) - 1) << regno;
+}
+
+extern void avr_fix_inputs (rtx*, unsigned, unsigned);
+extern bool avr_emit3_fix_outputs (rtx (*)(rtx,rtx,rtx), rtx*, unsigned, unsigned);
 
 extern rtx lpm_reg_rtx;
 extern rtx lpm_addr_reg_rtx;
@@ -141,12 +154,11 @@ extern bool avr_have_dimode;
 
 /* From avr-log.c */
 
-#define avr_edump (avr_log_set_caller_e (__FUNCTION__))
-#define avr_fdump (avr_log_set_caller_f (__FUNCTION__))
-
-extern int (*avr_log_set_caller_e (const char*))(const char*, ...);
-extern int (*avr_log_set_caller_f (const char*))(FILE*, const char*, ...);
+#define avr_dump(...) avr_vdump (NULL, __FUNCTION__, __VA_ARGS__)
+#define avr_edump(...) avr_vdump (stderr, __FUNCTION__, __VA_ARGS__)
+#define avr_fdump(FIL, ...) avr_vdump (FIL, __FUNCTION__, __VA_ARGS__)
 
+extern int avr_vdump (FILE*, const char*, ...);
 extern void avr_log_set_avr_log (void);
 
 typedef struct
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index fa979df..519fb83 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -32,6 +32,7 @@
 #include "flags.h"
 #include "reload.h"
 #include "tree.h"
+#include "varasm.h"
 #include "print-tree.h"
 #include "calls.h"
 #include "stor-layout.h"
@@ -51,6 +52,8 @@
 #include "target-def.h"
 #include "params.h"
 #include "df.h"
+#include "context.h"
+#include "tree-pass.h"
 
 /* Maximal allowed offset for an address in the LD command */
 #define MAX_LD_OFFSET(MODE) (64 - (signed)GET_MODE_SIZE (MODE))
@@ -81,6 +84,17 @@
   ((SYMBOL_REF_FLAGS (sym) & AVR_SYMBOL_FLAG_PROGMEM)           \
    / SYMBOL_FLAG_MACH_DEP)
 
+#define TINY_ADIW(REG1, REG2, I)                                \
+    "subi " #REG1 ",lo8(-(" #I "))" CR_TAB                      \
+    "sbci " #REG2 ",hi8(-(" #I "))"
+
+#define TINY_SBIW(REG1, REG2, I)                                \
+    "subi " #REG1 ",lo8((" #I "))" CR_TAB                       \
+    "sbci " #REG2 ",hi8((" #I "))"
+
+#define AVR_TMP_REGNO (AVR_TINY ? TMP_REGNO_TINY : TMP_REGNO)
+#define AVR_ZERO_REGNO (AVR_TINY ? ZERO_REGNO_TINY : ZERO_REGNO)
+
 /* Known address spaces.  The order must be the same as in the respective
    enum from avr.h (or designated initialized must be used).  */
 const avr_addrspace_t avr_addrspace[ADDR_SPACE_COUNT] =
@@ -149,6 +163,9 @@ static bool avr_rtx_costs (rtx, int, int, int, int*, bool);
 /* Allocate registers from r25 to r8 for parameters for function calls.  */
 #define FIRST_CUM_REG 26
 
+/* Last call saved register */
+#define LAST_CALLEE_SAVED_REG (AVR_TINY ? 19 : 17)
+
 /* Implicit target register of LPM instruction (R0) */
 extern GTY(()) rtx lpm_reg_rtx;
 rtx lpm_reg_rtx;
@@ -188,10 +205,7 @@ static GTY(()) rtx xstring_empty;
 static GTY(()) rtx xstring_e;
 
 /* Current architecture.  */
-const avr_arch_t *avr_current_arch;
-
-/* Current device.  */
-const avr_mcu_t *avr_current_device;
+const avr_arch_t *avr_arch;
 
 /* Section to put switch tables in.  */
 static GTY(()) section *progmem_swtable_section;
@@ -285,6 +299,101 @@ avr_to_int_mode (rtx x)
 }
 
 
+static const pass_data avr_pass_data_recompute_notes =
+{
+  RTL_PASS,       // type
+  "",             // name (will be patched)
+  OPTGROUP_NONE,  // optinfo_flags
+  false,          // has_gate
+  true,           // has_execute
+  TV_DF_SCAN,     // tv_id
+  0,              // properties_required
+  0,              // properties_provided
+  0,              // properties_destroyed
+  0,              // todo_flags_start
+  // todo_flags_finish
+  TODO_df_finish | TODO_verify_rtl_sharing | TODO_verify_flow
+};
+
+
+class avr_pass_recompute_notes : public rtl_opt_pass
+{
+public:
+  avr_pass_recompute_notes (gcc::context *ctxt, const char *name)
+    : rtl_opt_pass (avr_pass_data_recompute_notes, ctxt)
+  {
+    this->name = name;
+  }
+
+  unsigned int execute (void)
+  {
+    df_note_add_problem ();
+    df_analyze ();
+
+    return 0;
+  }
+}; // avr_pass_recompute_notes
+
+
+static void
+avr_register_passes (void)
+{
+  /* This avr-specific pass (re)computes insn notes, in particular REG_DEAD
+     notes which are used by `avr.c::reg_unused_after' and branch offset
+     computations.  These notes must be correct, i.e. there must be no
+     dangling REG_DEAD notes; otherwise wrong code might result, cf. PR64331.
+
+     DF needs (correct) CFG, hence right before free_cfg is the last
+     opportunity to rectify notes.  */
+
+  register_pass (new avr_pass_recompute_notes (g, "avr-notes-free-cfg"),
+                 PASS_POS_INSERT_BEFORE, "*free_cfg", 1);
+}
+
+
+/* Set `avr_arch' as specified by `-mmcu='.
+   Return true on success.  */
+
+static bool
+avr_set_core_architecture (void)
+{
+  /* Search for mcu core architecture.  */
+
+  if (!avr_mmcu)
+    avr_mmcu = AVR_MMCU_DEFAULT;
+
+  avr_arch = &avr_arch_types[0];
+
+  for (const avr_mcu_t *mcu = avr_mcu_types; ; mcu++)
+    {
+      if (NULL == mcu->name)
+        {
+          /* Reached the end of `avr_mcu_types'.  This should actually never
+             happen as options are provided by device-specs.  It could be a
+             typo in a device-specs or calling the compiler proper directly
+             with -mmcu=<device>. */
+
+          error ("unknown core architecture %qs specified with %qs",
+                 avr_mmcu, "-mmcu=");
+          avr_inform_core_architectures ();
+          break;
+        }
+      else if (0 == strcmp (mcu->name, avr_mmcu)
+               // Is this a proper architecture ? 
+               && NULL == mcu->macro)
+        {
+          avr_arch = &avr_arch_types[mcu->arch_id];
+          if (avr_n_flash < 0)
+            avr_n_flash = mcu->n_flash;
+
+          return true;
+        }
+    }
+
+  return false;
+}
+
+
 /* Implement `TARGET_OPTION_OVERRIDE'.  */
 
 static void
@@ -323,29 +432,37 @@ avr_option_override (void)
   if (flag_pie == 2)
     warning (OPT_fPIE, "-fPIE is not supported");
 
-  avr_current_device = &avr_mcu_types[avr_mcu_index];
-  avr_current_arch = &avr_arch_types[avr_current_device->arch];
+  if (!avr_set_core_architecture())
+    return;
 
   /* RAM addresses of some SFRs common to all devices in respective arch. */
 
   /* SREG: Status Register containing flags like I (global IRQ) */
-  avr_addr.sreg = 0x3F + avr_current_arch->sfr_offset;
+  avr_addr.sreg = 0x3F + avr_arch->sfr_offset;
 
   /* RAMPZ: Address' high part when loading via ELPM */
-  avr_addr.rampz = 0x3B + avr_current_arch->sfr_offset;
+  avr_addr.rampz = 0x3B + avr_arch->sfr_offset;
 
-  avr_addr.rampy = 0x3A + avr_current_arch->sfr_offset;
-  avr_addr.rampx = 0x39 + avr_current_arch->sfr_offset;
-  avr_addr.rampd = 0x38 + avr_current_arch->sfr_offset;
-  avr_addr.ccp = 0x34 + avr_current_arch->sfr_offset;
+  avr_addr.rampy = 0x3A + avr_arch->sfr_offset;
+  avr_addr.rampx = 0x39 + avr_arch->sfr_offset;
+  avr_addr.rampd = 0x38 + avr_arch->sfr_offset;
+  avr_addr.ccp = (AVR_TINY ? 0x3C : 0x34) + avr_arch->sfr_offset;
 
   /* SP: Stack Pointer (SP_H:SP_L) */
-  avr_addr.sp_l = 0x3D + avr_current_arch->sfr_offset;
+  avr_addr.sp_l = 0x3D + avr_arch->sfr_offset;
   avr_addr.sp_h = avr_addr.sp_l + 1;
 
   init_machine_status = avr_init_machine_status;
 
+  if (!global_options_set.x_dwarf_version)
+    dwarf_version = 2;
+
   avr_log_set_avr_log();
+
+  /* Register some avr-specific pass(es).  There is no canonical place for
+     pass registration.  This function is convenient.  */
+
+  avr_register_passes ();
 }
 
 /* Function to set up the backend function structure.  */
@@ -369,8 +486,8 @@ avr_init_expanders (void)
     all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);
 
   lpm_reg_rtx  = all_regs_rtx[LPM_REGNO];
-  tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];
-  zero_reg_rtx = all_regs_rtx[ZERO_REGNO];
+  tmp_reg_rtx  = all_regs_rtx[AVR_TMP_REGNO];
+  zero_reg_rtx = all_regs_rtx[AVR_ZERO_REGNO];
 
   lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);
 
@@ -382,6 +499,11 @@ avr_init_expanders (void)
 
   xstring_empty = gen_rtx_CONST_STRING (VOIDmode, "");
   xstring_e = gen_rtx_CONST_STRING (VOIDmode, "e");
+
+  /* TINY core does not have regs r10-r16, but avr-dimode.md expects them
+     to be present */
+  if (AVR_TINY)
+    avr_have_dimode = false;
 }
 
 
@@ -527,6 +649,15 @@ avr_interrupt_function_p (tree func)
   return avr_lookup_function_attribute1 (func, "interrupt");
 }
 
+/* Return nonzero if FUNC is an nmi function as specified
+   by the "nmi" attribute.  */
+
+static int
+avr_nmi_function_p (tree func)
+{
+  return avr_lookup_function_attribute1 (func, "nmi");
+}
+
 /* Return nonzero if FUNC is a signal function as specified
    by the "signal" attribute.  */
 
@@ -574,15 +705,22 @@ avr_set_current_function (tree decl)
   cfun->machine->is_naked = avr_naked_function_p (decl);
   cfun->machine->is_signal = avr_signal_function_p (decl);
   cfun->machine->is_interrupt = avr_interrupt_function_p (decl);
+  cfun->machine->is_nmi = avr_nmi_function_p (decl);
   cfun->machine->is_OS_task = avr_OS_task_function_p (decl);
   cfun->machine->is_OS_main = avr_OS_main_function_p (decl);
 
-  isr = cfun->machine->is_interrupt ? "interrupt" : "signal";
+  if (cfun->machine->is_interrupt)
+    isr = "interrupt";
+  else if (cfun->machine->is_nmi)
+    isr = "nmi";
+  else
+    isr = "signal";
 
   /* Too much attributes make no sense as they request conflicting features. */
 
   if (cfun->machine->is_OS_task + cfun->machine->is_OS_main
-      + (cfun->machine->is_signal || cfun->machine->is_interrupt) > 1)
+      + (cfun->machine->is_signal || cfun->machine->is_interrupt 
+          || cfun->machine->is_nmi) > 1)
     error_at (loc, "function attributes %qs, %qs and %qs are mutually"
                " exclusive", "OS_task", "OS_main", isr);
 
@@ -593,7 +731,8 @@ avr_set_current_function (tree decl)
     warning_at (loc, OPT_Wattributes, "function attributes %qs and %qs have"
                 " no effect on %qs function", "OS_task", "OS_main", "naked");
 
-  if (cfun->machine->is_interrupt || cfun->machine->is_signal)
+  if (cfun->machine->is_interrupt || cfun->machine->is_signal 
+          || cfun->machine->is_nmi)
     {
       tree args = TYPE_ARG_TYPES (TREE_TYPE (decl));
       tree ret = TREE_TYPE (TREE_TYPE (decl));
@@ -890,7 +1029,7 @@ sequent_regs_live (void)
   int live_seq = 0;
   int cur_seq = 0;
 
-  for (reg = 0; reg < 18; ++reg)
+  for (reg = 0; reg <= LAST_CALLEE_SAVED_REG; ++reg)
     {
       if (fixed_regs[reg])
         {
@@ -1002,7 +1141,7 @@ emit_push_sfr (rtx sfr, bool frame_related_p, bool clr_p)
     RTX_FRAME_RELATED_P (insn) = 1;
 
   /* PUSH __tmp_reg__ */
-  emit_push_byte (TMP_REGNO, frame_related_p);
+  emit_push_byte (AVR_TMP_REGNO, frame_related_p);
 
   if (clr_p)
     {
@@ -1028,7 +1167,8 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
                    && live_seq
                    && !isr_p
                    && !cfun->machine->is_OS_task
-                   && !cfun->machine->is_OS_main);
+                   && !cfun->machine->is_OS_main
+                   && !AVR_TINY);
 
   if (minimize
       && (frame_pointer_needed
@@ -1065,11 +1205,11 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
       /* Note that live_seq always contains r28+r29, but the other
          registers to be saved are all below 18.  */
 
-      first_reg = 18 - (live_seq - 2);
+      first_reg = (LAST_CALLEE_SAVED_REG + 1) - (live_seq - 2);
 
       for (reg = 29, offset = -live_seq + 1;
            reg >= first_reg;
-           reg = (reg == 28 ? 17 : reg - 1), ++offset)
+           reg = (reg == 28 ? LAST_CALLEE_SAVED_REG : reg - 1), ++offset)
         {
           rtx m, r;
 
@@ -1308,10 +1448,10 @@ avr_expand_prologue (void)
         emit_insn (gen_enable_interrupt ());
 
       /* Push zero reg.  */
-      emit_push_byte (ZERO_REGNO, true);
+      emit_push_byte (AVR_ZERO_REGNO, true);
 
       /* Push tmp reg.  */
-      emit_push_byte (TMP_REGNO, true);
+      emit_push_byte (AVR_TMP_REGNO, true);
 
       /* Push SREG.  */
       /* ??? There's no dwarf2 column reserved for SREG.  */
@@ -1453,7 +1593,8 @@ avr_expand_epilogue (bool sibcall_p)
               && live_seq
               && !isr_p
               && !cfun->machine->is_OS_task
-              && !cfun->machine->is_OS_main);
+              && !cfun->machine->is_OS_main
+              && !AVR_TINY);
 
   if (minimize
       && (live_seq > 4
@@ -1611,14 +1752,14 @@ avr_expand_epilogue (bool sibcall_p)
 
       /* Restore SREG using tmp_reg as scratch.  */
 
-      emit_pop_byte (TMP_REGNO);
+      emit_pop_byte (AVR_TMP_REGNO);
       emit_move_insn (sreg_rtx, tmp_reg_rtx);
 
       /* Restore tmp REG.  */
-      emit_pop_byte (TMP_REGNO);
+      emit_pop_byte (AVR_TMP_REGNO);
 
       /* Restore zero REG.  */
-      emit_pop_byte (ZERO_REGNO);
+      emit_pop_byte (AVR_ZERO_REGNO);
     }
 
   if (!sibcall_p)
@@ -1749,6 +1890,16 @@ avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)
       break;
     }
 
+  if (AVR_TINY
+      && CONSTANT_ADDRESS_P (x))
+    {
+      /* avrtiny's load / store instructions only cover addresses 0..0xbf:
+         IN / OUT range is 0..0x3f and LDS / STS can access 0x40..0xbf.  */
+
+      ok = (CONST_INT_P (x)
+            && IN_RANGE (INTVAL (x), 0, 0xc0 - GET_MODE_SIZE (mode)));
+    }
+
   if (avr_log.legitimate_address_p)
     {
       avr_edump ("\n%?: ret=%d, mode=%m strict=%d "
@@ -2100,10 +2251,14 @@ avr_print_operand_punct_valid_p (unsigned char code)
 static void
 avr_print_operand (FILE *file, rtx x, int code)
 {
-  int abcd = 0;
+  int abcd = 0, ef = 0, ij = 0;
 
   if (code >= 'A' && code <= 'D')
     abcd = code - 'A';
+  else if (code == 'E' || code == 'F')
+    ef = code - 'E';
+  else if (code == 'I' || code == 'J')
+    ij = code - 'I';
 
   if (code == '~')
     {
@@ -2140,6 +2295,16 @@ avr_print_operand (FILE *file, rtx x, int code)
       else
         fatal_insn ("operands to %T/%t must be reg + const_int:", x);
     }
+  else if (code == 'E' || code == 'F')
+    {
+      rtx op = XEXP(x, 0);
+      fprintf (file, reg_names[REGNO (op) + ef]);
+    }
+  else if (code == 'I' || code == 'J')
+    {
+      rtx op = XEXP(XEXP(x, 0), 0);
+      fprintf (file, reg_names[REGNO (op) + ij]);
+    }
   else if (REG_P (x))
     {
       if (x == zero_reg_rtx)
@@ -2166,7 +2331,7 @@ avr_print_operand (FILE *file, rtx x, int code)
             fprintf (file, "__RAMPX__");
           else if (AVR_HAVE_RAMPD && ival == avr_addr.rampd)
             fprintf (file, "__RAMPD__");
-          else if (AVR_XMEGA && ival == avr_addr.ccp)
+          else if ((AVR_XMEGA || AVR_TINY) && ival == avr_addr.ccp)
             fprintf (file, "__CCP__");
           else if (ival == avr_addr.sreg)   fprintf (file, "__SREG__");
           else if (ival == avr_addr.sp_l)   fprintf (file, "__SP_L__");
@@ -2174,7 +2339,7 @@ avr_print_operand (FILE *file, rtx x, int code)
           else
             {
               fprintf (file, HOST_WIDE_INT_PRINT_HEX,
-                       ival - avr_current_arch->sfr_offset);
+                       ival - avr_arch->sfr_offset);
             }
         }
       else
@@ -2209,6 +2374,13 @@ avr_print_operand (FILE *file, rtx x, int code)
 
           avr_print_operand (file, XEXP (addr, 1), 0);
         }
+      else if (code == 'b')
+        {
+          if (GET_CODE (addr) != PLUS)
+               fatal_insn ("bad address, not (reg+disp):", addr);
+
+          avr_print_operand_address (file, XEXP (addr, 0));
+        }
       else if (code == 'p' || code == 'r')
         {
           if (GET_CODE (addr) != POST_INC && GET_CODE (addr) != PRE_DEC)
@@ -2233,7 +2405,11 @@ avr_print_operand (FILE *file, rtx x, int code)
     }
   else if (code == 'i')
     {
-      fatal_insn ("bad address, not an I/O address:", x);
+      if (GET_CODE (x) == SYMBOL_REF && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_IO))
+	avr_print_operand_address
+	  (file, plus_constant (HImode, x, -avr_arch->sfr_offset));
+      else
+	fatal_insn ("bad address, not an I/O address:", x);
     }
   else if (code == 'x')
     {
@@ -2562,7 +2738,7 @@ avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE op, rtx x)
 int
 avr_function_arg_regno_p(int r)
 {
-  return (r >= 8 && r <= 25);
+  return (AVR_TINY ? r >= 20 && r <= 25 : r >= 8 && r <= 25);
 }
 
 
@@ -2574,7 +2750,7 @@ void
 avr_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname,
                           tree fndecl ATTRIBUTE_UNUSED)
 {
-  cum->nregs = 18;
+  cum->nregs = AVR_TINY ? 6 : 18;
   cum->regno = FIRST_CUM_REG;
   if (!libname && stdarg_p (fntype))
     cum->nregs = 0;
@@ -2758,7 +2934,7 @@ avr_xload_libgcc_p (enum machine_mode mode)
   int n_bytes = GET_MODE_SIZE (mode);
 
   return (n_bytes > 1
-          || avr_current_device->n_flash > 1);
+          || avr_n_flash > 1);
 }
 
 
@@ -3110,7 +3286,6 @@ avr_out_xload (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)
   return "";
 }
 
-
 const char*
 output_movqi (rtx insn, rtx operands[], int *plen)
 {
@@ -3238,6 +3413,26 @@ output_movhi (rtx insn, rtx xop[], int *plen)
   return "";
 }
 
+
+/* Same as out_movqi_r_mr, but TINY does not have ADIW or SBIW */
+
+static const char*
+avr_out_movqi_r_mr_reg_disp_tiny (rtx insn, rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx x = XEXP (src, 0);
+
+  avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+               "ld %0,%b1" , op, plen, -3);
+
+  if (!reg_overlap_mentioned_p (dest, XEXP (x,0))
+      && !reg_unused_after (insn, XEXP (x,0)))
+    avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);
+
+  return "";
+}
+
 static const char*
 out_movqi_r_mr (rtx insn, rtx op[], int *plen)
 {
@@ -3247,11 +3442,13 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)
 
   if (CONSTANT_ADDRESS_P (x))
     {
+      int n_words = AVR_TINY ? 1 : 2;
       return optimize > 0 && io_address_operand (x, QImode)
         ? avr_asm_len ("in %0,%i1", op, plen, -1)
-        : avr_asm_len ("lds %0,%m1", op, plen, -2);
+        : avr_asm_len ("lds %0,%m1", op, plen, -n_words);
     }
-  else if (GET_CODE (x) == PLUS
+
+  if (GET_CODE (x) == PLUS
            && REG_P (XEXP (x, 0))
            && CONST_INT_P (XEXP (x, 1)))
     {
@@ -3259,6 +3456,9 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)
 
       int disp = INTVAL (XEXP (x, 1));
 
+      if (AVR_TINY)
+        return avr_out_movqi_r_mr_reg_disp_tiny (insn, op, plen);
+
       if (disp - GET_MODE_SIZE (GET_MODE (src)) >= 63)
         {
           if (REGNO (XEXP (x, 0)) != REG_Y)
@@ -3298,6 +3498,88 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)
   return avr_asm_len ("ld %0,%1", op, plen, -1);
 }
 
+
+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
+
+static const char*
+avr_out_movhi_r_mr_reg_no_disp_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  if (reg_dest == reg_base)         /* R = (R) */
+    return avr_asm_len ("ld __tmp_reg__,%1+" CR_TAB
+			"ld %B0,%1"          CR_TAB
+			"mov %A0,__tmp_reg__", op, plen, -3);
+
+  return avr_asm_len ("ld %A0,%1"             CR_TAB
+                      TINY_ADIW (%E1, %F1, 1) CR_TAB
+                      "ld %B0,%1"             CR_TAB
+                      TINY_SBIW (%E1, %F1, 1), op, plen, -6);
+}
+
+
+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
+
+static const char*
+avr_out_movhi_r_mr_reg_disp_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (XEXP (base, 0));
+
+  if (reg_base == reg_dest)
+    {
+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                          "ld __tmp_reg__,%b1+"     CR_TAB
+                          "ld %B0,%b1"              CR_TAB
+                          "mov %A0,__tmp_reg__", op, plen, -5);
+    }
+  else
+    {
+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                          "ld %A0,%b1+"             CR_TAB
+                          "ld %B0,%b1"              CR_TAB
+                          TINY_SBIW (%I1, %J1, %o1+1), op, plen, -6);
+    }
+}
+
+
+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
+
+static const char*
+avr_out_movhi_r_mr_pre_dec_tiny (rtx insn, rtx op[], int *plen)
+{
+  int mem_volatile_p = 0;
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+
+  /* "volatile" forces reading low byte first, even if less efficient,
+     for correct operation with 16-bit I/O registers.  */
+  mem_volatile_p = MEM_VOLATILE_P (src);
+
+  if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))
+    fatal_insn ("incorrect insn:", insn);
+
+  if (!mem_volatile_p)
+    return avr_asm_len ("ld %B0,%1" CR_TAB
+                        "ld %A0,%1", op, plen, -2);
+
+  return avr_asm_len (TINY_SBIW (%I1, %J1, 2)  CR_TAB
+                      "ld %A0,%p1+"            CR_TAB
+                      "ld %B0,%p1"             CR_TAB
+                      TINY_SBIW (%I1, %J1, 1), op, plen, -6);
+}
+
+
 static const char*
 out_movhi_r_mr (rtx insn, rtx op[], int *plen)
 {
@@ -3312,6 +3594,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_movhi_r_mr_reg_no_disp_tiny (op, plen);
+
       if (reg_dest == reg_base)         /* R = (R) */
         return avr_asm_len ("ld __tmp_reg__,%1+" CR_TAB
                             "ld %B0,%1"          CR_TAB
@@ -3334,6 +3619,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
       int disp = INTVAL (XEXP (base, 1));
       int reg_base = true_regnum (XEXP (base, 0));
 
+      if (AVR_TINY)
+        return avr_out_movhi_r_mr_reg_disp_tiny (op, plen);
+
       if (disp > MAX_LD_OFFSET (GET_MODE (src)))
         {
           if (REGNO (XEXP (base, 0)) != REG_Y)
@@ -3345,7 +3633,7 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
                            "ldd %B0,Y+63"    CR_TAB
                            "sbiw r28,%o1-62", op, plen, -4)
 
-            : avr_asm_len ("subi r28,lo8(-%o1)" CR_TAB
+              : avr_asm_len ("subi r28,lo8(-%o1)" CR_TAB
                            "sbci r29,hi8(-%o1)" CR_TAB
                            "ld %A0,Y"           CR_TAB
                            "ldd %B0,Y+1"        CR_TAB
@@ -3379,6 +3667,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
     }
   else if (GET_CODE (base) == PRE_DEC) /* (--R) */
     {
+      if (AVR_TINY)
+	return avr_out_movhi_r_mr_pre_dec_tiny (insn, op, plen);
+
       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))
         fatal_insn ("incorrect insn:", insn);
 
@@ -3406,12 +3697,13 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
     }
   else if (CONSTANT_ADDRESS_P (base))
     {
+      int n_words = AVR_TINY ? 2 : 4;
       return optimize > 0 && io_address_operand (base, HImode)
         ? avr_asm_len ("in %A0,%i1" CR_TAB
                        "in %B0,%i1+1", op, plen, -2)
 
         : avr_asm_len ("lds %A0,%m1" CR_TAB
-                       "lds %B0,%m1+1", op, plen, -4);
+                       "lds %B0,%m1+1", op, plen, -n_words);
     }
 
   fatal_insn ("unknown move insn:",insn);
@@ -3419,6 +3711,100 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
 }
 
 static const char*
+avr_out_movsi_r_mr_reg_no_disp_tiny (rtx insn, rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  if (reg_dest == reg_base)
+    {
+      /* "ld r26,-X" is undefined */
+      return *l = 9, (TINY_ADIW (%E1, %F1, 3) CR_TAB
+		      "ld %D0,%1"             CR_TAB
+		      "ld %C0,-%1"            CR_TAB
+		      "ld __tmp_reg__,-%1"    CR_TAB
+		      TINY_SBIW (%E1, %F1, 1) CR_TAB
+		      "ld %A0,%1"             CR_TAB
+		      "mov %B0,__tmp_reg__");
+    }
+  else if (reg_dest == reg_base - 2)
+    {
+      return *l = 5, ("ld %A0,%1+"            CR_TAB
+		      "ld %B0,%1+"            CR_TAB
+		      "ld __tmp_reg__,%1+"    CR_TAB
+		      "ld %D0,%1"             CR_TAB
+		      "mov %C0,__tmp_reg__");
+    }
+  else if (reg_unused_after (insn, base))
+    {
+      return *l = 4, ("ld %A0,%1+"    CR_TAB
+		      "ld %B0,%1+"    CR_TAB
+		      "ld %C0,%1+"    CR_TAB
+		      "ld %D0,%1");
+    }
+  else
+    {
+      return *l = 6, ("ld %A0,%1+"    CR_TAB
+		      "ld %B0,%1+"    CR_TAB
+		      "ld %C0,%1+"    CR_TAB
+		      "ld %D0,%1"     CR_TAB
+		      TINY_SBIW (%E1, %F1, 3));
+    }
+}
+
+
+static const char*
+avr_out_movsi_r_mr_reg_disp_tiny (rtx insn, rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (XEXP (base, 0));
+
+  if (reg_dest == reg_base)
+    {
+      /* "ld r26,-X" is undefined */
+      return *l = 9, (TINY_ADIW (%I1, %J1, %o1+3) CR_TAB
+                      "ld %D0,%b1"                CR_TAB
+                      "ld %C0,-%b1"               CR_TAB
+                      "ld __tmp_reg__,-%b1"       CR_TAB
+                      TINY_SBIW (%I1, %J1, 1)     CR_TAB
+                      "ld %A0,%b1"                CR_TAB
+                      "mov %B0,__tmp_reg__");
+    }
+  else if (reg_dest == reg_base - 2)
+    {
+      return *l = 7, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                      "ld %A0,%b1+"             CR_TAB
+                      "ld %B0,%b1+"             CR_TAB
+                      "ld __tmp_reg__,%b1+"     CR_TAB
+                      "ld %D0,%b1"              CR_TAB
+                      "mov %C0,__tmp_reg__");
+    }
+  else if (reg_unused_after (insn, XEXP (base, 0)))
+    {
+      return *l = 6, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                      "ld %A0,%b1+"             CR_TAB
+                      "ld %B0,%b1+"             CR_TAB
+                      "ld %C0,%b1+"             CR_TAB
+                      "ld %D0,%b1");
+    }
+  else
+    {
+      return *l = 8, (TINY_ADIW (%I1, %J1, %o1)  CR_TAB
+                      "ld %A0,%b1+"              CR_TAB
+                      "ld %B0,%b1+"              CR_TAB
+                      "ld %C0,%b1+"              CR_TAB
+                      "ld %D0,%b1"               CR_TAB
+                      TINY_SBIW (%I1, %J1, %o1+3));
+    }
+}
+
+static const char*
 out_movsi_r_mr (rtx insn, rtx op[], int *l)
 {
   rtx dest = op[0];
@@ -3433,6 +3819,9 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_movsi_r_mr_reg_no_disp_tiny (insn, op, l);
+
       if (reg_base == REG_X)        /* (R26) */
         {
           if (reg_dest == REG_X)
@@ -3487,6 +3876,9 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)
     {
       int disp = INTVAL (XEXP (base, 1));
 
+      if (AVR_TINY)
+        return avr_out_movsi_r_mr_reg_disp_tiny (insn, op, l);
+
       if (disp > MAX_LD_OFFSET (GET_MODE (src)))
 	{
 	  if (REGNO (XEXP (base, 0)) != REG_Y)
@@ -3570,16 +3962,134 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)
 		  "ld %C0,%1" CR_TAB
 		  "ld %D0,%1");
   else if (CONSTANT_ADDRESS_P (base))
-    return *l=8, ("lds %A0,%m1"   CR_TAB
+    {
+      if (io_address_operand (base, SImode))
+        {
+          *l = 4;
+          return ("in %A0,%i1"   CR_TAB
+                  "in %B0,%i1+1" CR_TAB
+                  "in %C0,%i1+2" CR_TAB
+                  "in %D0,%i1+3");
+        }
+      else
+        {
+          *l = AVR_TINY ? 4 : 8;
+          return ("lds %A0,%m1"   CR_TAB
                   "lds %B0,%m1+1" CR_TAB
                   "lds %C0,%m1+2" CR_TAB
                   "lds %D0,%m1+3");
+        }
+    }
 
   fatal_insn ("unknown move insn:",insn);
   return "";
 }
 
 static const char*
+avr_out_movsi_mr_r_reg_no_disp_tiny (rtx insn, rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = true_regnum (base);
+  int reg_src = true_regnum (src);
+
+  if (reg_base == reg_src)
+    {
+	  /* "ld r26,-X" is undefined */
+      if (reg_unused_after (insn, base))
+        {
+          return *l = 7, ("mov __tmp_reg__, %B1"  CR_TAB
+			  "st %0,%A1"             CR_TAB
+			  TINY_ADIW (%E0, %F0, 1) CR_TAB
+			  "st %0+,__tmp_reg__"    CR_TAB
+			  "st %0+,%C1"            CR_TAB
+			  "st %0+,%D1");
+        }
+      else
+        {
+          return *l = 9, ("mov __tmp_reg__, %B1"  CR_TAB
+			  "st %0,%A1"             CR_TAB
+			  TINY_ADIW (%E0, %F0, 1) CR_TAB
+			  "st %0+,__tmp_reg__"    CR_TAB
+			  "st %0+,%C1"            CR_TAB
+			  "st %0+,%D1"            CR_TAB
+			  TINY_SBIW (%E0, %F0, 3));
+        }
+    }
+  else if (reg_base == reg_src + 2)
+    {
+      if (reg_unused_after (insn, base))
+	return *l = 7, ("mov __zero_reg__,%C1" CR_TAB
+                        "mov __tmp_reg__,%D1"  CR_TAB
+                        "st %0+,%A1"           CR_TAB
+                        "st %0+,%B1"           CR_TAB
+                        "st %0+,__zero_reg__"  CR_TAB
+                        "st %0,__tmp_reg__"    CR_TAB
+                        "clr __zero_reg__");
+      else
+	return *l = 9, ("mov __zero_reg__,%C1" CR_TAB
+			"mov __tmp_reg__,%D1"  CR_TAB
+			"st %0+,%A1"           CR_TAB
+			"st %0+,%B1"           CR_TAB
+			"st %0+,__zero_reg__"  CR_TAB
+			"st %0,__tmp_reg__"    CR_TAB
+			"clr __zero_reg__"     CR_TAB
+			TINY_SBIW (%E0, %F0, 3));
+    }
+
+  return *l = 6, ("st %0+,%A1" CR_TAB
+		  "st %0+,%B1" CR_TAB
+		  "st %0+,%C1" CR_TAB
+		  "st %0,%D1"  CR_TAB
+		  TINY_SBIW (%E0, %F0, 3));
+}
+
+static const char*
+avr_out_movsi_mr_r_reg_disp_tiny (rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = REGNO (XEXP (base, 0));
+  int reg_src =true_regnum (src);
+
+  if (reg_base == reg_src)
+    {
+      *l = 11;
+      return ("mov __tmp_reg__,%A2"        CR_TAB
+              "mov __zero_reg__,%B2"       CR_TAB
+              TINY_ADIW (%I0, %J0, %o0)    CR_TAB
+              "st %b0+,__tmp_reg__"        CR_TAB
+              "st %b0+,__zero_reg__"       CR_TAB
+              "st %b0+,%C2"                CR_TAB
+              "st %b0,%D2"                 CR_TAB
+              "clr __zero_reg__"           CR_TAB
+              TINY_SBIW (%I0, %J0, %o0+3));
+    }
+  else if (reg_src == reg_base - 2)
+    {
+      *l = 11;
+      return ("mov __tmp_reg__,%C2"         CR_TAB
+              "mov __zero_reg__,%D2"        CR_TAB
+              TINY_ADIW (%I0, %J0, %o0)     CR_TAB
+              "st %b0+,%A0"                 CR_TAB
+              "st %b0+,%B0"                 CR_TAB
+              "st %b0+,__tmp_reg__"         CR_TAB
+              "st %b0,__zero_reg__"         CR_TAB
+              "clr __zero_reg__"            CR_TAB
+              TINY_SBIW (%I0, %J0, %o0+3));
+    }
+  *l = 8;
+  return (TINY_ADIW (%I0, %J0, %o0)     CR_TAB
+          "st %b0+,%A1"                 CR_TAB
+          "st %b0+,%B1"                 CR_TAB
+          "st %b0+,%C1"                 CR_TAB
+          "st %b0,%D1"                  CR_TAB
+          TINY_SBIW (%I0, %J0, %o0+3));
+}
+
+static const char*
 out_movsi_mr_r (rtx insn, rtx op[], int *l)
 {
   rtx dest = op[0];
@@ -3593,12 +4103,29 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)
     l = &tmp;
 
   if (CONSTANT_ADDRESS_P (base))
-    return *l=8,("sts %m0,%A1" CR_TAB
-                 "sts %m0+1,%B1" CR_TAB
-                 "sts %m0+2,%C1" CR_TAB
-                 "sts %m0+3,%D1");
+    {
+      if (io_address_operand (base, SImode))
+        {
+          return *l=4,("out %i0, %A1"  CR_TAB
+                       "out %i0+1,%B1" CR_TAB
+                       "out %i0+2,%C1" CR_TAB
+                       "out %i0+3,%D1");
+        }
+      else
+        {
+          *l = AVR_TINY ? 4 : 8;
+          return ("sts %m0,%A1"   CR_TAB
+                  "sts %m0+1,%B1" CR_TAB
+                  "sts %m0+2,%C1" CR_TAB
+                  "sts %m0+3,%D1");
+        }
+    }
+
   if (reg_base > 0)                 /* (r) */
     {
+      if (AVR_TINY)
+        return avr_out_movsi_mr_r_reg_no_disp_tiny (insn, op, l);
+
       if (reg_base == REG_X)                /* (R26) */
         {
           if (reg_src == REG_X)
@@ -3655,6 +4182,10 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)
   else if (GET_CODE (base) == PLUS) /* (R + i) */
     {
       int disp = INTVAL (XEXP (base, 1));
+
+      if (AVR_TINY)
+        return avr_out_movsi_mr_r_reg_disp_tiny (op, l);
+
       reg_base = REGNO (XEXP (base, 0));
       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))
 	{
@@ -3815,6 +4346,73 @@ output_movsisf (rtx insn, rtx operands[], int *l)
 /* Handle loads of 24-bit types from memory to register.  */
 
 static const char*
+avr_out_load_psi_reg_no_disp_tiny (rtx insn, rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  if (reg_base == reg_dest)
+    {
+      return avr_asm_len (TINY_ADIW (%E1, %F1, 2)   CR_TAB
+                          "ld %C0,%1"               CR_TAB
+                          "ld __tmp_reg__,-%1"      CR_TAB
+                          TINY_SBIW (%E1, %F1, 1)   CR_TAB
+                          "ld %A0,%1"               CR_TAB
+                          "mov %B0,__tmp_reg__", op, plen, -8);
+    }
+  else
+    {
+      avr_asm_len ("ld %A0,%1+"  CR_TAB
+		   "ld %B0,%1+"  CR_TAB
+		   "ld %C0,%1", op, plen, -3);
+
+      if (reg_dest != reg_base - 2 &&
+          !reg_unused_after (insn, base))
+        {
+          avr_asm_len (TINY_SBIW (%E1, %F1, 2), op, plen, 2);
+        }
+      return "";
+    }
+}
+
+static const char*
+avr_out_load_psi_reg_disp_tiny (rtx insn, rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  reg_base = true_regnum (XEXP (base, 0));
+  if (reg_base == reg_dest)
+    {
+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1+2) CR_TAB
+                          "ld %C0,%b1"                CR_TAB
+                          "ld __tmp_reg__,-%b1"       CR_TAB
+                          TINY_SBIW (%I1, %J1, 1)     CR_TAB
+                          "ld %A0,%b1"                CR_TAB
+                          "mov %B0,__tmp_reg__", op, plen, -8);
+   }
+  else
+    {
+      avr_asm_len (TINY_ADIW (%I1, %J1, %o1)   CR_TAB
+                          "ld %A0,%b1+"              CR_TAB
+                          "ld %B0,%b1+"              CR_TAB
+                          "ld %C0,%b1", op, plen, -5);
+
+      if (reg_dest != (reg_base - 2)
+          && !reg_unused_after (insn, XEXP (base, 0)))
+          avr_asm_len (TINY_SBIW (%I1, %J1, %o1+2), op, plen, 2);
+
+      return "";
+    }
+}
+
+static const char*
 avr_out_load_psi (rtx insn, rtx *op, int *plen)
 {
   rtx dest = op[0];
@@ -3825,6 +4423,9 @@ avr_out_load_psi (rtx insn, rtx *op, int *plen)
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_load_psi_reg_no_disp_tiny (insn, op, plen);
+
       if (reg_base == REG_X)        /* (R26) */
         {
           if (reg_dest == REG_X)
@@ -3867,6 +4468,9 @@ avr_out_load_psi (rtx insn, rtx *op, int *plen)
     {
       int disp = INTVAL (XEXP (base, 1));
 
+      if (AVR_TINY)
+        return avr_out_load_psi_reg_disp_tiny (insn, op, plen);
+
       if (disp > MAX_LD_OFFSET (GET_MODE (src)))
         {
           if (REGNO (XEXP (base, 0)) != REG_Y)
@@ -3935,14 +4539,94 @@ avr_out_load_psi (rtx insn, rtx *op, int *plen)
                         "ld %C0,%1", op, plen, -3);
 
   else if (CONSTANT_ADDRESS_P (base))
-    return avr_asm_len ("lds %A0,%m1" CR_TAB
-                        "lds %B0,%m1+1" CR_TAB
-                        "lds %C0,%m1+2", op, plen , -6);
+    {
+      int n_words = AVR_TINY ? 3 : 6;
+      return avr_asm_len ("lds %A0,%m1" CR_TAB
+                          "lds %B0,%m1+1" CR_TAB
+                          "lds %C0,%m1+2", op, plen , -n_words);
+    }
 
   fatal_insn ("unknown move insn:",insn);
   return "";
 }
 
+
+static const char*
+avr_out_store_psi_reg_no_disp_tiny (rtx insn, rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = true_regnum (base);
+  int reg_src = true_regnum (src);
+
+  if (reg_base == reg_src)
+    {
+      avr_asm_len ("st %0,%A1"              CR_TAB
+                   "mov __tmp_reg__,%B1"    CR_TAB
+                   TINY_ADIW (%E0, %F0, 1)  CR_TAB /* st X+, r27 is undefined */
+                   "st %0+,__tmp_reg__"     CR_TAB
+                   "st %0,%C1", op, plen, -6);
+
+    }
+  else if (reg_src == reg_base - 2)
+    {
+      avr_asm_len ("st %0,%A1"              CR_TAB
+                   "mov __tmp_reg__,%C1"    CR_TAB
+                   TINY_ADIW (%E0, %F0, 1)  CR_TAB
+                   "st %0+,%B1"             CR_TAB
+                   "st %0,__tmp_reg__", op, plen, 6);
+    }
+  else
+    {
+      avr_asm_len ("st %0+,%A1"  CR_TAB
+                   "st %0+,%B1" CR_TAB
+                   "st %0,%C1", op, plen, -3);
+    }
+
+  if (!reg_unused_after (insn, base))
+    avr_asm_len (TINY_SBIW (%E0, %F0, 2), op, plen, 2);
+
+  return "";
+}
+
+static const char*
+avr_out_store_psi_reg_disp_tiny (rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = REGNO (XEXP (base, 0));
+  int reg_src = true_regnum (src);
+
+  if (reg_src == reg_base)
+    {
+      return avr_asm_len ("mov __tmp_reg__,%A1"          CR_TAB
+                          "mov __zero_reg__,%B1"         CR_TAB
+                          TINY_ADIW (%I0, %J0, %o0)      CR_TAB
+                          "st %b0+,__tmp_reg__"          CR_TAB
+                          "st %b0+,__zero_reg__"         CR_TAB
+                          "st %b0,%C1"                   CR_TAB
+                          "clr __zero_reg__"             CR_TAB
+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -10);
+    }
+  else if (reg_src == reg_base - 2)
+    {
+      return avr_asm_len ("mov __tmp_reg__,%C1"          CR_TAB
+                          TINY_ADIW (%I0, %J0, %o0)      CR_TAB
+                          "st %b0+,%A1"                  CR_TAB
+                          "st %b0+,%B1"                  CR_TAB
+                          "st %b0,__tmp_reg__"           CR_TAB
+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -8);
+    }
+
+  return avr_asm_len (TINY_ADIW (%I0, %J0, %o0)      CR_TAB
+                          "st %b0+,%A1"                  CR_TAB
+                          "st %b0+,%B1"                  CR_TAB
+                          "st %b0,%C1"                   CR_TAB
+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -7);
+}
+
 /* Handle store of 24-bit type from register or zero to memory.  */
 
 static const char*
@@ -3954,12 +4638,18 @@ avr_out_store_psi (rtx insn, rtx *op, int *plen)
   int reg_base = true_regnum (base);
 
   if (CONSTANT_ADDRESS_P (base))
-    return avr_asm_len ("sts %m0,%A1"   CR_TAB
-                        "sts %m0+1,%B1" CR_TAB
-                        "sts %m0+2,%C1", op, plen, -6);
+    {
+      int n_words = AVR_TINY ? 3 : 6;
+      return avr_asm_len ("sts %m0,%A1"   CR_TAB
+                          "sts %m0+1,%B1" CR_TAB
+                          "sts %m0+2,%C1", op, plen, -n_words);
+    }
 
   if (reg_base > 0)                 /* (r) */
     {
+      if (AVR_TINY)
+        return avr_out_store_psi_reg_no_disp_tiny (insn, op, plen);
+
       if (reg_base == REG_X)        /* (R26) */
         {
           gcc_assert (!reg_overlap_mentioned_p (base, src));
@@ -3981,6 +4671,10 @@ avr_out_store_psi (rtx insn, rtx *op, int *plen)
   else if (GET_CODE (base) == PLUS) /* (R + i) */
     {
       int disp = INTVAL (XEXP (base, 1));
+
+      if (AVR_TINY)
+        return avr_out_store_psi_reg_disp_tiny (op, plen);
+
       reg_base = REGNO (XEXP (base, 0));
 
       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))
@@ -4097,6 +4791,30 @@ avr_out_movpsi (rtx insn, rtx *op, int *plen)
   return "";
 }
 
+static const char*
+avr_out_movqi_mr_r_reg_disp_tiny (rtx insn, rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx x = XEXP (dest, 0);
+
+  if (reg_overlap_mentioned_p (src, XEXP (x, 0)))
+    {
+      avr_asm_len ("mov __tmp_reg__,%1"      CR_TAB
+                   TINY_ADIW (%I0, %J0, %o0) CR_TAB
+                   "st %b0,__tmp_reg__", op, plen, -4);
+    }
+    else
+    {
+      avr_asm_len (TINY_ADIW (%I0, %J0, %o0) CR_TAB
+          "st %b0,%1" , op, plen, -3);
+    }
+
+  if (!reg_unused_after (insn, XEXP (x,0)))
+      avr_asm_len (TINY_SBIW (%I0, %J0, %o0), op, plen, 2);
+
+  return "";
+}
 
 static const char*
 out_movqi_mr_r (rtx insn, rtx op[], int *plen)
@@ -4107,9 +4825,10 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)
 
   if (CONSTANT_ADDRESS_P (x))
     {
+      int n_words = AVR_TINY ? 1 : 2;
       return optimize > 0 && io_address_operand (x, QImode)
         ? avr_asm_len ("out %i0,%1", op, plen, -1)
-        : avr_asm_len ("sts %m0,%1", op, plen, -2);
+        : avr_asm_len ("sts %m0,%1", op, plen, -n_words);
     }
   else if (GET_CODE (x) == PLUS
            && REG_P (XEXP (x, 0))
@@ -4119,6 +4838,9 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)
 
       int disp = INTVAL (XEXP (x, 1));
 
+      if (AVR_TINY)
+        return avr_out_movqi_mr_r_reg_disp_tiny (insn, op, plen);
+
       if (disp - GET_MODE_SIZE (GET_MODE (dest)) >= 63)
         {
           if (REGNO (XEXP (x, 0)) != REG_Y)
@@ -4179,12 +4901,15 @@ avr_out_movhi_mr_r_xmega (rtx insn, rtx op[], int *plen)
   int mem_volatile_p = MEM_VOLATILE_P (dest);
 
   if (CONSTANT_ADDRESS_P (base))
-    return optimize > 0 && io_address_operand (base, HImode)
-      ? avr_asm_len ("out %i0,%A1" CR_TAB
-                     "out %i0+1,%B1", op, plen, -2)
+    {
+      int n_words = AVR_TINY ? 2 : 4;
+      return optimize > 0 && io_address_operand (base, HImode)
+        ? avr_asm_len ("out %i0,%A1" CR_TAB
+                       "out %i0+1,%B1", op, plen, -2)
 
-      : avr_asm_len ("sts %m0,%A1" CR_TAB
-                     "sts %m0+1,%B1", op, plen, -4);
+        : avr_asm_len ("sts %m0,%A1" CR_TAB
+                       "sts %m0+1,%B1", op, plen, -n_words);
+    }
 
   if (reg_base > 0)
     {
@@ -4259,20 +4984,84 @@ avr_out_movhi_mr_r_xmega (rtx insn, rtx op[], int *plen)
                        "st X,%B1"    CR_TAB
                        "sbiw r26,1", op, plen, -4)
 
-        : avr_asm_len ("sbiw %r0,2"  CR_TAB
-                       "st %p0,%A1"  CR_TAB
-                       "std %p0+1,%B1", op, plen, -3);
-    }
-  else if (GET_CODE (base) == POST_INC) /* (R++) */
+        : avr_asm_len ("sbiw %r0,2"  CR_TAB
+                       "st %p0,%A1"  CR_TAB
+                       "std %p0+1,%B1", op, plen, -3);
+    }
+  else if (GET_CODE (base) == POST_INC) /* (R++) */
+    {
+      return avr_asm_len ("st %0,%A1"  CR_TAB
+                          "st %0,%B1", op, plen, -2);
+
+    }
+  fatal_insn ("unknown move insn:",insn);
+  return "";
+}
+
+static const char*
+avr_out_movhi_mr_r_reg_no_disp_tiny (rtx insn, rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = true_regnum (base);
+  int reg_src = true_regnum (src);
+  int mem_volatile_p = MEM_VOLATILE_P (dest);
+
+  if (reg_base == reg_src)
     {
-      return avr_asm_len ("st %0,%A1"  CR_TAB
-                          "st %0,%B1", op, plen, -2);
-
+      return !mem_volatile_p && reg_unused_after (insn, src)
+        ? avr_asm_len ("mov __tmp_reg__,%B1"   CR_TAB
+                       "st %0,%A1"             CR_TAB
+                       TINY_ADIW (%E0, %F0, 1) CR_TAB
+                       "st %0,__tmp_reg__", op, plen, -5)
+        : avr_asm_len ("mov __tmp_reg__,%B1"   CR_TAB
+                       TINY_ADIW (%E0, %F0, 1) CR_TAB
+                       "st %0,__tmp_reg__"      CR_TAB
+                       TINY_SBIW (%E0, %F0, 1) CR_TAB
+                       "st %0, %A1", op, plen, -7);
     }
-  fatal_insn ("unknown move insn:",insn);
-  return "";
+
+  return !mem_volatile_p && reg_unused_after (insn, base)
+      ? avr_asm_len ("st %0+,%A1" CR_TAB
+                     "st %0,%B1", op, plen, -2)
+      : avr_asm_len (TINY_ADIW (%E0, %F0, 1) CR_TAB
+                     "st %0,%B1"             CR_TAB
+                     "st -%0,%A1", op, plen, -4);
+}
+
+static const char*
+avr_out_movhi_mr_r_reg_disp_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = REGNO (XEXP (base, 0));
+  int reg_src = true_regnum (src);
+
+  return reg_src == reg_base
+        ? avr_asm_len ("mov __tmp_reg__,%A1"          CR_TAB
+                       "mov __zero_reg__,%B1"         CR_TAB
+                       TINY_ADIW (%I0, %J0, %o0+1)    CR_TAB
+                       "st %b0,__zero_reg__"          CR_TAB
+                       "st -%b0,__tmp_reg__"          CR_TAB
+                       "clr __zero_reg__"             CR_TAB
+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -9)
+
+        : avr_asm_len (TINY_ADIW (%I0, %J0, %o0+1) CR_TAB
+                       "st %b0,%B1"                CR_TAB
+                       "st -%b0,%A1"               CR_TAB
+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -6);
 }
 
+static const char*
+avr_out_movhi_mr_r_post_inc_tiny (rtx op[], int *plen)
+{
+  return avr_asm_len (TINY_ADIW (%I0, %J0, 1)  CR_TAB
+                      "st %p0,%B1"    CR_TAB
+                      "st -%p0,%A1"   CR_TAB
+                      TINY_ADIW (%I0, %J0, 2), op, plen, -6);
+}
 
 static const char*
 out_movhi_mr_r (rtx insn, rtx op[], int *plen)
@@ -4294,15 +5083,21 @@ out_movhi_mr_r (rtx insn, rtx op[], int *plen)
   mem_volatile_p = MEM_VOLATILE_P (dest);
 
   if (CONSTANT_ADDRESS_P (base))
-    return optimize > 0 && io_address_operand (base, HImode)
-      ? avr_asm_len ("out %i0+1,%B1" CR_TAB
-                     "out %i0,%A1", op, plen, -2)
+    {
+      int n_words = AVR_TINY ? 2 : 4;
+      return optimize > 0 && io_address_operand (base, HImode)
+        ? avr_asm_len ("out %i0+1,%B1" CR_TAB
+                       "out %i0,%A1", op, plen, -2)
 
-      : avr_asm_len ("sts %m0+1,%B1" CR_TAB
-                     "sts %m0,%A1", op, plen, -4);
+        : avr_asm_len ("sts %m0+1,%B1" CR_TAB
+                       "sts %m0,%A1", op, plen, -n_words);
+    }
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_movhi_mr_r_reg_no_disp_tiny (insn, op, plen);
+
       if (reg_base != REG_X)
         return avr_asm_len ("std %0+1,%B1" CR_TAB
                             "st %0,%A1", op, plen, -2);
@@ -4331,6 +5126,10 @@ out_movhi_mr_r (rtx insn, rtx op[], int *plen)
   else if (GET_CODE (base) == PLUS)
     {
       int disp = INTVAL (XEXP (base, 1));
+
+      if (AVR_TINY)
+        return avr_out_movhi_mr_r_reg_disp_tiny (op, plen);
+
       reg_base = REGNO (XEXP (base, 0));
       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))
         {
@@ -4380,6 +5179,9 @@ out_movhi_mr_r (rtx insn, rtx op[], int *plen)
         return avr_asm_len ("st %0,%A1"  CR_TAB
                             "st %0,%B1", op, plen, -2);
 
+      if (AVR_TINY)
+        return avr_out_movhi_mr_r_post_inc_tiny (op, plen);
+
       return REGNO (XEXP (base, 0)) == REG_X
         ? avr_asm_len ("adiw r26,1"  CR_TAB
                        "st X,%B1"    CR_TAB
@@ -4562,7 +5364,11 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)
               && (val8 == 0
                   || reg_unused_after (insn, xreg)))
             {
-              avr_asm_len ("sbiw %0,%1", xop, plen, 1);
+              if (AVR_TINY)
+                avr_asm_len (TINY_SBIW (%A0, %B0, %1), xop, plen, 2);
+              else
+                avr_asm_len ("sbiw %0,%1", xop, plen, 1);
+
               i++;
               continue;
             }
@@ -4572,7 +5378,9 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)
               && compare_eq_p (insn)
               && reg_unused_after (insn, xreg))
             {
-              return avr_asm_len ("adiw %0,%n1", xop, plen, 1);
+              return AVR_TINY
+                  ? avr_asm_len (TINY_ADIW (%A0, %B0, %n1), xop, plen, 2)
+                  : avr_asm_len ("adiw %0,%n1", xop, plen, 1);
             }
         }
 
@@ -6633,7 +7441,8 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,
       else
         {
           if (MINUS == code && !test_hard_reg_class (LD_REGS, op[0]))
-            avr_asm_len ("sec" CR_TAB "sbc %0,%0", op, plen, 2);
+            avr_asm_len ("sec" CR_TAB
+                         "sbc %0,%0", op, plen, 2);
           else
             avr_asm_len (PLUS == code ? "sbc %0,%0" : "ldi %0,0xff",
                          op, plen, 1);
@@ -6993,6 +7802,56 @@ avr_out_bitop (rtx insn, rtx *xop, int *plen)
 }
 
 
+/* Output sign extension from XOP[1] to XOP[0] and return "".
+   If PLEN == NULL, print assembler instructions to perform the operation;
+   otherwise, set *PLEN to the length of the instruction sequence (in words)
+   as printed with PLEN == NULL.  */
+
+const char*
+avr_out_sign_extend (rtx insn, rtx *xop, int *plen)
+{
+  // Size in bytes of source resp. destination operand.
+  unsigned n_src = GET_MODE_SIZE (GET_MODE (xop[1]));
+  unsigned n_dest = GET_MODE_SIZE (GET_MODE (xop[0]));
+  rtx r_msb = all_regs_rtx[REGNO (xop[1]) + n_src - 1];
+
+  if (plen)
+    *plen = 0;
+
+  // Copy destination to source
+
+  if (REGNO (xop[0]) != REGNO (xop[1]))
+    {
+      gcc_assert (n_src <= 2);
+
+      if (n_src == 2)
+        avr_asm_len (AVR_HAVE_MOVW
+                     ? "movw %0,%1"
+                     : "mov %B0,%B1", xop, plen, 1);
+      if (n_src == 1 || !AVR_HAVE_MOVW)
+        avr_asm_len ("mov %A0,%A1", xop, plen, 1);
+    }
+
+  // Set Carry to the sign bit MSB.7...
+
+  if (REGNO (xop[0]) == REGNO (xop[1])
+      || !reg_unused_after (insn, r_msb))
+    {
+      avr_asm_len ("mov __tmp_reg__,%0", &r_msb, plen, 1);
+      r_msb = tmp_reg_rtx;
+    }
+  
+  avr_asm_len ("lsl %0", &r_msb, plen, 1);
+                   
+  // ...and propagate it to all the new sign bits
+
+  for (unsigned n = n_src; n < n_dest; n++)
+    avr_asm_len ("sbc %0,%0", &all_regs_rtx[REGNO (xop[0]) + n], plen, 1);
+
+  return "";
+}
+
+
 /* PLEN == NULL: Output code to add CONST_INT OP[0] to SP.
    PLEN != NULL: Set *PLEN to the length of that sequence.
    Return "".  */
@@ -7137,16 +7996,16 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
     gcc_unreachable();
 
   /* If we need to round the fraction part, we might need to save/round it
-     before clobbering any of it in Step 1.  Also, we might to want to do
+     before clobbering any of it in Step 1.  Also, we might want to do
      the rounding now to make use of LD_REGS.  */
   if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
       && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))
       && !TARGET_FRACT_CONV_TRUNC)
     {
       bool overlap
-	= (src.regno <=
-	   (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)
-	   && dest.regno - offset -1 >= dest.regno);
+        = (src.regno <=
+           (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)
+           && dest.regno - offset -1 >= dest.regno);
       unsigned s0 = dest.regno - offset -1;
       bool use_src = true;
       unsigned sn;
@@ -7154,92 +8013,103 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
       bool have_carry = false;
 
       if (src.ibyte > dest.ibyte)
-	copied_msb -= src.ibyte - dest.ibyte;
+        copied_msb -= src.ibyte - dest.ibyte;
 
       for (sn = s0; sn <= copied_msb; sn++)
-	if (!IN_RANGE (sn, dest.regno, dest.regno_msb)
-	    && !reg_unused_after (insn, all_regs_rtx[sn]))
-	  use_src = false;
+        if (!IN_RANGE (sn, dest.regno, dest.regno_msb)
+            && !reg_unused_after (insn, all_regs_rtx[sn]))
+          use_src = false;
       if (use_src && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0))
-	{
-	  avr_asm_len ("tst %0" CR_TAB "brpl 0f",
-		       &all_regs_rtx[src.regno_msb], plen, 2);
-	  sn = src.regno;
-	  if (sn < s0)
-	    {
-	      if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))
-		avr_asm_len ("cpi %0,1", &all_regs_rtx[sn], plen, 1);
-	      else
-		avr_asm_len ("sec" CR_TAB "cpc %0,__zero_reg__",
-			     &all_regs_rtx[sn], plen, 2);
-	      have_carry = true;
-	    }
-	  while (++sn < s0)
-	    avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
-	  avr_asm_len (have_carry ? "sbci %0,128" : "subi %0,129",
-		       &all_regs_rtx[s0], plen, 1);
-	  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
-	    avr_asm_len ("sbci %0,255", &all_regs_rtx[sn], plen, 1);
-	  avr_asm_len ("\n0:", NULL, plen, 0);
-	  frac_rounded = true;
-	}
+        {
+          avr_asm_len ("tst %0" CR_TAB "brpl 0f",
+                       &all_regs_rtx[src.regno_msb], plen, 2);
+          sn = src.regno;
+          if (sn < s0)
+            {
+              if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))
+                avr_asm_len ("cpi %0,1", &all_regs_rtx[sn], plen, 1);
+              else
+                avr_asm_len ("sec" CR_TAB
+                             "cpc %0,__zero_reg__",
+                             &all_regs_rtx[sn], plen, 2);
+              have_carry = true;
+            }
+          while (++sn < s0)
+            avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+
+          avr_asm_len (have_carry ? "sbci %0,128" : "subi %0,129",
+                       &all_regs_rtx[s0], plen, 1);
+          for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
+            avr_asm_len ("sbci %0,255", &all_regs_rtx[sn], plen, 1);
+          avr_asm_len ("\n0:", NULL, plen, 0);
+          frac_rounded = true;
+        }
       else if (use_src && overlap)
-	{
-	  avr_asm_len ("clr __tmp_reg__" CR_TAB
-		       "sbrc %1,0" CR_TAB "dec __tmp_reg__", xop, plen, 1);
-	  sn = src.regno;
-	  if (sn < s0)
-	    {
-	      avr_asm_len ("add %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
-	      have_carry = true;
-	    }
-	  while (++sn < s0)
-	    avr_asm_len ("adc %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
-	  if (have_carry)
-	    avr_asm_len ("clt" CR_TAB "bld __tmp_reg__,7" CR_TAB
-			 "adc %0,__tmp_reg__",
-			 &all_regs_rtx[s0], plen, 1);
-	  else
-	    avr_asm_len ("lsr __tmp_reg" CR_TAB "add %0,__tmp_reg__",
-			 &all_regs_rtx[s0], plen, 2);
-	  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
-	    avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
-	  frac_rounded = true;
-	}
+        {
+          avr_asm_len ("clr __tmp_reg__" CR_TAB
+                       "sbrc %1,0"       CR_TAB
+                       "dec __tmp_reg__", xop, plen, 1);
+          sn = src.regno;
+          if (sn < s0)
+            {
+              avr_asm_len ("add %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
+              have_carry = true;
+            }
+
+          while (++sn < s0)
+            avr_asm_len ("adc %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
+
+          if (have_carry)
+            avr_asm_len ("clt"                CR_TAB
+                         "bld __tmp_reg__,7"  CR_TAB
+                         "adc %0,__tmp_reg__",
+                         &all_regs_rtx[s0], plen, 1);
+          else
+            avr_asm_len ("lsr __tmp_reg" CR_TAB
+                         "add %0,__tmp_reg__",
+                         &all_regs_rtx[s0], plen, 2);
+          for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
+            avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+          frac_rounded = true;
+        }
       else if (overlap)
-	{
-	  bool use_src
-	    = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)
-	       && (IN_RANGE (s0, dest.regno, dest.regno_msb)
-		   || reg_unused_after (insn, all_regs_rtx[s0])));
-	  xop[2] = all_regs_rtx[s0];
-	  unsigned sn = src.regno;
-	  if (!use_src || sn == s0)
-	    avr_asm_len ("mov __tmp_reg__,%2", xop, plen, 1);
-	  /* We need to consider to-be-discarded bits
-	     if the value is negative.  */
-	  if (sn < s0)
-	    {
-	      avr_asm_len ("tst %0" CR_TAB "brpl 0f",
-			   &all_regs_rtx[src.regno_msb], plen, 2);
-	      /* Test to-be-discarded bytes for any nozero bits.
-		 ??? Could use OR or SBIW to test two registers at once.  */
-	      if (sn < s0)
-		avr_asm_len ("cp %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
-	      while (++sn < s0)
-		avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
-	      /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */
-	      if (use_src)
-		avr_asm_len ("breq 0f" CR_TAB
-			     "ori %2,1" "\n0:\t" "mov __tmp_reg__,%2",
-			     xop, plen, 3);
-	      else
-		avr_asm_len ("breq 0f" CR_TAB
-			     "set" CR_TAB "bld __tmp_reg__,0\n0:",
-			     xop, plen, 3);
-	    }
-	  lsb_in_tmp_reg = true;
-	}
+        {
+          bool use_src
+            = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)
+               && (IN_RANGE (s0, dest.regno, dest.regno_msb)
+                   || reg_unused_after (insn, all_regs_rtx[s0])));
+          xop[2] = all_regs_rtx[s0];
+          unsigned sn = src.regno;
+          if (!use_src || sn == s0)
+            avr_asm_len ("mov __tmp_reg__,%2", xop, plen, 1);
+          /* We need to consider to-be-discarded bits
+             if the value is negative.  */
+          if (sn < s0)
+            {
+              avr_asm_len ("tst %0" CR_TAB
+                           "brpl 0f",
+                           &all_regs_rtx[src.regno_msb], plen, 2);
+              /* Test to-be-discarded bytes for any nozero bits.
+                 ??? Could use OR or SBIW to test two registers at once.  */
+              if (sn < s0)
+                avr_asm_len ("cp %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+
+              while (++sn < s0)
+                avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+              /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */
+              if (use_src)
+                avr_asm_len ("breq 0f" CR_TAB
+                             "ori %2,1"
+                             "\n0:\t" "mov __tmp_reg__,%2",
+                             xop, plen, 3);
+              else
+                avr_asm_len ("breq 0f" CR_TAB
+                             "set"     CR_TAB
+                             "bld __tmp_reg__,0\n0:",
+                             xop, plen, 3);
+            }
+          lsb_in_tmp_reg = true;
+        }
     }
 
   /* Step 1:  Clear bytes at the low end and copy payload bits from source
@@ -7313,7 +8183,7 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
             {
               /* We are going to override the sign bit.  If we sign-extend,
                  store the sign in the Carry flag.  This is not needed if
-                 the destination will be ASHIFT is the remainder because
+                 the destination will be ASHIFT in the remainder because
                  the ASHIFT will set Carry without extra instruction.  */
 
               avr_asm_len ("lsl %0", &all_regs_rtx[src.regno_msb], plen, 1);
@@ -7377,7 +8247,8 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
 	    avr_asm_len ("cpc __zero_reg__,%0", &all_regs_rtx[sn++], plen, 1);
 
 	  /* Overflow goes with set carry.  Clear carry otherwise.  */
-	  avr_asm_len ("brvs 0f" CR_TAB "clc\n0:", NULL, plen, 2);
+	  avr_asm_len ("brvs 0f" CR_TAB
+                       "clc\n0:", NULL, plen, 2);
 	}
       /* Likewise, when converting from accumulator types to integer, we
 	 need to round up negative values.  */
@@ -7426,22 +8297,26 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
 	      /* Fall back to use __zero_reg__ as a temporary.  */
 	      avr_asm_len ("dec __zero_reg__", NULL, plen, 1);
 	      if (have_carry)
-		avr_asm_len ("clt" CR_TAB "bld __zero_reg__,7", NULL, plen, 2);
+		avr_asm_len ("clt" CR_TAB
+                             "bld __zero_reg__,7", NULL, plen, 2);
 	      else
 		avr_asm_len ("lsr __zero_reg__", NULL, plen, 1);
-	      avr_asm_len ((have_carry && lsb_in_tmp_reg
-			   ? "adc __tmp_reg__,__zero_reg__"
-			   : have_carry ? "adc %2,__zero_reg__"
-			   : lsb_in_tmp_reg ? "add __tmp_reg__,__zero_reg__"
-			   : "add %2,__zero_reg__"),
+	      avr_asm_len (have_carry && lsb_in_tmp_reg
+                           ? "adc __tmp_reg__,__zero_reg__"
+                           : have_carry ? "adc %2,__zero_reg__"
+                           : lsb_in_tmp_reg ? "add __tmp_reg__,__zero_reg__"
+                           : "add %2,__zero_reg__",
 			   xop, plen, 1);
 	      avr_asm_len ("eor __zero_reg__,__zero_reg__", NULL, plen, 1);
 	    }
-	  for (d0 = dest.regno + zero_bytes;
+
+          for (d0 = dest.regno + zero_bytes;
 	       d0 <= dest.regno_msb - sign_bytes; d0++)
 	    avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[d0], plen, 1);
-	  avr_asm_len (lsb_in_tmp_reg
-		       ? "\n0:\t" "lsl __tmp_reg__" : "\n0:\t" "lsl %2",
+
+          avr_asm_len (lsb_in_tmp_reg
+		       ? "\n0:\t" "lsl __tmp_reg__"
+                       : "\n0:\t" "lsl %2",
 		       xop, plen, 1);
 	}
       else if (MAY_CLOBBER (s0))
@@ -7681,15 +8556,15 @@ avr_rotate_bytes (rtx operands[])
 	gcc_assert (size <= MAX_SIZE);
 	/* Generate list of subreg moves.  */
 	for (i = 0; i < size; i++)
-	  {
+          {
 	    int from = i;
 	    int to = (from + offset) % size;
 	    move[i].src = simplify_gen_subreg (move_mode, operands[1],
-						mode, from * move_size);
+                                               mode, from * move_size);
 	    move[i].dst = simplify_gen_subreg (move_mode, operands[0],
-						mode, to   * move_size);
-	    move[i].links = -1;
-	   }
+                                               mode, to * move_size);
+            move[i].links = -1;
+          }
 	/* Mark dependence where a dst of one move is the src of another move.
 	   The first move is a conflict as it must wait until second is
 	   performed.  We ignore moves to self - we catch this later.  */
@@ -7778,7 +8653,8 @@ avr_adjust_insn_length (rtx insn, int len)
      It is easier to state this in an insn attribute "adjust_len" than
      to clutter up code here...  */
 
-  if (-1 == recog_memoized (insn))
+  if (!NONDEBUG_INSN_P (insn)
+      || -1 == recog_memoized (insn))
     {
       return len;
     }
@@ -7819,6 +8695,7 @@ avr_adjust_insn_length (rtx insn, int len)
     case ADJUST_LEN_MOVMEM: avr_out_movmem (insn, op, &len); break;
     case ADJUST_LEN_XLOAD: avr_out_xload (insn, op, &len); break;
     case ADJUST_LEN_LPM: avr_out_lpm (insn, op, &len); break;
+    case ADJUST_LEN_SEXT: avr_out_sign_extend (insn, op, &len); break;
 
     case ADJUST_LEN_SFRACT: avr_out_fract (insn, op, true, &len); break;
     case ADJUST_LEN_UFRACT: avr_out_fract (insn, op, false, &len); break;
@@ -8033,7 +8910,8 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)
 static bool
 avr_class_likely_spilled_p (reg_class_t c)
 {
-  return (c != ALL_REGS && c != ADDW_REGS);
+  return (c != ALL_REGS &&
+           (AVR_TINY ? 1 : c != ADDW_REGS));
 }
 
 
@@ -8120,6 +8998,88 @@ avr_handle_fntype_attribute (tree *node, tree name,
   return NULL_TREE;
 }
 
+static tree
+avr_handle_addr_attribute (tree *node, tree name, tree args,
+			   int flags ATTRIBUTE_UNUSED, bool *no_add)
+{
+  bool io_p = (strncmp (IDENTIFIER_POINTER (name), "io", 2) == 0);
+  location_t loc = DECL_SOURCE_LOCATION (*node);
+
+  if (TREE_CODE (*node) != VAR_DECL)
+    {
+      warning_at (loc, 0, "%qE attribute only applies to variables", name);
+      *no_add = true;
+    }
+
+  if (args != NULL_TREE)
+    {
+      if (TREE_CODE (TREE_VALUE (args)) == NON_LVALUE_EXPR)
+	TREE_VALUE (args) = TREE_OPERAND (TREE_VALUE (args), 0);
+      tree arg = TREE_VALUE (args);
+      if (TREE_CODE (arg) != INTEGER_CST)
+	{
+	  warning (0, "%qE attribute allows only an integer constant argument",
+		   name);
+	  *no_add = true;
+	}
+      else if (io_p
+	       && (!tree_fits_shwi_p (arg)
+		   || !(strcmp (IDENTIFIER_POINTER (name), "io_low") == 0
+			? low_io_address_operand : io_address_operand)
+			 (GEN_INT (TREE_INT_CST_LOW (arg)), QImode)))
+	{
+	  warning_at (loc, 0, "%qE attribute address out of range", name);
+	  *no_add = true;
+	}
+      else
+	{
+	  tree attribs = DECL_ATTRIBUTES (*node);
+	  const char *names[] = { "io", "io_low", "address", NULL } ;
+	  for (const char **p = names; *p; p++)
+	    {
+	      tree other = lookup_attribute (*p, attribs);
+	      if (other && TREE_VALUE (other))
+		{
+		  warning_at (loc, 0,
+			      "both %s and %qE attribute provide address",
+			      *p, name);
+		  *no_add = true;
+		  break;
+		}
+	    }
+	}
+    }
+
+  if (*no_add == false && io_p && !TREE_THIS_VOLATILE (*node))
+    warning_at (loc, 0, "%qE attribute on non-volatile variable", name);
+
+  return NULL_TREE;
+}
+
+rtx
+avr_eval_addr_attrib (rtx x)
+{
+  if (GET_CODE (x) == SYMBOL_REF
+      && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_ADDRESS))
+    {
+      tree decl = SYMBOL_REF_DECL (x);
+      tree attr = NULL_TREE;
+
+      if (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_IO)
+	{
+	  attr = lookup_attribute ("io", DECL_ATTRIBUTES (decl));
+         if (!attr || !TREE_VALUE (attr))
+           attr = lookup_attribute ("io_low", DECL_ATTRIBUTES (decl));
+	  gcc_assert (attr);
+	}
+      if (!attr || !TREE_VALUE (attr))
+	attr = lookup_attribute ("address", DECL_ATTRIBUTES (decl));
+      gcc_assert (attr && TREE_VALUE (attr) && TREE_VALUE (TREE_VALUE (attr)));
+      return GEN_INT (TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr))));
+    }
+  return x;
+}
+
 
 /* AVR attributes.  */
 static const struct attribute_spec
@@ -8133,12 +9093,20 @@ avr_attribute_table[] =
     false },
   { "interrupt", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,
     false },
+  { "nmi",       0, 0, true,  false, false,  avr_handle_fndecl_attribute,
+    false },
   { "naked",     0, 0, false, true,  true,   avr_handle_fntype_attribute,
     false },
   { "OS_task",   0, 0, false, true,  true,   avr_handle_fntype_attribute,
     false },
   { "OS_main",   0, 0, false, true,  true,   avr_handle_fntype_attribute,
     false },
+  { "io",        0, 1, false, false, false,  avr_handle_addr_attribute,
+    false },
+  { "io_low",    0, 1, false, false, false,  avr_handle_addr_attribute,
+    false },
+  { "address",   1, 1, false, false, false,  avr_handle_addr_attribute,
+    false },
   { NULL,        0, 0, false, false, false, NULL, false }
 };
 
@@ -8220,7 +9188,9 @@ avr_nonconst_pointer_addrspace (tree typ)
 
       if (!ADDR_SPACE_GENERIC_P (as)
           && (!TYPE_READONLY (target)
-              || avr_addrspace[as].segment >= avr_current_device->n_flash))
+              || avr_addrspace[as].segment >= avr_n_flash
+              /* Also refuse __memx address space if we can't support it.  */
+              || (!AVR_HAVE_LPM && avr_addrspace[as].pointer_size > 2)))
         {
           return as;
         }
@@ -8284,15 +9254,14 @@ avr_pgm_check_var_decl (tree node)
 
   if (reason)
     {
-      if (avr_addrspace[as].segment >= avr_current_device->n_flash)
+      if (avr_addrspace[as].segment >= avr_n_flash)
         {
           if (TYPE_P (node))
-            error ("%qT uses address space %qs beyond flash of %qs",
-                   node, avr_addrspace[as].name, avr_current_device->name);
+            error ("%qT uses address space %qs beyond flash of %d KiB",
+                   node, avr_addrspace[as].name, avr_n_flash);
           else
-            error ("%s %q+D uses address space %qs beyond flash of %qs",
-                   reason, node, avr_addrspace[as].name,
-                   avr_current_device->name);
+            error ("%s %q+D uses address space %qs beyond flash of %d KiB",
+                   reason, node, avr_addrspace[as].name, avr_n_flash);
         }
       else
         {
@@ -8336,12 +9305,17 @@ avr_insert_attributes (tree node, tree *attributes)
 
       as = TYPE_ADDR_SPACE (TREE_TYPE (node));
 
-      if (avr_addrspace[as].segment >= avr_current_device->n_flash)
+      if (avr_addrspace[as].segment >= avr_n_flash)
         {
-          error ("variable %q+D located in address space %qs"
-                 " beyond flash of %qs",
-                 node, avr_addrspace[as].name, avr_current_device->name);
+          error ("variable %q+D located in address space %qs beyond flash "
+                 "of %d KiB", node, avr_addrspace[as].name, avr_n_flash);
         }
+      else if (!AVR_HAVE_LPM && avr_addrspace[as].pointer_size > 2)
+        {
+          error ("variable %q+D located in address space %qs"
+                 " which is not supported for architecture %qs",
+                 node, avr_addrspace[as].name, avr_arch->name);
+	}
 
       if (!TYPE_READONLY (node0)
           && !TREE_READONLY (node))
@@ -8367,11 +9341,37 @@ avr_insert_attributes (tree node, tree *attributes)
 
 void
 avr_asm_output_aligned_decl_common (FILE * stream,
-                                    const_tree decl ATTRIBUTE_UNUSED,
+                                    tree decl,
                                     const char *name,
                                     unsigned HOST_WIDE_INT size,
                                     unsigned int align, bool local_p)
 {
+  rtx mem = decl == NULL_TREE ? NULL_RTX : DECL_RTL (decl);
+  rtx symbol;
+
+  if (mem != NULL_RTX && MEM_P (mem)
+      && GET_CODE ((symbol = XEXP (mem, 0))) == SYMBOL_REF
+      && (SYMBOL_REF_FLAGS (symbol) & (SYMBOL_FLAG_IO | SYMBOL_FLAG_ADDRESS)))
+    {
+
+      if (!local_p)
+	{
+	  fprintf (stream, "\t.globl\t");
+	  assemble_name (stream, name);
+	  fprintf (stream, "\n");
+	}
+      if (SYMBOL_REF_FLAGS (symbol) & SYMBOL_FLAG_ADDRESS)
+	{
+	  assemble_name (stream, name);
+	  fprintf (stream, " = %ld\n",
+		   (long) INTVAL (avr_eval_addr_attrib (symbol)));
+	}
+      else if (local_p)
+	error_at (DECL_SOURCE_LOCATION (decl),
+		  "static IO declaration for %q+D needs an address", decl);
+      return;
+    }
+
   /* __gnu_lto_v1 etc. are just markers for the linker injected by toplev.c.
      There is no need to trigger __do_clear_bss code for them.  */
 
@@ -8384,6 +9384,29 @@ avr_asm_output_aligned_decl_common (FILE * stream,
     ASM_OUTPUT_ALIGNED_COMMON (stream, name, size, align);
 }
 
+void
+avr_asm_asm_output_aligned_bss (FILE *file, tree decl, const char *name,
+				unsigned HOST_WIDE_INT size, int align,
+				void (*default_func)
+				  (FILE *, tree, const char *,
+				   unsigned HOST_WIDE_INT, int))
+{
+  rtx mem = decl == NULL_TREE ? NULL_RTX : DECL_RTL (decl);
+  rtx symbol;
+
+  if (mem != NULL_RTX && MEM_P (mem)
+      && GET_CODE ((symbol = XEXP (mem, 0))) == SYMBOL_REF
+      && (SYMBOL_REF_FLAGS (symbol) & (SYMBOL_FLAG_IO | SYMBOL_FLAG_ADDRESS)))
+    {
+      if (!(SYMBOL_REF_FLAGS (symbol) & SYMBOL_FLAG_ADDRESS))
+	error_at (DECL_SOURCE_LOCATION (decl),
+		  "IO definition for %q+D needs an address", decl);
+      avr_asm_output_aligned_decl_common (file, decl, name, size, align, false);
+    }
+  else
+    default_func (file, decl, name, size, align);
+}
+
 
 /* Unnamed section callback for data_section
    to track need of __do_copy_data.  */
@@ -8615,17 +9638,45 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)
    {
       rtx sym = XEXP (rtl, 0);
       tree type = TREE_TYPE (decl);
+      tree attr = DECL_ATTRIBUTES (decl);
       if (type == error_mark_node)
 	return;
+
       addr_space_t as = TYPE_ADDR_SPACE (type);
 
       /* PSTR strings are in generic space but located in flash:
          patch address space.  */
 
-      if (-1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))
+      if (-1 == avr_progmem_p (decl, attr))
         as = ADDR_SPACE_FLASH;
 
       AVR_SYMBOL_SET_ADDR_SPACE (sym, as);
+
+      tree io_low_attr = lookup_attribute ("io_low", attr);
+      tree io_attr = lookup_attribute ("io", attr);
+      tree addr_attr;
+      if (io_low_attr
+	  && TREE_VALUE (io_low_attr) && TREE_VALUE (TREE_VALUE (io_low_attr)))
+	addr_attr = io_attr;
+      else if (io_attr
+	       && TREE_VALUE (io_attr) && TREE_VALUE (TREE_VALUE (io_attr)))
+	addr_attr = io_attr;
+      else
+	addr_attr = lookup_attribute ("address", attr);
+      if (io_low_attr
+	  || (io_attr && addr_attr
+              && low_io_address_operand
+                  (GEN_INT (TREE_INT_CST_LOW
+                            (TREE_VALUE (TREE_VALUE (addr_attr)))), QImode)))
+	SYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_IO_LOW;
+      if (io_attr || io_low_attr)
+	SYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_IO;
+      /* If we have an (io) address attribute specification, but the variable
+	 is external, treat the address as only a tentative definition
+	 to be used to determine if an io port is in the lower range, but
+	 don't use the exact value for constant propagation.  */
+      if (addr_attr && !DECL_EXTERNAL (decl))
+	SYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_ADDRESS;
     }
 }
 
@@ -8681,10 +9732,10 @@ avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)
 static void
 avr_file_start (void)
 {
-  int sfr_offset = avr_current_arch->sfr_offset;
+  int sfr_offset = avr_arch->sfr_offset;
 
-  if (avr_current_arch->asm_only)
-    error ("MCU %qs supported for assembler only", avr_current_device->name);
+  if (avr_arch->asm_only)
+    error ("architecture %qs supported for assembler only", avr_mmcu);
 
   default_file_start ();
 
@@ -8703,10 +9754,10 @@ avr_file_start (void)
     fprintf (asm_out_file, "__RAMPX__ = 0x%02x\n", avr_addr.rampx - sfr_offset);
   if (AVR_HAVE_RAMPD)
     fprintf (asm_out_file, "__RAMPD__ = 0x%02x\n", avr_addr.rampd - sfr_offset);
-  if (AVR_XMEGA)
+  if (AVR_XMEGA || AVR_TINY)
     fprintf (asm_out_file, "__CCP__ = 0x%02x\n", avr_addr.ccp - sfr_offset);
-  fprintf (asm_out_file, "__tmp_reg__ = %d\n", TMP_REGNO);
-  fprintf (asm_out_file, "__zero_reg__ = %d\n", ZERO_REGNO);
+  fprintf (asm_out_file, "__tmp_reg__ = %d\n", AVR_TMP_REGNO);
+  fprintf (asm_out_file, "__zero_reg__ = %d\n", AVR_ZERO_REGNO);
 }
 
 
@@ -8753,6 +9804,18 @@ avr_adjust_reg_alloc_order (void)
       0, 1,
       32, 33, 34, 35
   };
+  static const int tiny_order_0[] = {
+    20, 21,
+    22, 23,
+    24, 25,
+    30, 31,
+    26, 27,
+    28, 29,
+    19, 18,
+    16, 17,
+    32, 33, 34, 35,
+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+  };
   static const int order_1[] =
     {
       18, 19, 20, 21, 22, 23, 24, 25,
@@ -8762,6 +9825,17 @@ avr_adjust_reg_alloc_order (void)
       0, 1,
       32, 33, 34, 35
   };
+  static const int tiny_order_1[] = {
+    22, 23,
+    24, 25,
+    30, 31,
+    26, 27,
+    28, 29,
+    21, 20, 19, 18,
+    16, 17,
+    32, 33, 34, 35,
+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+  };
   static const int order_2[] =
     {
       25, 24, 23, 22, 21, 20, 19, 18,
@@ -8772,9 +9846,14 @@ avr_adjust_reg_alloc_order (void)
       32, 33, 34, 35
   };
 
-  const int *order = (TARGET_ORDER_1 ? order_1 :
-		      TARGET_ORDER_2 ? order_2 :
-		      order_0);
+  /* Select specific register allocation order.
+     Tiny Core (ATtiny4/5/9/10/20/40) devices have only 16 registers,
+     so different allocation order should be used.  */
+
+  const int *order = (TARGET_ORDER_1 ? (AVR_TINY ? tiny_order_1 : order_1)
+                      : TARGET_ORDER_2 ? (AVR_TINY ? tiny_order_0 : order_2)
+                      : (AVR_TINY ? tiny_order_0 : order_0));
+
   for (i = 0; i < ARRAY_SIZE (order_0); ++i)
       reg_alloc_order[i] = order[i];
 }
@@ -8866,7 +9945,11 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,
       return true;
 
     case MEM:
-      *total = COSTS_N_INSNS (GET_MODE_SIZE (mode));
+      /* MEM rtx with non-default address space is more
+         expensive. Not expressing that results in reg
+         clobber during expand (PR 65657). */
+      *total = COSTS_N_INSNS (GET_MODE_SIZE (mode)
+                  + (MEM_ADDR_SPACE(x) == ADDR_SPACE_RAM ? 0 : 5));
       return true;
 
     case NEG:
@@ -10127,7 +11210,7 @@ test_hard_reg_class (enum reg_class rclass, rtx x)
 static bool
 avr_2word_insn_p (rtx insn)
 {
-  if ((avr_current_device->dev_attribute & AVR_ERRATA_SKIP)
+  if (TARGET_SKIP_BUG
       || !insn
       || 2 != get_attr_length (insn))
     {
@@ -10237,9 +11320,10 @@ avr_hard_regno_call_part_clobbered (unsigned regno, enum machine_mode mode)
     return 0;
 
   /* Return true if any of the following boundaries is crossed:
-     17/18, 27/28 and 29/30.  */
+     17/18 or 19/20 (if AVR_TINY), 27/28 and 29/30.  */
 
-  return ((regno < 18 && regno + GET_MODE_SIZE (mode) > 18)
+  return ((regno <= LAST_CALLEE_SAVED_REG &&
+          regno + GET_MODE_SIZE (mode) > (LAST_CALLEE_SAVED_REG + 1))
           || (regno < REG_Y && regno + GET_MODE_SIZE (mode) > REG_Y)
           || (regno < REG_Z && regno + GET_MODE_SIZE (mode) > REG_Z));
 }
@@ -10456,7 +11540,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)
         {
           if (!clear_p)
             avr_asm_len (ldreg_p ? "ldi %0,0"
-                         : ZERO_REGNO == REGNO (xdest[n]) ? "clr %0"
+                         : AVR_ZERO_REGNO == REGNO (xdest[n]) ? "clr %0"
                          : "mov %0,__zero_reg__",
                          &xdest[n], len, 1);
           continue;
@@ -10658,6 +11742,55 @@ avr_output_addr_vec_elt (FILE *stream, int value)
     fprintf (stream, "\trjmp .L%d\n", value);
 }
 
+static void
+avr_conditional_register_usage(void)
+{
+  if (AVR_TINY)
+    {
+      unsigned int i;
+
+      const int tiny_reg_alloc_order[] = {
+        24, 25,
+        22, 23,
+        30, 31,
+        26, 27,
+        28, 29,
+        21, 20, 19, 18,
+        16, 17,
+        32, 33, 34, 35,
+        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+      };
+
+      /* Set R0-R17 as fixed registers. Reset R0-R17 in call used register list
+         - R0-R15 are not available in Tiny Core devices
+         - R16 and R17 are fixed registers.  */
+
+      for (i = 0;  i <= 17;  i++)
+        {
+          fixed_regs[i] = 1;
+          call_used_regs[i] = 1;
+        }
+
+      /* Set R18 to R21 as callee saved registers
+         - R18, R19, R20 and R21 are the callee saved registers in
+           Tiny Core devices  */
+
+      for (i = 18; i <= LAST_CALLEE_SAVED_REG; i++)
+        {
+          call_used_regs[i] = 0;
+        }
+
+      /* Update register allocation order for Tiny Core devices */
+
+      for (i = 0; i < ARRAY_SIZE (tiny_reg_alloc_order); i++)
+        {
+          reg_alloc_order[i] = tiny_reg_alloc_order[i];
+        }
+
+      CLEAR_HARD_REG_SET (reg_class_contents[(int) ADDW_REGS]);
+      CLEAR_HARD_REG_SET (reg_class_contents[(int) NO_LD_REGS]);
+    }
+}
 
 /* Implement `TARGET_HARD_REGNO_SCRATCH_OK'.  */
 /* Returns true if SCRATCH are safe to be allocated as a scratch
@@ -10745,6 +11878,8 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])
       gcc_unreachable();
 
     case CONST_INT:
+    case CONST:
+    case SYMBOL_REF:
 
       if (low_io_address_operand (operands[1], QImode))
         {
@@ -10755,6 +11890,7 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])
         }
       else
         {
+	  gcc_assert (io_address_operand (operands[1], QImode));
           output_asm_insn ("in __tmp_reg__,%i1", operands);
           if (comp == EQ)
             output_asm_insn ("sbrs __tmp_reg__,%2", operands);
@@ -10809,13 +11945,21 @@ avr_asm_out_dtor (rtx symbol, int priority)
 static bool
 avr_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
-  if (TYPE_MODE (type) == BLKmode)
+  HOST_WIDE_INT size = int_size_in_bytes (type);
+  HOST_WIDE_INT ret_size_limit = AVR_TINY ? 4 : 8;
+
+  /* In avr, there are 8 return registers. But, for Tiny Core
+     (ATtiny4/5/9/10/20/40) devices, only 4 registers are available.
+     Return true if size is unknown or greater than the limit.  */
+
+  if (size == -1 || size > ret_size_limit)
     {
-      HOST_WIDE_INT size = int_size_in_bytes (type);
-      return (size == -1 || size > 8);
+      return true;
     }
   else
-    return false;
+    {
+      return false;
+    }
 }
 
 
@@ -11094,7 +12238,7 @@ avr_convert_to_type (tree type, tree expr)
     {
       addr_space_t as_old = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (expr)));
       addr_space_t as_new = TYPE_ADDR_SPACE (TREE_TYPE (type));
-        
+
       if (avr_log.progmem)
         avr_edump ("%?: type = %t\nexpr = %t\n\n", type, expr);
 
@@ -11118,6 +12262,115 @@ avr_convert_to_type (tree type, tree expr)
 }
 
 
+/* PR63633: The middle-end might come up with hard regs as input operands.
+
+   RMASK is a bit mask representing a subset of hard registers R0...R31:
+   Rn is an element of that set iff bit n of RMASK is set.
+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then
+   OP[n] has to be fixed; otherwise OP[n] is left alone.
+
+   For each element of OPMASK which is a hard register overlapping RMASK,
+   replace OP[n] with a newly created pseudo register
+
+   HREG == 0:  Also emit a move insn that copies the contents of that
+               hard register into the new pseudo.
+
+   HREG != 0:  Also set HREG[n] to the hard register.  */
+
+static void
+avr_fix_operands (rtx *op, rtx *hreg, unsigned opmask, unsigned rmask)
+{
+  for (; opmask; opmask >>= 1, op++)
+    {
+      rtx reg = *op;
+
+      if (hreg)
+        *hreg = NULL_RTX;
+
+      if ((opmask & 1)
+          && REG_P (reg)
+          && REGNO (reg) < FIRST_PSEUDO_REGISTER
+          // This hard-reg overlaps other prohibited hard regs?
+          && (rmask & regmask (GET_MODE (reg), REGNO (reg))))
+        {
+          *op = gen_reg_rtx (GET_MODE (reg));
+          if (hreg == NULL)
+            emit_move_insn (*op, reg);
+          else
+            *hreg = reg;
+        }
+
+      if (hreg)
+        hreg++;
+    }
+}
+
+
+void
+avr_fix_inputs (rtx *op, unsigned opmask, unsigned rmask)
+{
+  avr_fix_operands (op, NULL, opmask, rmask);
+}
+
+
+/* Helper for the function below:  If bit n of MASK is set and
+   HREG[n] != NULL, then emit a move insn to copy OP[n] to HREG[n].
+   Otherwise do nothing for that n.  Return TRUE.  */
+
+static bool
+avr_move_fixed_operands (rtx *op, rtx *hreg, unsigned mask)
+{
+  for (; mask; mask >>= 1, op++, hreg++)
+    if ((mask & 1)
+        && *hreg)
+      emit_move_insn (*hreg, *op);
+
+  return true;
+}
+
+
+/* PR63633: The middle-end might come up with hard regs as output operands.
+
+   GEN is a sequence generating function like gen_mulsi3 with 3 operands OP[].
+   RMASK is a bit mask representing a subset of hard registers R0...R31:
+   Rn is an element of that set iff bit n of RMASK is set.
+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then
+   OP[n] has to be fixed; otherwise OP[n] is left alone.
+
+   Emit the insn sequence as generated by GEN() with all elements of OPMASK
+   which are hard registers overlapping RMASK replaced by newly created
+   pseudo registers.  After the sequence has been emitted, emit insns that
+   move the contents of respective pseudos to their hard regs.  */
+
+bool
+avr_emit3_fix_outputs (rtx (*gen)(rtx,rtx,rtx), rtx *op,
+                       unsigned opmask, unsigned rmask)
+{
+  const int n = 3;
+  rtx hreg[n];
+
+  /* It is legitimate for GEN to call this function, and in order not to
+     get self-recursive we use the following static kludge.  This is the
+     only way not to duplicate all expanders and to avoid ugly and
+     hard-to-maintain C-code instead of the much more appreciated RTL
+     representation as supplied by define_expand.  */
+  static bool lock = false;
+
+  gcc_assert (opmask < (1u << n));
+
+  if (lock)
+    return false;
+
+  avr_fix_operands (op, hreg, opmask, rmask);
+
+  lock = true;
+  emit_insn (gen (op[0], op[1], op[2]));
+  lock = false;
+
+  return avr_move_fixed_operands (op, hreg, opmask);
+}
+
+
 /* Worker function for movmemhi expander.
    XOP[0]  Destination as MEM:BLK
    XOP[1]  Source      "     "
@@ -11164,7 +12417,7 @@ avr_emit_movmemhi (rtx *xop)
       int segment = avr_addrspace[as].segment;
 
       if (segment
-          && avr_current_device->n_flash > 1)
+          && avr_n_flash > 1)
         {
           a_hi8 = GEN_INT (segment);
           emit_move_insn (rampz_rtx, a_hi8 = copy_to_mode_reg (QImode, a_hi8));
@@ -11829,7 +13082,7 @@ avr_init_builtins (void)
 
 #define ITYP(T)                                                         \
   lang_hooks.types.type_for_size (TYPE_PRECISION (T), TYPE_UNSIGNED (T))
-  
+
 #define FX_FTYPE_FX(fx)                                                 \
   tree fx##r_ftype_##fx##r                                              \
     = build_function_type_list (node_##fx##r, node_##fx##r, NULL);      \
@@ -11843,7 +13096,7 @@ avr_init_builtins (void)
   tree fx##k_ftype_##fx##k_int                                          \
     = build_function_type_list (node_##fx##k, node_##fx##k,             \
                                 integer_type_node, NULL)
-  
+
 #define INT_FTYPE_FX(fx)                                                \
   tree int_ftype_##fx##r                                                \
     = build_function_type_list (integer_type_node, node_##fx##r, NULL); \
@@ -12087,7 +13340,7 @@ avr_expand_builtin (tree exp, rtx target,
 
       /* Warn about odd rounding.  Rounding points >= FBIT will have
          no effect.  */
-      
+
       if (TREE_CODE (CALL_EXPR_ARG (exp, 1)) != INTEGER_CST)
         break;
 
@@ -12436,6 +13689,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,
 #undef  TARGET_BUILTIN_SETJMP_FRAME_VALUE
 #define TARGET_BUILTIN_SETJMP_FRAME_VALUE avr_builtin_setjmp_frame_value
 
+#undef TARGET_CONDITIONAL_REGISTER_USAGE
+#define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage
+
 #undef  TARGET_HARD_REGNO_SCRATCH_OK
 #define TARGET_HARD_REGNO_SCRATCH_OK avr_hard_regno_scratch_ok
 #undef  TARGET_CASE_VALUES_THRESHOLD
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 9d34983..b3959ef 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -60,21 +60,23 @@ enum
 
 #define TARGET_CPU_CPP_BUILTINS()	avr_cpu_cpp_builtins (pfile)
 
-#define AVR_HAVE_JMP_CALL (avr_current_arch->have_jmp_call)
-#define AVR_HAVE_MUL (avr_current_arch->have_mul)
-#define AVR_HAVE_MOVW (avr_current_arch->have_movw_lpmx)
-#define AVR_HAVE_LPMX (avr_current_arch->have_movw_lpmx)
-#define AVR_HAVE_ELPM (avr_current_arch->have_elpm)
-#define AVR_HAVE_ELPMX (avr_current_arch->have_elpmx)
-#define AVR_HAVE_RAMPD (avr_current_arch->have_rampd)
-#define AVR_HAVE_RAMPX (avr_current_arch->have_rampd)
-#define AVR_HAVE_RAMPY (avr_current_arch->have_rampd)
-#define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm             \
-                        || avr_current_arch->have_rampd)
-#define AVR_HAVE_EIJMP_EICALL (avr_current_arch->have_eijmp_eicall)
+#define AVR_HAVE_JMP_CALL (avr_arch->have_jmp_call)
+#define AVR_HAVE_MUL (avr_arch->have_mul)
+#define AVR_HAVE_MOVW (avr_arch->have_movw_lpmx)
+#define AVR_HAVE_LPM (!AVR_TINY)
+#define AVR_HAVE_LPMX (avr_arch->have_movw_lpmx)
+#define AVR_HAVE_ELPM (avr_arch->have_elpm)
+#define AVR_HAVE_ELPMX (avr_arch->have_elpmx)
+#define AVR_HAVE_RAMPD (avr_arch->have_rampd)
+#define AVR_HAVE_RAMPX (avr_arch->have_rampd)
+#define AVR_HAVE_RAMPY (avr_arch->have_rampd)
+#define AVR_HAVE_RAMPZ (avr_arch->have_elpm             \
+                        || avr_arch->have_rampd)
+#define AVR_HAVE_EIJMP_EICALL (avr_arch->have_eijmp_eicall)
 
 /* Handling of 8-bit SP versus 16-bit SP is as follows:
 
+FIXME: DRIVER_SELF_SPECS has changed.
    -msp8 is used internally to select the right multilib for targets with
    8-bit SP.  -msp8 is set automatically by DRIVER_SELF_SPECS for devices
    with 8-bit SP or by multilib generation machinery.  If a frame pointer is
@@ -88,16 +90,16 @@ enum
    __AVR_HAVE_8BIT_SP__ and __AVR_HAVE_16BIT_SP__.  During multilib generation
    there is always __AVR_SP8__ == __AVR_HAVE_8BIT_SP__.  */
 
-#define AVR_HAVE_8BIT_SP                                 \
-  ((avr_current_device->dev_attribute & AVR_SHORT_SP) || \
-   TARGET_TINY_STACK || avr_sp8)
+#define AVR_HAVE_8BIT_SP                        \
+  (TARGET_TINY_STACK || avr_sp8)
 
 #define AVR_HAVE_SPH (!avr_sp8)
 
 #define AVR_2_BYTE_PC (!AVR_HAVE_EIJMP_EICALL)
 #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)
 
-#define AVR_XMEGA (avr_current_arch->xmega_p)
+#define AVR_XMEGA (avr_arch->xmega_p)
+#define AVR_TINY  (avr_arch->tiny_p)
 
 #define BITS_BIG_ENDIAN 0
 #define BYTES_BIG_ENDIAN 0
@@ -145,6 +147,8 @@ enum
 #define SIZE_TYPE (INT_TYPE_SIZE == 8 ? "long unsigned int" : "unsigned int")
 #define PTRDIFF_TYPE (INT_TYPE_SIZE == 8 ? "long int" :"int")
 
+#define WCHAR_TYPE "int"
+#define WINT_TYPE "int"
 #define WCHAR_TYPE_SIZE 16
 
 #define FIRST_PSEUDO_REGISTER 36
@@ -304,13 +308,13 @@ enum reg_class {
 
 #define ARG_POINTER_REGNUM 34
 
-#define STATIC_CHAIN_REGNUM 2
+#define STATIC_CHAIN_REGNUM ((AVR_TINY) ? 18 :2)
 
 #define ELIMINABLE_REGS {					\
-      {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},		\
-      {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},		\
-	{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}		\
-       ,{FRAME_POINTER_REGNUM+1,STACK_POINTER_REGNUM+1}}
+    { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },               \
+    { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM },               \
+    { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },             \
+    { FRAME_POINTER_REGNUM + 1, STACK_POINTER_REGNUM + 1 } }
 
 #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
   OFFSET = avr_initial_elimination_offset (FROM, TO)
@@ -403,7 +407,8 @@ typedef struct avr_args
   avr_asm_output_aligned_decl_common (STREAM, DECL, NAME, SIZE, ALIGN, false)
 
 #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
-  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+  avr_asm_asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN, \
+				  asm_output_aligned_bss)
 
 #define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGN)  \
   avr_asm_output_aligned_decl_common (STREAM, DECL, NAME, SIZE, ALIGN, true)
@@ -488,60 +493,24 @@ typedef struct avr_args
 #define ADJUST_INSN_LENGTH(INSN, LENGTH)                \
     (LENGTH = avr_adjust_insn_length (INSN, LENGTH))
 
-extern const char *avr_device_to_as (int argc, const char **argv);
-extern const char *avr_device_to_ld (int argc, const char **argv);
-extern const char *avr_device_to_data_start (int argc, const char **argv);
-extern const char *avr_device_to_startfiles (int argc, const char **argv);
-extern const char *avr_device_to_devicelib (int argc, const char **argv);
-extern const char *avr_device_to_sp8 (int argc, const char **argv);
+extern const char *avr_devicespecs_file (int, const char**);
 
-#define EXTRA_SPEC_FUNCTIONS                            \
-  { "device_to_as", avr_device_to_as },                 \
-  { "device_to_ld", avr_device_to_ld },                 \
-  { "device_to_data_start", avr_device_to_data_start }, \
-  { "device_to_startfile", avr_device_to_startfiles },  \
-  { "device_to_devicelib", avr_device_to_devicelib },   \
-  { "device_to_sp8", avr_device_to_sp8 },
+#define EXTRA_SPEC_FUNCTIONS                                   \
+  { "device-specs-file", avr_devicespecs_file },
 
-#define DRIVER_SELF_SPECS " %:device_to_sp8(%{mmcu=*:%*}) "
-#define CPP_SPEC ""
+/* Driver self specs has lmited functionality w.r.t. '%s' for dynamic specs.
+   Apply '%s' to a static string to inflate the file (directory) name which
+   is used to diagnose problems with reading the specs file.  */
 
-#define CC1_SPEC ""
+#undef  DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS                       \
+  " %:device-specs-file(device-specs%s %{mmcu=*:%*})"
 
-#define CC1PLUS_SPEC "%{!frtti:-fno-rtti} \
-    %{!fenforce-eh-specs:-fno-enforce-eh-specs} \
-    %{!fexceptions:-fno-exceptions}"
-
-#define ASM_SPEC "%:device_to_as(%{mmcu=*:%*}) "
-  
-#define LINK_SPEC "\
-%{mrelax:--relax\
-         %{mpmem-wrap-around:%{mmcu=at90usb8*:--pmem-wrap-around=8k}\
-                             %{mmcu=atmega16*:--pmem-wrap-around=16k}\
-                             %{mmcu=atmega32*|\
-                               mmcu=at90can32*:--pmem-wrap-around=32k}\
-                             %{mmcu=atmega64*|\
-                               mmcu=at90can64*|\
-                               mmcu=at90usb64*:--pmem-wrap-around=64k}}}\
-%:device_to_ld(%{mmcu=*:%*})\
-%:device_to_data_start(%{mmcu=*:%*})\
-%{shared:%eshared is not supported}"
-
-#define LIB_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
-
-#define LIBSTDCXX "gcc"
 /* No libstdc++ for now.  Empty string doesn't work.  */
+#define LIBSTDCXX "gcc"
 
-#define LIBGCC_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lgcc }}}}}"
-
-#define STARTFILE_SPEC "%:device_to_startfile(%{mmcu=*:%*})"
-
-#define ENDFILE_SPEC ""
-
-/* This is the default without any -mmcu=* option (AT90S*).  */
-#define MULTILIB_DEFAULTS { "mmcu=avr2" }
+/* This is the default without any -mmcu=* option.  */
+#define MULTILIB_DEFAULTS { "mmcu=" AVR_MMCU_DEFAULT }
 
 #define TEST_HARD_REG_CLASS(CLASS, REGNO) \
   TEST_HARD_REG_BIT (reg_class_contents[ (int) (CLASS)], REGNO)
@@ -574,6 +543,10 @@ struct GTY(()) machine_function
   /* 'true' - if current function is a signal function 
      as specified by the "signal" attribute.  */
   int is_signal;
+
+  /* 'true' - if current function is an nmi function 
+     as specified by the "nmi" attribute.  */
+  int is_nmi;
   
   /* 'true' - if current function is a 'task' function 
      as specified by the "OS_task" attribute.  */
@@ -605,3 +578,8 @@ extern int avr_accumulate_outgoing_args (void);
 #define ACCUMULATE_OUTGOING_ARGS avr_accumulate_outgoing_args()
 
 #define INIT_EXPANDERS avr_init_expanders()
+
+/* Flags used for io and address attributes.  */
+#define SYMBOL_FLAG_IO_LOW	(SYMBOL_FLAG_MACH_DEP << 4)
+#define SYMBOL_FLAG_IO		(SYMBOL_FLAG_MACH_DEP << 5)
+#define SYMBOL_FLAG_ADDRESS	(SYMBOL_FLAG_MACH_DEP << 6)
diff --git a/gcc/config/avr/avr.md b/gcc/config/avr/avr.md
index 2d90b76..5e2fdb9 100644
--- a/gcc/config/avr/avr.md
+++ b/gcc/config/avr/avr.md
@@ -24,6 +24,10 @@
 ;;  B  Add 1 to REG number, MEM address or CONST_INT.
 ;;  C  Add 2.
 ;;  D  Add 3.
+;;  E  reg number in XEXP(x, 0).
+;;  F  Add 1 to reg number.
+;;  I  reg number in XEXP(XEXP(x, 0), 0).
+;;  J  Add 1 to reg number.
 ;;  j  Branch condition.
 ;;  k  Reverse branch condition.
 ;;..m..Constant Direct Data memory address.
@@ -59,6 +63,11 @@
    (ZERO_REGNO  1)      ; zero register r1
    ])
 
+(define_constants
+  [(TMP_REGNO_TINY  16) ; r16 is temp register for AVR_TINY
+   (ZERO_REGNO_TINY 17) ; r17 is zero register for AVR_TINY
+  ])
+
 (define_c_enum "unspec"
   [UNSPEC_STRLEN
    UNSPEC_MOVMEM
@@ -138,7 +147,7 @@
 ;; Otherwise do special processing depending on the attribute.
 
 (define_attr "adjust_len"
-  "out_bitop, plus, addto_sp,
+  "out_bitop, plus, addto_sp, sext,
    tsthi, tstpsi, tstsi, compare, compare64, call,
    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,
    ufract, sfract, round,
@@ -159,9 +168,10 @@
 ;; lpm  : ISA has no LPMX                lpmx  : ISA has LPMX
 ;; elpm : ISA has ELPM but no ELPMX      elpmx : ISA has ELPMX
 ;; no_xmega: non-XMEGA core              xmega : XMEGA core
+;; no_tiny:  non-TINY core               tiny  : TINY core
 
 (define_attr "isa"
-  "mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega,
+  "mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega, no_tiny,tiny,
    standard"
   (const_string "standard"))
 
@@ -213,9 +223,18 @@
               (match_test "AVR_XMEGA"))
          (const_int 1)
 
+         (and (eq_attr "isa" "tiny")
+              (match_test "AVR_TINY"))
+         (const_int 1)
+
          (and (eq_attr "isa" "no_xmega")
               (match_test "!AVR_XMEGA"))
          (const_int 1)
+
+         (and (eq_attr "isa" "no_tiny")
+              (match_test "!AVR_TINY"))
+         (const_int 1)
+
          ] (const_int 0)))
 
 
@@ -352,6 +371,13 @@
 	push __zero_reg__"
   [(set_attr "length" "1,1")])
 
+(define_insn "pushhi1_insn"
+  [(set (mem:HI (post_dec:HI (reg:HI REG_SP)))
+        (match_operand:HI 0 "register_operand" "r"))]
+  ""
+  "push %B0\;push %A0"
+  [(set_attr "length" "2")])
+
 ;; All modes for a multi-byte push.  We must include complex modes here too,
 ;; lest emit_single_push_insn "helpfully" create the auto-inc itself.
 (define_mode_iterator MPUSH
@@ -367,17 +393,42 @@
   [(match_operand:MPUSH 0 "" "")]
   ""
   {
-    int i;
-
-    // Avoid (subreg (mem)) for non-generic address spaces below.  Because
-    // of the poor addressing capabilities of these spaces it's better to
-    // load them in one chunk.  And it avoids PR61443.
-
     if (MEM_P (operands[0])
         && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (operands[0])))
-      operands[0] = copy_to_mode_reg (<MODE>mode, operands[0]);
+      {
+        // Avoid (subreg (mem)) for non-generic address spaces.  Because
+        // of the poor addressing capabilities of these spaces it's better to
+        // load them in one chunk.  And it avoids PR61443.
+
+        operands[0] = copy_to_mode_reg (<MODE>mode, operands[0]);
+      }
+    else if (REG_P (operands[0])
+             && IN_RANGE (REGNO (operands[0]), FIRST_VIRTUAL_REGISTER,
+                          LAST_VIRTUAL_REGISTER))
+      {
+        // Byte-wise pushing of virtual regs might result in something like
+        //
+        //     (set (mem:QI (post_dec:HI (reg:HI 32 SP)))
+        //          (subreg:QI (plus:HI (reg:HI 28)
+        //                              (const_int 17)) 0))
+        //
+        // after elimination.  This cannot be handled by reload, cf. PR64452.
+        // Reload virtuals in one chunk.  That way it's possible to reload
+        // above situation and finally
+        //
+        //    (set (reg:HI **)
+        //         (const_int 17))
+        //    (set (reg:HI **)
+        //         (plus:HI (reg:HI **)
+        //                  (reg:HI 28)))
+        //    (set (mem:HI (post_dec:HI (reg:HI 32 SP))
+        //         (reg:HI **)))
+ 
+        emit_insn (gen_pushhi1_insn (operands[0]));
+        DONE;
+      }
 
-    for (i = GET_MODE_SIZE (<MODE>mode) - 1; i >= 0; --i)
+    for (int i = GET_MODE_SIZE (<MODE>mode) - 1; i >= 0; --i)
       {
         rtx part = simplify_gen_subreg (QImode, operands[0], <MODE>mode, i);
         if (part != const0_rtx)
@@ -584,7 +635,7 @@
   ""
   {
     rtx dest = operands[0];
-    rtx src  = operands[1];
+    rtx src  = avr_eval_addr_attrib (operands[1]);
 
     if (avr_mem_flash_p (dest))
       DONE;
@@ -636,7 +687,7 @@
   [(set (match_operand:ALL1 0 "nonimmediate_operand" "=r    ,d    ,Qm   ,r ,q,r,*r")
         (match_operand:ALL1 1 "nox_general_operand"   "r Y00,n Ynn,r Y00,Qm,r,q,i"))]
   "register_operand (operands[0], <MODE>mode)
-   || reg_or_0_operand (operands[1], <MODE>mode)"
+    || reg_or_0_operand (operands[1], <MODE>mode)"
   {
     return output_movqi (insn, operands, NULL);
   }
@@ -1482,7 +1533,11 @@
    (set (reg:QI 22) (match_operand:QI 2 "register_operand" ""))
    (parallel [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))
               (clobber (reg:QI 22))])
-   (set (match_operand:QI 0 "register_operand" "") (reg:QI 24))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
+  })
 
 (define_insn "*mulqi3_call"
   [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))
@@ -2162,10 +2217,10 @@
         DONE;
       }
 
-    /* For small constants we can do better by extending them on the fly.
-       The constant can be loaded in one instruction and the widening
-       multiplication is shorter.  First try the unsigned variant because it
-       allows constraint "d" instead of "a" for the signed version.  */
+    /* ; For small constants we can do better by extending them on the fly.
+       ; The constant can be loaded in one instruction and the widening
+       ; multiplication is shorter.  First try the unsigned variant because it
+       ; allows constraint "d" instead of "a" for the signed version.  */
 
     if (s9_operand (operands[2], HImode))
       {
@@ -2210,7 +2265,13 @@
    (parallel [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))
               (clobber (reg:HI 22))
               (clobber (reg:QI 21))])
-   (set (match_operand:HI 0 "register_operand" "") (reg:HI 24))])
+   (set (match_operand:HI 0 "register_operand" "")
+        (reg:HI 24))]
+  ""
+  {
+    avr_fix_inputs (operands, (1 << 2), regmask (HImode, 24));
+  })
+
 
 (define_insn "*mulhi3_call"
   [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))
@@ -2248,6 +2309,10 @@
         emit_insn (gen_mulohisi3 (operands[0], operands[2], operands[1]));
         DONE;
       }
+
+    if (avr_emit3_fix_outputs (gen_mulsi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
   })
 
 (define_insn_and_split "*mulsi3"
@@ -2287,7 +2352,23 @@
 
 ;; "muluqisi3"
 ;; "muluhisi3"
-(define_insn_and_split "mulu<mode>si3"
+(define_expand "mulu<mode>si3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (zero_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" ""))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulu<mode>si3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+;; "*muluqisi3"
+;; "*muluhisi3"
+(define_insn_and_split "*mulu<mode>si3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                           "=r")
         (mult:SI (zero_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" "r"))
                  (match_operand:SI 2 "pseudo_register_or_const_int_operand"      "rn")))
@@ -2323,7 +2404,23 @@
 
 ;; "mulsqisi3"
 ;; "mulshisi3"
-(define_insn_and_split "muls<mode>si3"
+(define_expand "muls<mode>si3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (sign_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" ""))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_muls<mode>si3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+;; "*mulsqisi3"
+;; "*mulshisi3"
+(define_insn_and_split "*muls<mode>si3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                           "=r")
         (mult:SI (sign_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" "r"))
                  (match_operand:SI 2 "pseudo_register_or_const_int_operand"      "rn")))
@@ -2366,7 +2463,22 @@
 
 ;; One-extend operand 1
 
-(define_insn_and_split "mulohisi3"
+(define_expand "mulohisi3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (not:SI (zero_extend:SI
+                                     (not:HI (match_operand:HI 1 "pseudo_register_operand" ""))))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulohisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+(define_insn_and_split "*mulohisi3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                          "=r")
         (mult:SI (not:SI (zero_extend:SI
                           (not:HI (match_operand:HI 1 "pseudo_register_operand" "r"))))
@@ -2394,7 +2506,12 @@
                             (any_extend:SI (match_operand:HI 2 "register_operand" ""))))
               (clobber (reg:HI 26))
               (clobber (reg:DI 18))])]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    if (avr_emit3_fix_outputs (gen_<extend_u>mulhisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
 
 (define_expand "usmulhisi3"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
@@ -2402,7 +2519,12 @@
                             (sign_extend:SI (match_operand:HI 2 "register_operand" ""))))
               (clobber (reg:HI 26))
               (clobber (reg:DI 18))])]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    if (avr_emit3_fix_outputs (gen_usmulhisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
 
 ;; "*uumulqihisi3" "*uumulhiqisi3" "*uumulhihisi3" "*uumulqiqisi3"
 ;; "*usmulqihisi3" "*usmulhiqisi3" "*usmulhihisi3" "*usmulqiqisi3"
@@ -2474,7 +2596,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:HI 0 "register_operand" "")
         (reg:HI 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (HImode, 18));
+  })
 
 
 (define_insn "*mulsi3_call"
@@ -2697,6 +2822,10 @@
         emit_insn (gen_mulsqipsi3 (operands[0], reg, operands[1]));
         DONE;
       }
+
+    if (avr_emit3_fix_outputs (gen_mulpsi3, operands, 1u << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
   })
 
 (define_insn "*umulqihipsi3"
@@ -2729,7 +2858,21 @@
   [(set_attr "length" "7")
    (set_attr "cc" "clobber")])
 
-(define_insn_and_split "mulsqipsi3"
+(define_expand "mulsqipsi3"
+  [(parallel [(set (match_operand:PSI 0 "pseudo_register_operand" "")
+                   (mult:PSI (sign_extend:PSI (match_operand:QI 1 "pseudo_register_operand" ""))
+                             (match_operand:PSI 2 "pseudo_register_or_const_int_operand""")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulsqipsi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+(define_insn_and_split "*mulsqipsi3"
   [(set (match_operand:PSI 0 "pseudo_register_operand"                          "=r")
         (mult:PSI (sign_extend:PSI (match_operand:QI 1 "pseudo_register_operand" "r"))
                   (match_operand:PSI 2 "pseudo_register_or_const_int_operand"    "rn")))
@@ -3188,7 +3331,7 @@
 	swap %0\;lsl %0\;adc %0,__zero_reg__
 	swap %0\;lsl %0\;adc %0,__zero_reg__\;lsl %0\;adc %0,__zero_reg__
 	bst %0,0\;ror %0\;bld %0,7
-	"
+	" ; empty
   [(set_attr "length" "2,4,4,1,3,5,3,0")
    (set_attr "cc" "set_n,set_n,clobber,none,set_n,set_n,clobber,none")])
 
@@ -4108,62 +4251,66 @@
   [(set (match_operand:HI 0 "register_operand" "=r,r")
         (sign_extend:HI (match_operand:QI 1 "combine_pseudo_register_operand" "0,*r")))]
   ""
-  "@
-	clr %B0\;sbrc %0,7\;com %B0
-	mov %A0,%A1\;clr %B0\;sbrc %A0,7\;com %B0"
+  {
+    return avr_out_sign_extend (insn, operands, NULL);
+  }
   [(set_attr "length" "3,4")
-   (set_attr "cc" "set_n,set_n")])
+   (set_attr "adjust_len" "sext")
+   (set_attr "cc" "set_n")])
 
 (define_insn "extendqipsi2"
   [(set (match_operand:PSI 0 "register_operand" "=r,r")
         (sign_extend:PSI (match_operand:QI 1 "combine_pseudo_register_operand" "0,*r")))]
   ""
-  "@
-	clr %B0\;sbrc %A0,7\;com %B0\;mov %C0,%B0
-	mov %A0,%A1\;clr %B0\;sbrc %A0,7\;com %B0\;mov %C0,%B0"
+  {
+    return avr_out_sign_extend (insn, operands, NULL);
+  }
   [(set_attr "length" "4,5")
-   (set_attr "cc" "set_n,set_n")])
+   (set_attr "adjust_len" "sext")
+   (set_attr "cc" "set_n")])
 
 (define_insn "extendqisi2"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
         (sign_extend:SI (match_operand:QI 1 "combine_pseudo_register_operand" "0,*r")))]
   ""
-  "@
-	clr %B0\;sbrc %A0,7\;com %B0\;mov %C0,%B0\;mov %D0,%B0
-	mov %A0,%A1\;clr %B0\;sbrc %A0,7\;com %B0\;mov %C0,%B0\;mov %D0,%B0"
+  {
+    return avr_out_sign_extend (insn, operands, NULL);
+  }
   [(set_attr "length" "5,6")
-   (set_attr "cc" "set_n,set_n")])
+   (set_attr "adjust_len" "sext")
+   (set_attr "cc" "set_n")])
 
 (define_insn "extendhipsi2"
-  [(set (match_operand:PSI 0 "register_operand"                               "=r,r ,r")
-        (sign_extend:PSI (match_operand:HI 1 "combine_pseudo_register_operand" "0,*r,*r")))]
+  [(set (match_operand:PSI 0 "register_operand"                               "=r,r")
+        (sign_extend:PSI (match_operand:HI 1 "combine_pseudo_register_operand" "0,*r")))]
   ""
-  "@
-	clr %C0\;sbrc %B0,7\;com %C0
-	mov %A0,%A1\;mov %B0,%B1\;clr %C0\;sbrc %B0,7\;com %C0
-	movw %A0,%A1\;clr %C0\;sbrc %B0,7\;com %C0"
-  [(set_attr "length" "3,5,4")
-   (set_attr "isa" "*,mov,movw")
+  {
+    return avr_out_sign_extend (insn, operands, NULL);
+  }
+  [(set_attr "length" "3,5")
+   (set_attr "adjust_len" "sext")
    (set_attr "cc" "set_n")])
 
 (define_insn "extendhisi2"
-  [(set (match_operand:SI 0 "register_operand"                               "=r,r ,r")
-        (sign_extend:SI (match_operand:HI 1 "combine_pseudo_register_operand" "0,*r,*r")))]
+  [(set (match_operand:SI 0 "register_operand"                               "=r,r")
+        (sign_extend:SI (match_operand:HI 1 "combine_pseudo_register_operand" "0,*r")))]
   ""
-  "@
-	clr %C0\;sbrc %B0,7\;com %C0\;mov %D0,%C0
-	mov %A0,%A1\;mov %B0,%B1\;clr %C0\;sbrc %B0,7\;com %C0\;mov %D0,%C0
-	movw %A0,%A1\;clr %C0\;sbrc %B0,7\;com %C0\;mov %D0,%C0"
-  [(set_attr "length" "4,6,5")
-   (set_attr "isa" "*,mov,movw")
+  {
+    return avr_out_sign_extend (insn, operands, NULL);
+  }
+  [(set_attr "length" "4,6")
+   (set_attr "adjust_len" "sext")
    (set_attr "cc" "set_n")])
 
 (define_insn "extendpsisi2"
   [(set (match_operand:SI 0 "register_operand"                                "=r")
         (sign_extend:SI (match_operand:PSI 1 "combine_pseudo_register_operand" "0")))]
   ""
-  "clr %D0\;sbrc %C0,7\;com %D0"
+  {
+    return avr_out_sign_extend (insn, operands, NULL);
+  }
   [(set_attr "length" "3")
+   (set_attr "adjust_len" "sext")
    (set_attr "cc" "set_n")])
 
 ;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
@@ -5013,7 +5160,7 @@
 ;; Clear/set/test a single bit in I/O address space.
 
 (define_insn "*cbi"
-  [(set (mem:QI (match_operand 0 "low_io_address_operand" "n"))
+  [(set (mem:QI (match_operand 0 "low_io_address_operand" "i"))
         (and:QI (mem:QI (match_dup 0))
                 (match_operand:QI 1 "single_zero_operand" "n")))]
   ""
@@ -5025,7 +5172,7 @@
    (set_attr "cc" "none")])
 
 (define_insn "*sbi"
-  [(set (mem:QI (match_operand 0 "low_io_address_operand" "n"))
+  [(set (mem:QI (match_operand 0 "low_io_address_operand" "i"))
         (ior:QI (mem:QI (match_dup 0))
                 (match_operand:QI 1 "single_one_operand" "n")))]
   ""
@@ -5042,7 +5189,7 @@
         (if_then_else
          (match_operator 0 "eqne_operator"
                          [(zero_extract:QIHI
-                           (mem:QI (match_operand 1 "low_io_address_operand" "n"))
+                           (mem:QI (match_operand 1 "low_io_address_operand" "i"))
                            (const_int 1)
                            (match_operand 2 "const_int_operand" "n"))
                           (const_int 0)])
@@ -5066,7 +5213,7 @@
   [(set (pc)
         (if_then_else
          (match_operator 0 "gelt_operator"
-                         [(mem:QI (match_operand 1 "low_io_address_operand" "n"))
+                         [(mem:QI (match_operand 1 "low_io_address_operand" "i"))
                           (const_int 0)])
          (label_ref (match_operand 2 "" ""))
          (pc)))]
@@ -5381,7 +5528,7 @@
                       (label_ref (match_operand 0 "" ""))
                       (pc)))]
   "!AVR_HAVE_JMP_CALL
-   || !(avr_current_device->dev_attribute & AVR_ERRATA_SKIP)"
+   || !TARGET_SKIP_BUG"
   {
     if (operands[2] == CONST0_RTX (<MODE>mode))
       operands[2] = zero_reg_rtx;
@@ -5544,24 +5691,24 @@
    (clobber (match_scratch:QI 2 "=&d"))]
   ""
   "ldi %2,lo8(%0)
-	1: dec %2
+1:	dec %2
 	brne 1b"
   [(set_attr "length" "3")
    (set_attr "cc" "clobber")])
 
 (define_insn "delay_cycles_2"
-  [(unspec_volatile [(match_operand:HI 0 "const_int_operand" "n")
+  [(unspec_volatile [(match_operand:HI 0 "const_int_operand" "n,n")
                      (const_int 2)]
                     UNSPECV_DELAY_CYCLES)
    (set (match_operand:BLK 1 "" "")
 	(unspec_volatile:BLK [(match_dup 1)] UNSPECV_MEMORY_BARRIER))
-   (clobber (match_scratch:HI 2 "=&w"))]
+   (clobber (match_scratch:HI 2 "=&w,&d"))]
   ""
-  "ldi %A2,lo8(%0)
-	ldi %B2,hi8(%0)
-	1: sbiw %A2,1
-	brne 1b"
-  [(set_attr "length" "4")
+  "@
+	ldi %A2,lo8(%0)\;ldi %B2,hi8(%0)\n1:	sbiw %A2,1\;brne 1b
+	ldi %A2,lo8(%0)\;ldi %B2,hi8(%0)\n1:	subi %A2,1\;sbci %B2,0\;brne 1b"
+  [(set_attr "length" "4,5")
+   (set_attr "isa" "no_tiny,tiny")
    (set_attr "cc" "clobber")])
 
 (define_insn "delay_cycles_3"
@@ -5577,7 +5724,7 @@
   "ldi %2,lo8(%0)
 	ldi %3,hi8(%0)
 	ldi %4,hlo8(%0)
-	1: subi %2,1
+1:	subi %2,1
 	sbci %3,0
 	sbci %4,0
 	brne 1b"
@@ -5599,7 +5746,7 @@
 	ldi %3,hi8(%0)
 	ldi %4,hlo8(%0)
 	ldi %5,hhi8(%0)
-	1: subi %2,1
+1:	subi %2,1
 	sbci %3,0
 	sbci %4,0
 	sbci %5,0
@@ -6064,6 +6211,7 @@
         emit_insn (gen_fmul_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmul_insn"
@@ -6107,6 +6255,7 @@
         emit_insn (gen_fmuls_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmuls_insn"
@@ -6150,6 +6299,7 @@
         emit_insn (gen_fmulsu_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmulsu_insn"
@@ -6239,7 +6389,7 @@
 ;; in contrast to a IN/BST/BLD/OUT sequence we need less registers and the
 ;; operation on I/O is atomic.
 (define_insn "*insv.io"
-  [(set (zero_extract:QI (mem:QI (match_operand 0 "low_io_address_operand" "n,n,n"))
+  [(set (zero_extract:QI (mem:QI (match_operand 0 "low_io_address_operand" "i,i,i"))
                          (const_int 1)
                          (match_operand:QI 1 "const_0_to_7_operand"        "n,n,n"))
         (match_operand:QI 2 "nonmemory_operand"                            "L,P,r"))]
@@ -6252,7 +6402,7 @@
    (set_attr "cc" "none")])
 
 (define_insn "*insv.not.io"
-  [(set (zero_extract:QI (mem:QI (match_operand 0 "low_io_address_operand" "n"))
+  [(set (zero_extract:QI (mem:QI (match_operand 0 "low_io_address_operand" "i"))
                          (const_int 1)
                          (match_operand:QI 1 "const_0_to_7_operand"        "n"))
         (not:QI (match_operand:QI 2 "register_operand"                     "r")))]
diff --git a/gcc/config/avr/avr.opt b/gcc/config/avr/avr.opt
index 5be80aa..d3784e5 100644
--- a/gcc/config/avr/avr.opt
+++ b/gcc/config/avr/avr.opt
@@ -23,9 +23,21 @@ Target Report Mask(CALL_PROLOGUES)
 Use subroutines for function prologues and epilogues
 
 mmcu=
-Target RejectNegative Joined Var(avr_mcu_index) Init(0) Enum(avr_mcu)
+Target RejectNegative Joined Var(avr_mmcu) MissingArgError(missing device or architecture after %qs)
 -mmcu=MCU	Select the target MCU
 
+mn-flash=
+Target RejectNegative Joined Var(avr_n_flash) UInteger Init(-1)
+Set the number of 64 KiB flash segments
+
+mskip-bug
+Target Report Mask(SKIP_BUG)
+Indicate presence of a processor erratum
+
+mrmw
+Target Report Mask(RMW)
+Enable Read-Modify-Write (RMW) instructions support/use
+
 mdeb
 Target Report Undocumented Mask(ALL_DEBUG)
 
@@ -82,3 +94,7 @@ Warn if the address space of an address is changed.
 mfract-convert-truncate
 Target Report Mask(FRACT_CONV_TRUNC)
 Allow to use truncation instead of rounding towards 0 for fractional int types
+
+nodevicelib
+Driver Target Report RejectNegative
+Do not link against the device-specific library lib<MCU>.a
diff --git a/gcc/config/avr/avrlibc.h b/gcc/config/avr/avrlibc.h
index fee685b..159ba60 100644
--- a/gcc/config/avr/avrlibc.h
+++ b/gcc/config/avr/avrlibc.h
@@ -19,11 +19,21 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-/* AVR-Libc implements functions from libgcc.a in libm.a, see PR54461.  */
+#undef  LIB_SPEC
+#define LIB_SPEC                                \
+  "%{!mmcu=avr1:-lc} %(avrlibc_devicelib)"
+
+// AVR-Libc implements functions from libgcc.a in libm.a, see PR54461.
+// For a list of functions which are provided by libm.a and are
+// omitted from libgcc.a see libgcc's t-avrlibc.
 
 #undef  LIBGCC_SPEC
-#define LIBGCC_SPEC                                                     \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lgcc -lm }}}}}"
+#define LIBGCC_SPEC                             \
+  "%{!mmcu=avr1:-lgcc -lm}"
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC                          \
+  " %(avrlibc_startfile) "
 
 #undef  LINK_GCC_C_SEQUENCE_SPEC
 #define LINK_GCC_C_SEQUENCE_SPEC \
diff --git a/gcc/config/avr/driver-avr.c b/gcc/config/avr/driver-avr.c
index 76c8b39..e797dda 100644
--- a/gcc/config/avr/driver-avr.c
+++ b/gcc/config/avr/driver-avr.c
@@ -1,6 +1,6 @@
 /* Subroutines for the gcc driver.
-   Copyright (C) 2009-2014 Free Software Foundation, Inc.
-   Contributed by Anatoly Sokolov <aesok@post.ru>
+   Copyright (C) 2009-2015 Free Software Foundation, Inc.
+   Contributed by Georg-Johann Lay <avr@gjlay.de>
 
 This file is part of GCC.
 
@@ -21,130 +21,135 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "diagnostic.h"
 #include "tm.h"
 
-/* Current architecture.  */
-const avr_arch_t *avr_current_arch = NULL;
+// Remove -nodevicelib from the command line if not needed
+#define X_NODEVLIB "%<nodevicelib"
 
-/* Current device.  */
-const avr_mcu_t *avr_current_device = NULL;
+static const char dir_separator_str[] = { DIR_SEPARATOR, 0 };
 
-/* Initialize avr_current_arch and avr_current_device variables.  */
+static const char specfiles_doc_url[] =
+  "http://gcc.gnu.org/onlinedocs/gcc/Spec-Files.html";
 
-static void
-avr_set_current_device (const char *name)
-{
- 
- if (NULL != avr_current_arch)
-   return;
- 
-  for (avr_current_device = avr_mcu_types; avr_current_device->name;
-       avr_current_device++)
-    {
-      if (strcmp (avr_current_device->name, name) == 0)
-        break;
-    }
-
-  avr_current_arch = &avr_arch_types[avr_current_device->arch];
-}
-
-/* Returns command line parameters to pass to as.  */
-
-const char*
-avr_device_to_as (int argc, const char **argv)
-{
-  if (0 == argc)
-    return NULL;
 
-  avr_set_current_device (argv[0]);
-
-  return concat ("-mmcu=", avr_current_arch->arch_name,
-    avr_current_device->dev_attribute & AVR_ERRATA_SKIP ? "" : " -mno-skip-bug",
-    avr_current_device->dev_attribute & AVR_ISA_RMW ? " -mrmw" : "", NULL);
-}
-
-/* Returns command line parameters to pass to ld.  */
-
-const char*
-avr_device_to_ld (int argc, const char **argv)
+static const char*
+avr_diagnose_devicespecs_error (const char *mcu, const char *filename)
 {
-  if (0 == argc)
-    return NULL;
+  error ("cannot access device-specs for %qs expected at %qs",
+         mcu, filename);
 
-  avr_set_current_device (argv[0]);
+  // Inform about natively supported devices and cores.
 
-  return concat ("-m ", avr_current_arch->arch_name, NULL);
-}
-
-/* Returns command line parameters that describe start of date section.  */
+  if (strncmp (mcu, "avr", strlen ("avr")))
+    avr_inform_devices ();
 
-const char *
-avr_device_to_data_start (int argc, const char **argv)
-{
-  unsigned long data_section_start;
-  char data_section_start_str[16];
-
-  if (0 == argc)
-    return NULL;
-
-  avr_set_current_device (argv[0]);
-  
-  if (avr_current_device->data_section_start 
-      == avr_current_arch->default_data_section_start)
-    return NULL;
-    
-  data_section_start = 0x800000 + avr_current_device->data_section_start;
-  
-  snprintf (data_section_start_str, sizeof(data_section_start_str) - 1,
-            "0x%lX", data_section_start);
-  
-  return concat ("-Tdata ", data_section_start_str, NULL);    
-}
-
-/* Returns command line parameters that describe the device startfile.  */
-
-const char *
-avr_device_to_startfiles (int argc, const char **argv)
-{
-  if (0 == argc)
-    return NULL;
+  avr_inform_core_architectures ();
 
-  avr_set_current_device (argv[0]);
+  inform (input_location, "you can provide your own specs files, "
+          "see <%s> for details", specfiles_doc_url);
 
-  return concat ("crt", avr_current_device->library_name, ".o%s", NULL);
+  return X_NODEVLIB;
 }
 
-/* Returns command line parameters that describe the device library.  */
 
-const char *
-avr_device_to_devicelib (int argc, const char **argv)
-{
-  if (0 == argc)
-    return NULL;
-
-  avr_set_current_device (argv[0]);
+/* Implement spec function `device-specs-file.
 
-  return concat ("-l", avr_current_device->library_name, NULL);
-}
+   Compose -specs=<specs-file-name>%s.  If everything went well then argv[0]
+   is the inflated (absolute) specs directory and argv[1] is a device or
+   core name as supplied by -mmcu=*.  When building GCC the path might
+   be relative.  */
 
 const char*
-avr_device_to_sp8 (int argc, const char **argv)
+avr_devicespecs_file (int argc, const char **argv)
 {
-  if (0 == argc)
-    return NULL;
+  char *specfile_name;
+  const char *mmcu = NULL;
 
-  avr_set_current_device (argv[0]);
+#ifdef DEBUG_SPECS
+  if (verbose_flag)
+    fnotice (stderr, "Running spec function '%s' with %d args\n\n",
+             __FUNCTION__, argc);
+#endif
 
-  /* Leave "avr2" and "avr25" alone.  These two architectures are
-     the only ones that mix devices with 8-bit SP and 16-bit SP.
-     -msp8 is set by mmultilib machinery.  */
+  switch (argc)
+    {
+    case 0:
+      fatal_error ("bad usage of spec function %qs", "device-specs-file");
+      return X_NODEVLIB;
+
+    case 1:
+      if (0 == strcmp ("device-specs", argv[0]))
+        {
+          /* FIXME:  This means "device-specs%s" from avr.h:DRIVER_SELF_SPECS
+             has not been resolved to a path.  That case can occur when the
+             c++ testsuite is run from the build directory.  DejaGNU's
+             libgloss.exp:get_multilibs runs $compiler without -B, i.e.runs
+             xgcc without specifying a prefix.  Without any prefix, there is
+             no means to find out where the specs files might be located.
+             get_multilibs runs xgcc --print-multi-lib, hence we don't actually
+             need information form a specs file and may skip it here.  */
+          return X_NODEVLIB;
+        }
+
+      mmcu = AVR_MMCU_DEFAULT;
+      break;
+
+    default:
+      mmcu = argv[1];
+
+      // Allow specifying the same MCU more than once.
+
+      for (int i = 2; i < argc; i++)
+        if (0 != strcmp (mmcu, argv[i]))
+          {
+            error ("specified option %qs more than once", "-mmcu");
+            return X_NODEVLIB;
+          }
+
+      break;
+    }
 
-  if (avr_current_device->macro == NULL
-      && (avr_current_device->arch == ARCH_AVR2
-          || avr_current_device->arch == ARCH_AVR25))
-    return "";
+  specfile_name = concat (argv[0], dir_separator_str, "specs-", mmcu, NULL);
+
+#ifdef DEBUG_SPECS
+  if (verbose_flag)
+    fnotice (stderr, "'%s': mmcu='%s'\n'%s': specfile='%s'\n\n",
+             __FUNCTION__, mmcu, __FUNCTION__, specfile_name);
+#endif
+
+  // Filter out silly -mmcu= arguments like "foo bar".
+
+  for (const char *s = mmcu; *s; s++)
+    if (!ISALNUM (*s)
+        && '-' != *s
+        && '_' != *s)
+      {
+        error ("strange device name %qs after %qs: bad character %qc",
+               mmcu, "-mmcu=", *s);
+        return X_NODEVLIB;
+      }
+
+  if (/* When building / configuring the compiler we might get a relative path
+         as supplied by "-B.".  Assume that the specs file exists and MCU is
+         a core, not a proper device then, i.e. we have "-mmcu=avr*".  */
+      (0 == strncmp (mmcu, "avr", strlen ("avr"))
+       && specfile_name[0] == '.')
+      /* vanilla */
+      || (IS_ABSOLUTE_PATH (specfile_name)
+          && !access (specfile_name, R_OK)))
+    {
+      return concat ("-specs=device-specs", dir_separator_str, "specs-", mmcu,
+                     // Use '%s' instead of the expanded specfile_name.  This
+                     // is the easiest way to handle pathes containing spaces.
+                     "%s",
+#if defined (WITH_AVRLIBC)
+                     " %{mmcu=avr*:" X_NODEVLIB "} %{!mmcu=*:" X_NODEVLIB "}",
+#else
+                     " " X_NODEVLIB,
+#endif
+                     NULL);
+    }
 
-  return (avr_current_device->dev_attribute & AVR_SHORT_SP)
-    ? "-msp8"
-    : "%<msp8";
+  return avr_diagnose_devicespecs_error (mmcu, specfile_name);
 }
diff --git a/gcc/config/avr/gen-avr-mmcu-specs.c b/gcc/config/avr/gen-avr-mmcu-specs.c
new file mode 100644
index 0000000..e180cec
--- /dev/null
+++ b/gcc/config/avr/gen-avr-mmcu-specs.c
@@ -0,0 +1,295 @@
+/* Copyright (C) 1998-2014 Free Software Foundation, Inc.
+   Contributed by Joern Rennecke
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+   
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "config.h"
+
+#define IN_GEN_AVR_MMCU_TEXI
+
+#include "avr-devices.c"
+
+// Get rid of "defaults.h".  We just need tm.h for `WITH_AVRLIBS' and
+// and `WITH_RTEMS'.  */
+#define GCC_DEFAULTS_H
+
+#include "tm.h"
+
+// Mimic the include order as specified in config.gcc::tm_file.
+
+#include "specs.h"
+
+#if defined (WITH_AVRLIBC)
+#include "avrlibc.h"
+#endif
+
+#if defined (WITH_RTEMS)
+#include "../rtems.h"
+#include "rtems.h"
+#endif
+
+
+#define SPECFILE_DOC_URL                                \
+  "https://gcc.gnu.org/onlinedocs/gcc/Spec-Files.html"
+
+#define SPECFILE_USAGE_URL                              \
+  "https://gcc.gnu.org/gcc-5/changes.html"
+
+/* Return true iff STR starts with PREFIX.  */
+
+static bool
+str_prefix_p (const char *str, const char *prefix)
+{
+  return 0 == strncmp (str, prefix, strlen (prefix));
+}
+
+
+static const char header[] =
+  "#\n"
+  "# Generated by   : ./gcc/config/avr/gen-avr-mmcu-specs.c\n"
+  "# Generated from : ./gcc/config/gcc.c\n"
+  "#                  ./gcc/config/avr/specs.h\n"
+#if defined (WITH_RTEMS)
+  "#                  ./gcc/config/rtems.h\n"
+  "#                  ./gcc/config/avr/rtems.h\n"
+#endif
+#if defined (WITH_AVRLIBC)
+  "#                  ./gcc/config/avr/avrlibc.h\n"
+#endif
+  "# Used by        : avr-gcc compiler driver\n"
+  "# Used for       : building command options for sub-processes\n"
+  "#\n"
+  "# See <" SPECFILE_DOC_URL ">\n"
+  "# for a documentation of spec files.\n"
+  "\n";
+
+static const char help_copy_paste[] =
+  "# If you intend to use an existing device specs file as a starting point\n"
+  "# for a new device spec file, make sure you are copying from a specs\n"
+  "# file for a device from the same core architecture and SP width.\n"
+  "# See <" SPECFILE_USAGE_URL "> for a description\n"
+  "# of how to use such own spec files.\n";
+
+#if defined (WITH_AVRLIBC)
+static const char help_dev_lib_name[] =
+  "# AVR-LibC's avr/io.h uses the device specifying macro to determine\n"
+  "# the name of the device header.  For example, -mmcu=atmega8a triggers\n"
+  "# the definition of __AVR_ATmega8A__ and avr/io.h includes the device\n"
+  "# header 'iom8a.h' by means of:\n"
+  "#\n"
+  "#     ...\n"
+  "#     #elif defined (__AVR_ATmega8A__)\n"
+  "#     #  include <avr/iom8a.h>\n"
+  "#     #elif ...\n"
+  "# \n"
+  "# If no device macro is defined, AVR-LibC uses __AVR_DEV_LIB_NAME__\n"
+  "# as fallback to determine the name of the device header as\n"
+  "#\n"
+  "#     \"avr/io\" + __AVR_DEV_LIB_NAME__ + \".h\"\n"
+  "#\n"
+  "# If you provide your own specs file for a device not yet known to\n"
+  "# AVR-LibC, you can now define the hook macro __AVR_DEV_LIB_NAME__\n"
+  "# as needed so that\n"
+  "#\n"
+  "#     #include <avr/io.h>\n"
+  "#\n"
+  "# will include the desired device header.  For ATmega8A the supplement\n"
+  "# to *cpp would read\n"
+  "#\n"
+  "#     -D__AVR_DEV_LIB_NAME__=m8a\n"
+  "\n";
+#endif // WITH_AVRLIBC
+
+static const avr_mcu_t *
+get_arch_for_mcu (const avr_mcu_t *mcu)
+{
+  const avr_mcu_t *current_mcu = avr_mcu_types;
+  for (; current_mcu->name; current_mcu++)
+    {
+      if (current_mcu->macro == NULL && current_mcu->arch_id == mcu->arch_id)
+        return current_mcu;
+    }
+
+  return NULL;
+}
+
+static void
+print_mcu (const avr_mcu_t *mcu)
+{
+  const char *sp8_spec;
+  const avr_mcu_t *arch_mcu;
+  const avr_arch_t *arch;
+  enum avr_arch_id arch_id = mcu->arch_id;
+
+  arch_mcu = get_arch_for_mcu (mcu);
+  if (!arch_mcu)
+    exit (EXIT_FAILURE);
+
+  arch = &avr_arch_types[arch_id];
+
+  char name[100];
+  if (snprintf (name, sizeof name, "specs-%s", mcu->name) >= (int) sizeof name)
+   exit (EXIT_FAILURE);
+
+  FILE *f = fopen (name ,"w");
+
+  bool errata_skip = 0 != (mcu->dev_attribute & AVR_ERRATA_SKIP);
+  bool rmw = 0 != (mcu->dev_attribute & AVR_ISA_RMW);
+  bool sp8 = 0 != (mcu->dev_attribute & AVR_SHORT_SP);
+  bool is_arch = NULL == mcu->macro;
+  bool is_device = ! is_arch;
+
+  if (is_arch
+      && (ARCH_AVR2 == arch_id
+          || ARCH_AVR25 == arch_id))
+    {
+      // Leave "avr2" and "avr25" alone.  These two architectures are
+      // the only ones that mix devices with 8-bit SP and 16-bit SP.
+      sp8_spec = "";
+    }
+  else
+    {
+      sp8_spec = sp8 ? "-msp8" :"%<msp8";
+    }
+
+  fprintf (f, "#\n"
+           "# Auto-generated specs for AVR ");
+  if (is_arch)
+    fprintf (f, "core architecture %s\n", arch->name);
+  else
+    fprintf (f, "device %s (core %s, %d-bit SP)\n",
+             mcu->name, arch->name, sp8 ? 8 : 16);
+  fprintf (f, "%s\n", header);
+
+  if (is_device)
+    fprintf (f, "%s\n", help_copy_paste);
+
+#if defined (WITH_AVRLIBC)
+  // AVR-LibC specific.  See avrlibc.h for the specs using them as subspecs.
+
+  if (is_device)
+    {
+      fprintf (f, "*avrlibc_startfile:\n");
+      fprintf (f, "\tcrt%s.o%%s", mcu->name);
+      fprintf (f, "\n\n");
+
+      fprintf (f, "*avrlibc_devicelib:\n");
+      fprintf (f, "\t%%{!nodevicelib:-l%s}", mcu->name);
+      fprintf (f, "\n\n");
+    }
+#endif  // WITH_AVRLIBC
+
+  // avr-gcc specific specs for the compilation / the compiler proper.
+
+  fprintf (f, "*cc1_n_flash:\n"
+           "\t%%{!mn-flash=*:-mn-flash=%d}\n\n", mcu->n_flash);
+
+  fprintf (f, "*cc1_rmw:\n%s\n\n", rmw
+           ? "\t%{!mno-rmw: -mrmw}"
+           : "\t%{mrmw}");
+
+  fprintf (f, "*cc1_errata_skip:\n%s\n\n", errata_skip
+           ? "\t%{!mno-skip-bug: -mskip-bug}"
+           : "\t%{!mskip-bug: -mno-skip-bug}");
+
+  // avr-gcc specific specs for assembling / the assembler.
+
+  fprintf (f, "*asm_arch:\n\t-mmcu=%s\n\n", arch->name);
+
+#ifdef HAVE_AS_AVR_MLINK_RELAX_OPTION
+  fprintf (f, "*asm_relax:\n\t%s\n\n", ASM_RELAX_SPEC);
+#endif // have avr-as --mlink-relax
+
+#ifdef HAVE_AS_AVR_MRMW_OPTION
+  fprintf (f, "*asm_rmw:\n%s\n\n", rmw
+           ? "\t%{!mno-rmw: -mrmw}"
+           : "\t%{mrmw}");
+#endif // have avr-as -mrmw
+
+  fprintf (f, "*asm_errata_skip:\n%s\n\n", errata_skip
+           ? "\t%{mno-skip-bug}"
+           : "\t%{!mskip-bug: -mno-skip-bug}");
+
+  // avr-specific specs for linking / the linker.
+
+  int wrap_k =
+    str_prefix_p (mcu->name, "at90usb8") ? 8
+    : str_prefix_p (mcu->name, "atmega16") ? 16
+    : (str_prefix_p (mcu->name, "atmega32")
+       || str_prefix_p (mcu->name, "at90can32")) ? 32
+    : (str_prefix_p (mcu->name, "atmega64")
+       || str_prefix_p (mcu->name, "at90can64")
+       || str_prefix_p (mcu->name, "at90usb64")) ? 64
+    : 0;
+
+  fprintf (f, "*link_pmem_wrap:\n");
+  if (wrap_k)
+    fprintf (f, "\t%%{mpmem-wrap-around: --pmem-wrap-around=%dk}", wrap_k);
+  fprintf (f, "\n\n");
+
+  fprintf (f, "*link_relax:\n\t%s\n\n", LINK_RELAX_SPEC);
+
+  fprintf (f, "*link_arch:\n\t%s\n\n", LINK_ARCH_SPEC);
+
+  if (is_device)
+    {
+      fprintf (f, "*link_data_start:\n");
+      if (mcu->data_section_start
+          != arch->default_data_section_start)
+        fprintf (f, "\t-Tdata 0x%lX", 0x800000UL + mcu->data_section_start);
+      fprintf (f, "\n\n");
+
+      fprintf (f, "*link_text_start:\n");
+      if (mcu->text_section_start != 0x0)
+        fprintf (f, "\t-Ttext 0x%lX", 0UL + mcu->text_section_start);
+      fprintf (f, "\n\n");
+    }
+
+  // Specs known to GCC.
+
+  if (is_device)
+    {
+      fprintf (f, "*self_spec:\n");
+      fprintf (f, "\t%%{!mmcu=avr*: %%<mmcu=* -mmcu=%s} ", arch->name);
+      fprintf (f, "%s\n\n", sp8_spec);
+
+#if defined (WITH_AVRLIBC)
+      fprintf (f, "%s\n", help_dev_lib_name);
+#endif // WITH_AVRLIBC
+
+      fprintf (f, "*cpp:\n");
+      fprintf (f, "\t-D%s -D__AVR_DEVICE_NAME__=%s", mcu->macro, mcu->name);
+      fprintf (f, "\n\n");
+    }
+
+  fprintf (f, "# End of file\n");
+
+  fclose (f);
+}
+
+
+int main (void)
+{
+  for (const avr_mcu_t *mcu = avr_mcu_types; mcu->name; mcu++)
+    print_mcu (mcu);
+
+  return EXIT_SUCCESS;
+}
diff --git a/gcc/config/avr/gen-avr-mmcu-texi.c b/gcc/config/avr/gen-avr-mmcu-texi.c
index ea3e6f1..f5fddfc 100644
--- a/gcc/config/avr/gen-avr-mmcu-texi.c
+++ b/gcc/config/avr/gen-avr-mmcu-texi.c
@@ -22,7 +22,6 @@
 
 #define IN_GEN_AVR_MMCU_TEXI
 
-#include "avr-arch.h"
 #include "avr-devices.c"
 
 static const char*
@@ -97,7 +96,7 @@ print_mcus (size_t n_mcus)
 
 int main (void)
 {
-  enum avr_arch arch = ARCH_UNKNOWN;
+  enum avr_arch_id arch_id = ARCH_UNKNOWN;
   size_t i, n_mcus = 0;
   const avr_mcu_t *mcu;
 
@@ -120,7 +119,7 @@ int main (void)
     {
       if (mcu->macro == NULL)
         {
-          arch = mcu->arch;
+          arch_id = mcu->arch_id;
 
           /* Start a new architecture:  Flush the MCUs collected so far.  */
 
@@ -128,10 +127,10 @@ int main (void)
           n_mcus = 0;
 
           for (i = 0; i < sizeof (avr_texinfo) / sizeof (*avr_texinfo); i++)
-            if (arch == avr_texinfo[i].arch)
+            if (arch_id == avr_texinfo[i].arch_id)
               printf ("@item %s\n%s\n", mcu->name, avr_texinfo[i].texinfo);
         }
-      else if (arch == (enum avr_arch) mcu->arch)
+      else if (arch_id == (enum avr_arch_id) mcu->arch_id)
         {
           mcu_name[n_mcus++] = mcu->name;
         }
diff --git a/gcc/config/avr/genmultilib.awk b/gcc/config/avr/genmultilib.awk
index 1dfeabb..a75572b 100644
--- a/gcc/config/avr/genmultilib.awk
+++ b/gcc/config/avr/genmultilib.awk
@@ -135,7 +135,6 @@ BEGIN {
 #    m_options     <->    MULTILIB_OPTIONS         Makefile
 #    m_dirnames    <->    MULTILIB_DIRNAMES           "
 #    m_exceptions  <->    MULTILIB_EXCEPTIONS         "
-#    m_matches     <->    MULTILIB_MATCHES            "
 #
 ##################################################################
 
@@ -143,7 +142,6 @@ END {
     m_options    = "\nMULTILIB_OPTIONS = "
     m_dirnames   = "\nMULTILIB_DIRNAMES ="
     m_exceptions = "\nMULTILIB_EXCEPTIONS ="
-    m_matches    = "\nMULTILIB_MATCHES ="
 
     ##############################################################
     # Compose MULTILIB_OPTIONS.  This represents the Cross-Product
@@ -169,8 +167,6 @@ END {
 	line = option[core] ":" option[mcu[t]]
 	gsub ("=", "?", line)
 	gsub (":", "=", line)
-
-	m_matches = m_matches " \\\n\t" line
     }
 
     ####################################################################
@@ -221,6 +217,5 @@ END {
 	print m_options
 	print m_dirnames
 	print m_exceptions
-	print m_matches
     }
 }
diff --git a/gcc/config/avr/predicates.md b/gcc/config/avr/predicates.md
index 85612e1..c027ad4 100644
--- a/gcc/config/avr/predicates.md
+++ b/gcc/config/avr/predicates.md
@@ -43,22 +43,26 @@
        (match_test "REGNO (op) == REG_SP")))
 
 ;; Return true if OP is a valid address for lower half of I/O space.
-(define_predicate "low_io_address_operand"
-  (and (match_code "const_int")
-       (match_test "IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,
-                              0, 0x1f)")))
+(define_special_predicate "low_io_address_operand"
+  (ior (and (match_code "const_int")
+	    (match_test "IN_RANGE (INTVAL (op) - avr_arch->sfr_offset,
+				   0, 0x20 - GET_MODE_SIZE (mode))"))
+       (and (match_code "symbol_ref")
+	    (match_test "SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_IO_LOW"))))
 
 ;; Return true if OP is a valid address for high half of I/O space.
 (define_predicate "high_io_address_operand"
   (and (match_code "const_int")
-       (match_test "IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,
+       (match_test "IN_RANGE (INTVAL (op) - avr_arch->sfr_offset,
                               0x20, 0x3F)")))
 
 ;; Return true if OP is a valid address of I/O space.
-(define_predicate "io_address_operand"
-  (and (match_code "const_int")
-       (match_test "IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,
-                              0, 0x40 - GET_MODE_SIZE (mode))")))
+(define_special_predicate "io_address_operand"
+  (ior (and (match_code "const_int")
+	    (match_test "IN_RANGE (INTVAL (op) - avr_arch->sfr_offset,
+				   0, 0x40 - GET_MODE_SIZE (mode))"))
+       (and (match_code "symbol_ref")
+	    (match_test "SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_IO"))))
 
 ;; Return 1 if OP is a general operand not in flash memory
 (define_predicate "nop_general_operand"
diff --git a/gcc/config/avr/specs.h b/gcc/config/avr/specs.h
new file mode 100644
index 0000000..e685ca2
--- /dev/null
+++ b/gcc/config/avr/specs.h
@@ -0,0 +1,77 @@
+/* Specs definitions for Atmel AVR back end.
+
+   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+   Contributed by Georg-Johann Lay (avr@gjlay.de)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* Default specs layout.  The actual definitions might be superseeded
+   by device- or OS- specific files, like avrlibc.h, ../rtems.h, etc.
+   The specs are repeated in the device specs files.  Subspecs are
+   specs known to GCC or specs defined in the device specs files.  */
+
+
+#undef  CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC                      \
+  "%(cpp)"
+
+#undef  CC1_SPEC
+#define CC1_SPEC                                \
+  "%(cc1_n_flash) "                             \
+  "%(cc1_errata_skip) "                         \
+  "%(cc1_rmw) "
+
+#undef  CC1PLUS_SPEC
+#define CC1PLUS_SPEC                                    \
+  "%(cc1) "                                             \
+  "%{!frtti:-fno-rtti} "                                \
+  "%{!fenforce-eh-specs:-fno-enforce-eh-specs} "        \
+  "%{!fexceptions:-fno-exceptions} "
+
+#define ASM_RELAX_SPEC                          \
+  "%{mrelax:--mlink-relax} "
+
+#undef  ASM_SPEC
+#define ASM_SPEC                                \
+  "%(asm_arch) "                                \
+  "%(asm_relax) "                               \
+  "%(asm_rmw) "                                 \
+  "%(asm_errata_skip) "
+
+#define LINK_ARCH_SPEC                          \
+  "%{mmcu=*:-m%*} "
+
+#define LINK_RELAX_SPEC                         \
+  "%{mrelax:--relax %(link_pmem_wrap)} "
+
+#undef  LINK_SPEC
+#define LINK_SPEC                               \
+  "%(link_arch) "                               \
+  "%(link_data_start) "                         \
+  "%(link_text_start) "                         \
+  "%(link_relax) "                              \
+  "%{shared:%eshared is not supported} "
+
+#undef  LIB_SPEC
+#define LIB_SPEC " %{!mmcu=avr1:-lc} "
+
+#undef  LIBGCC_SPEC
+#define LIBGCC_SPEC " %{!mmcu=avr1:-lgcc} "
+
+#define STARTFILE_SPEC ""
+#define ENDFILE_SPEC ""
diff --git a/gcc/config/avr/stdfix.h b/gcc/config/avr/stdfix.h
index 38d80e4..e985c9f 100644
--- a/gcc/config/avr/stdfix.h
+++ b/gcc/config/avr/stdfix.h
@@ -233,4 +233,13 @@ typedef long long unsigned int uint_uk_t;
 #define roundfx   __builtin_avr_roundfx
 #define countlsfx __builtin_avr_countlsfx
 
+
+/* Hook in stuff from AVR-Libc.  */
+
+#if (defined (__WITH_AVRLIBC__)                 \
+     && defined (__has_include)                 \
+     && __has_include (<stdfix-avrlibc.h>))
+#include <stdfix-avrlibc.h>
+#endif
+
 #endif /* _AVRGCC_STDFIX_H */
diff --git a/gcc/config/avr/t-avr b/gcc/config/avr/t-avr
index 75120ef..361ac7d 100644
--- a/gcc/config/avr/t-avr
+++ b/gcc/config/avr/t-avr
@@ -17,11 +17,13 @@
 # <http://www.gnu.org/licenses/>.
 
 driver-avr.o: $(srcdir)/config/avr/driver-avr.c \
-  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
+  $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(srcdir)/config/avr/avr-arch.h $(TM_H)
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
 
 avr-devices.o: $(srcdir)/config/avr/avr-devices.c \
   $(srcdir)/config/avr/avr-mcus.def \
+  $(srcdir)/config/avr/avr-arch.h \
   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
 
@@ -53,23 +55,38 @@ AVR_MCUS = $(srcdir)/config/avr/avr-mcus.def
 .PHONY: avr-mcus
 
 avr-mcus: $(srcdir)/config/avr/t-multilib \
-	  $(srcdir)/config/avr/avr-tables.opt \
 	  $(srcdir)/doc/avr-mmcu.texi ; @true
 
-# Make sure that -mmcu= is supported for devices from avr-mcus.def and
-# all -mmcu= values are displayed on the help screen
-$(srcdir)/config/avr/avr-tables.opt: $(srcdir)/config/avr/genopt.sh $(AVR_MCUS)
-	$(SHELL) $< $(AVR_MCUS) > $@
-
-# Make sure that -mmcu= support is in sync with -mmcu= documentation.
+# Make sure that native -mmcu= support is in sync with -mmcu= documentation.
 gen-avr-mmcu-texi$(build_exeext): $(srcdir)/config/avr/gen-avr-mmcu-texi.c \
   $(AVR_MCUS) $(srcdir)/config/avr/avr-devices.c \
   $(srcdir)/config/avr/avr-arch.h
 	$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $< -o $@
 
+gen-avr-mmcu-specs$(build_exeext): $(srcdir)/config/avr/gen-avr-mmcu-specs.c \
+  $(AVR_MCUS) $(srcdir)/config/avr/avr-devices.c \
+  $(srcdir)/config/avr/avr-arch.h $(TM_H)
+	$(CXX_FOR_BUILD) $(CXXFLAGS_FOR_BUILD) $< -o $@ $(INCLUDES)
+
 $(srcdir)/doc/avr-mmcu.texi: gen-avr-mmcu-texi$(build_exeext)
 	$(RUN_GEN) ./$< > $@
 
+s-device-specs: gen-avr-mmcu-specs$(build_exeext)
+	rm -rf device-specs
+	mkdir device-specs && cd device-specs && $(RUN_GEN) ../$<
+	$(STAMP) s-device-specs
+
+GCC_PASSES+=s-device-specs
+
+install-driver: install-device-specs
+
+install-device-specs: s-device-specs installdirs
+	-rm -rf $(DESTDIR)$(libsubdir)/device-specs
+	mkdir $(DESTDIR)$(libsubdir)/device-specs
+	-for file in device-specs/*; do \
+		$(INSTALL_DATA) $${file} $(DESTDIR)$(libsubdir)/$${file}; \
+	done
+
 # Map -mmcu= to the right multilib variant
 # MULTILIB_OPTIONS
 # MULTILIB_DIRNAMES
diff --git a/gcc/config/avr/t-multilib b/gcc/config/avr/t-multilib
index 301f864..ebe4605 100644
--- a/gcc/config/avr/t-multilib
+++ b/gcc/config/avr/t-multilib
@@ -21,9 +21,9 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7 msp8
+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7/mmcu=avrtiny msp8
 
-MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 tiny-stack avr25/tiny-stack
+MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack avr25/tiny-stack
 
 MULTILIB_EXCEPTIONS = \
 	mmcu=avr3/msp8 \
@@ -37,233 +37,5 @@ MULTILIB_EXCEPTIONS = \
 	mmcu=avrxmega4/msp8 \
 	mmcu=avrxmega5/msp8 \
 	mmcu=avrxmega6/msp8 \
-	mmcu=avrxmega7/msp8
-
-MULTILIB_MATCHES = \
-	mmcu?avr2=mmcu?at90s2313 \
-	mmcu?avr2=mmcu?at90s2323 \
-	mmcu?avr2=mmcu?at90s2333 \
-	mmcu?avr2=mmcu?at90s2343 \
-	mmcu?avr2=mmcu?attiny22 \
-	mmcu?avr2=mmcu?attiny26 \
-	mmcu?avr2=mmcu?at90s4414 \
-	mmcu?avr2=mmcu?at90s4433 \
-	mmcu?avr2=mmcu?at90s4434 \
-	mmcu?avr2=mmcu?at90s8515 \
-	mmcu?avr2=mmcu?at90c8534 \
-	mmcu?avr2=mmcu?at90s8535 \
-	mmcu?avr25=mmcu?ata6289 \
-	mmcu?avr25=mmcu?ata5272 \
-	mmcu?avr25=mmcu?attiny13 \
-	mmcu?avr25=mmcu?attiny13a \
-	mmcu?avr25=mmcu?attiny2313 \
-	mmcu?avr25=mmcu?attiny2313a \
-	mmcu?avr25=mmcu?attiny24 \
-	mmcu?avr25=mmcu?attiny24a \
-	mmcu?avr25=mmcu?attiny4313 \
-	mmcu?avr25=mmcu?attiny44 \
-	mmcu?avr25=mmcu?attiny44a \
-	mmcu?avr25=mmcu?attiny84 \
-	mmcu?avr25=mmcu?attiny84a \
-	mmcu?avr25=mmcu?attiny25 \
-	mmcu?avr25=mmcu?attiny45 \
-	mmcu?avr25=mmcu?attiny85 \
-	mmcu?avr25=mmcu?attiny261 \
-	mmcu?avr25=mmcu?attiny261a \
-	mmcu?avr25=mmcu?attiny461 \
-	mmcu?avr25=mmcu?attiny461a \
-	mmcu?avr25=mmcu?attiny861 \
-	mmcu?avr25=mmcu?attiny861a \
-	mmcu?avr25=mmcu?attiny43u \
-	mmcu?avr25=mmcu?attiny87 \
-	mmcu?avr25=mmcu?attiny48 \
-	mmcu?avr25=mmcu?attiny88 \
-	mmcu?avr25=mmcu?at86rf401 \
-	mmcu?avr3=mmcu?at43usb355 \
-	mmcu?avr3=mmcu?at76c711 \
-	mmcu?avr31=mmcu?atmega103 \
-	mmcu?avr31=mmcu?at43usb320 \
-	mmcu?avr35=mmcu?ata5505 \
-	mmcu?avr35=mmcu?at90usb82 \
-	mmcu?avr35=mmcu?at90usb162 \
-	mmcu?avr35=mmcu?atmega8u2 \
-	mmcu?avr35=mmcu?atmega16u2 \
-	mmcu?avr35=mmcu?atmega32u2 \
-	mmcu?avr35=mmcu?attiny167 \
-	mmcu?avr35=mmcu?attiny1634 \
-	mmcu?avr4=mmcu?ata6285 \
-	mmcu?avr4=mmcu?ata6286 \
-	mmcu?avr4=mmcu?atmega8 \
-	mmcu?avr4=mmcu?atmega8a \
-	mmcu?avr4=mmcu?atmega48 \
-	mmcu?avr4=mmcu?atmega48a \
-	mmcu?avr4=mmcu?atmega48p \
-	mmcu?avr4=mmcu?atmega48pa \
-	mmcu?avr4=mmcu?atmega88 \
-	mmcu?avr4=mmcu?atmega88a \
-	mmcu?avr4=mmcu?atmega88p \
-	mmcu?avr4=mmcu?atmega88pa \
-	mmcu?avr4=mmcu?atmega8515 \
-	mmcu?avr4=mmcu?atmega8535 \
-	mmcu?avr4=mmcu?atmega8hva \
-	mmcu?avr4=mmcu?at90pwm1 \
-	mmcu?avr4=mmcu?at90pwm2 \
-	mmcu?avr4=mmcu?at90pwm2b \
-	mmcu?avr4=mmcu?at90pwm3 \
-	mmcu?avr4=mmcu?at90pwm3b \
-	mmcu?avr4=mmcu?at90pwm81 \
-	mmcu?avr5=mmcu?ata5790 \
-	mmcu?avr5=mmcu?ata5790n \
-	mmcu?avr5=mmcu?ata5795 \
-	mmcu?avr5=mmcu?atmega16 \
-	mmcu?avr5=mmcu?atmega16a \
-	mmcu?avr5=mmcu?atmega161 \
-	mmcu?avr5=mmcu?atmega162 \
-	mmcu?avr5=mmcu?atmega163 \
-	mmcu?avr5=mmcu?atmega164a \
-	mmcu?avr5=mmcu?atmega164p \
-	mmcu?avr5=mmcu?atmega164pa \
-	mmcu?avr5=mmcu?atmega165 \
-	mmcu?avr5=mmcu?atmega165a \
-	mmcu?avr5=mmcu?atmega165p \
-	mmcu?avr5=mmcu?atmega165pa \
-	mmcu?avr5=mmcu?atmega168 \
-	mmcu?avr5=mmcu?atmega168a \
-	mmcu?avr5=mmcu?atmega168p \
-	mmcu?avr5=mmcu?atmega168pa \
-	mmcu?avr5=mmcu?atmega169 \
-	mmcu?avr5=mmcu?atmega169a \
-	mmcu?avr5=mmcu?atmega169p \
-	mmcu?avr5=mmcu?atmega169pa \
-	mmcu?avr5=mmcu?atmega16hvb \
-	mmcu?avr5=mmcu?atmega16hvbrevb \
-	mmcu?avr5=mmcu?atmega16m1 \
-	mmcu?avr5=mmcu?atmega16u4 \
-	mmcu?avr5=mmcu?atmega26hvg \
-	mmcu?avr5=mmcu?atmega32a \
-	mmcu?avr5=mmcu?atmega32 \
-	mmcu?avr5=mmcu?atmega323 \
-	mmcu?avr5=mmcu?atmega324a \
-	mmcu?avr5=mmcu?atmega324p \
-	mmcu?avr5=mmcu?atmega324pa \
-	mmcu?avr5=mmcu?atmega325 \
-	mmcu?avr5=mmcu?atmega325a \
-	mmcu?avr5=mmcu?atmega325p \
-	mmcu?avr5=mmcu?atmega3250 \
-	mmcu?avr5=mmcu?atmega3250a \
-	mmcu?avr5=mmcu?atmega3250p \
-	mmcu?avr5=mmcu?atmega3250pa \
-	mmcu?avr5=mmcu?atmega328 \
-	mmcu?avr5=mmcu?atmega328p \
-	mmcu?avr5=mmcu?atmega329 \
-	mmcu?avr5=mmcu?atmega329a \
-	mmcu?avr5=mmcu?atmega329p \
-	mmcu?avr5=mmcu?atmega329pa \
-	mmcu?avr5=mmcu?atmega3290 \
-	mmcu?avr5=mmcu?atmega3290a \
-	mmcu?avr5=mmcu?atmega3290p \
-	mmcu?avr5=mmcu?atmega3290pa \
-	mmcu?avr5=mmcu?atmega32c1 \
-	mmcu?avr5=mmcu?atmega32m1 \
-	mmcu?avr5=mmcu?atmega32u4 \
-	mmcu?avr5=mmcu?atmega32u6 \
-	mmcu?avr5=mmcu?atmega406 \
-	mmcu?avr5=mmcu?atmega64 \
-	mmcu?avr5=mmcu?atmega64a \
-	mmcu?avr5=mmcu?atmega640 \
-	mmcu?avr5=mmcu?atmega644 \
-	mmcu?avr5=mmcu?atmega644a \
-	mmcu?avr5=mmcu?atmega644p \
-	mmcu?avr5=mmcu?atmega644pa \
-	mmcu?avr5=mmcu?atmega645 \
-	mmcu?avr5=mmcu?atmega645a \
-	mmcu?avr5=mmcu?atmega645p \
-	mmcu?avr5=mmcu?atmega6450 \
-	mmcu?avr5=mmcu?atmega6450a \
-	mmcu?avr5=mmcu?atmega6450p \
-	mmcu?avr5=mmcu?atmega649 \
-	mmcu?avr5=mmcu?atmega649a \
-	mmcu?avr5=mmcu?atmega649p \
-	mmcu?avr5=mmcu?atmega6490 \
-	mmcu?avr5=mmcu?atmega16hva \
-	mmcu?avr5=mmcu?atmega16hva2 \
-	mmcu?avr5=mmcu?atmega32hvb \
-	mmcu?avr5=mmcu?atmega6490a \
-	mmcu?avr5=mmcu?atmega6490p \
-	mmcu?avr5=mmcu?atmega64c1 \
-	mmcu?avr5=mmcu?atmega64m1 \
-	mmcu?avr5=mmcu?atmega64hve \
-	mmcu?avr5=mmcu?atmega64rfa2 \
-	mmcu?avr5=mmcu?atmega64rfr2 \
-	mmcu?avr5=mmcu?atmega32hvbrevb \
-	mmcu?avr5=mmcu?atmega48hvf \
-	mmcu?avr5=mmcu?at90can32 \
-	mmcu?avr5=mmcu?at90can64 \
-	mmcu?avr5=mmcu?at90pwm161 \
-	mmcu?avr5=mmcu?at90pwm216 \
-	mmcu?avr5=mmcu?at90pwm316 \
-	mmcu?avr5=mmcu?at90scr100 \
-	mmcu?avr5=mmcu?at90usb646 \
-	mmcu?avr5=mmcu?at90usb647 \
-	mmcu?avr5=mmcu?at94k \
-	mmcu?avr5=mmcu?m3000 \
-	mmcu?avr51=mmcu?atmega128 \
-	mmcu?avr51=mmcu?atmega128a \
-	mmcu?avr51=mmcu?atmega1280 \
-	mmcu?avr51=mmcu?atmega1281 \
-	mmcu?avr51=mmcu?atmega1284 \
-	mmcu?avr51=mmcu?atmega1284p \
-	mmcu?avr51=mmcu?atmega128rfa1 \
-	mmcu?avr51=mmcu?at90can128 \
-	mmcu?avr51=mmcu?at90usb1286 \
-	mmcu?avr51=mmcu?at90usb1287 \
-	mmcu?avr6=mmcu?atmega2560 \
-	mmcu?avr6=mmcu?atmega2561 \
-	mmcu?avrxmega2=mmcu?atxmega16a4 \
-	mmcu?avrxmega2=mmcu?atxmega16d4 \
-	mmcu?avrxmega2=mmcu?atxmega32a4 \
-	mmcu?avrxmega2=mmcu?atxmega32d4 \
-	mmcu?avrxmega2=mmcu?atxmega32x1 \
-	mmcu?avrxmega2=mmcu?atmxt112sl \
-	mmcu?avrxmega2=mmcu?atmxt224 \
-	mmcu?avrxmega2=mmcu?atmxt224e \
-	mmcu?avrxmega2=mmcu?atmxt336s \
-	mmcu?avrxmega2=mmcu?atxmega16a4u \
-	mmcu?avrxmega2=mmcu?atxmega16c4 \
-	mmcu?avrxmega2=mmcu?atxmega32a4u \
-	mmcu?avrxmega2=mmcu?atxmega32c4 \
-	mmcu?avrxmega2=mmcu?atxmega32e5 \
-	mmcu?avrxmega4=mmcu?atxmega64a3 \
-	mmcu?avrxmega4=mmcu?atxmega64d3 \
-	mmcu?avrxmega4=mmcu?atxmega64a3u \
-	mmcu?avrxmega4=mmcu?atxmega64a4u \
-	mmcu?avrxmega4=mmcu?atxmega64b1 \
-	mmcu?avrxmega4=mmcu?atxmega64b3 \
-	mmcu?avrxmega4=mmcu?atxmega64c3 \
-	mmcu?avrxmega4=mmcu?atxmega64d4 \
-	mmcu?avrxmega5=mmcu?atxmega64a1 \
-	mmcu?avrxmega5=mmcu?atxmega64a1u \
-	mmcu?avrxmega6=mmcu?atxmega128a3 \
-	mmcu?avrxmega6=mmcu?atxmega128d3 \
-	mmcu?avrxmega6=mmcu?atxmega192a3 \
-	mmcu?avrxmega6=mmcu?atxmega192d3 \
-	mmcu?avrxmega6=mmcu?atxmega256a3 \
-	mmcu?avrxmega6=mmcu?atxmega256a3b \
-	mmcu?avrxmega6=mmcu?atxmega256a3bu \
-	mmcu?avrxmega6=mmcu?atxmega256d3 \
-	mmcu?avrxmega6=mmcu?atxmega128a3u \
-	mmcu?avrxmega6=mmcu?atxmega128b1 \
-	mmcu?avrxmega6=mmcu?atxmega128b3 \
-	mmcu?avrxmega6=mmcu?atxmega128c3 \
-	mmcu?avrxmega6=mmcu?atxmega128d4 \
-	mmcu?avrxmega6=mmcu?atmxt540s \
-	mmcu?avrxmega6=mmcu?atmxt540sreva \
-	mmcu?avrxmega6=mmcu?atxmega192a3u \
-	mmcu?avrxmega6=mmcu?atxmega192c3 \
-	mmcu?avrxmega6=mmcu?atxmega256a3u \
-	mmcu?avrxmega6=mmcu?atxmega256c3 \
-	mmcu?avrxmega6=mmcu?atxmega384c3 \
-	mmcu?avrxmega6=mmcu?atxmega384d3 \
-	mmcu?avrxmega7=mmcu?atxmega128a1 \
-	mmcu?avrxmega7=mmcu?atxmega128a1u \
-	mmcu?avrxmega7=mmcu?atxmega128a4u
+	mmcu=avrxmega7/msp8 \
+	mmcu=avrtiny/msp8
diff --git a/gcc/configure b/gcc/configure
index 291e463..4fda745 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -24121,6 +24121,70 @@ $as_echo "#define HAVE_AS_JSRDIRECT_RELOCS 1" >>confdefs.h
 fi
     ;;
 
+  avr-*-*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for --mlink-relax option" >&5
+$as_echo_n "checking assembler for --mlink-relax option... " >&6; }
+if test "${gcc_cv_as_avr_mlink_relax+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_avr_mlink_relax=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.text' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags --mlink-relax -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_avr_mlink_relax=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_avr_mlink_relax" >&5
+$as_echo "$gcc_cv_as_avr_mlink_relax" >&6; }
+if test $gcc_cv_as_avr_mlink_relax = yes; then
+
+$as_echo "#define HAVE_AS_AVR_MLINK_RELAX_OPTION 1" >>confdefs.h
+
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for -mrmw option" >&5
+$as_echo_n "checking assembler for -mrmw option... " >&6; }
+if test "${gcc_cv_as_avr_mrmw+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_avr_mrmw=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.text' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -mrmw -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_avr_mrmw=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_avr_mrmw" >&5
+$as_echo "$gcc_cv_as_avr_mrmw" >&6; }
+if test $gcc_cv_as_avr_mrmw = yes; then
+
+$as_echo "#define HAVE_AS_AVR_MRMW_OPTION 1" >>confdefs.h
+
+fi
+    ;;
+
   cris-*-*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for -no-mul-bug-abort option" >&5
 $as_echo_n "checking assembler for -no-mul-bug-abort option... " >&6; }
diff --git a/gcc/configure.ac b/gcc/configure.ac
index b9a3799..81a0c5c 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -3595,6 +3595,18 @@ AS_HELP_STRING([--disable-fix-cortex-a53-835769],
   [Define if your assembler supports the lituse_jsrdirect relocation.])])
     ;;
 
+  avr-*-*)
+    gcc_GAS_CHECK_FEATURE([--mlink-relax option], gcc_cv_as_avr_mlink_relax,,
+      [--mlink-relax], [.text],,
+      [AC_DEFINE(HAVE_AS_AVR_MLINK_RELAX_OPTION, 1,
+		[Define if your avr assembler supports --mlink-relax option.])])
+
+    gcc_GAS_CHECK_FEATURE([-mrmw option], gcc_cv_as_avr_mrmw,,
+      [-mrmw], [.text],,
+      [AC_DEFINE(HAVE_AS_AVR_MRMW_OPTION, 1,
+		[Define if your avr assembler supports -mrmw option.])])
+    ;;
+
   cris-*-*)
     gcc_GAS_CHECK_FEATURE([-no-mul-bug-abort option],
       gcc_cv_as_cris_no_mul_bug,[2,15,91],
diff --git a/gcc/doc/avr-mmcu.texi b/gcc/doc/avr-mmcu.texi
index 175407b..887a6a2 100644
--- a/gcc/doc/avr-mmcu.texi
+++ b/gcc/doc/avr-mmcu.texi
@@ -18,7 +18,7 @@
 
 @item avr25
 ``Classic'' devices with up to 8@tie{}KiB of program memory and with the @code{MOVW} instruction.
-@*@var{mcu}@tie{}= @code{ata5272}, @code{ata6289}, @code{attiny13}, @code{attiny13a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny43u}, @code{attiny4313}, @code{attiny44}, @code{attiny44a}, @code{attiny45}, @code{attiny461}, @code{attiny461a}, @code{attiny48}, @code{attiny84}, @code{attiny84a}, @code{attiny85}, @code{attiny861}, @code{attiny861a}, @code{attiny87}, @code{attiny88}, @code{at86rf401}.
+@*@var{mcu}@tie{}= @code{ata5272}, @code{ata6616c}, @code{attiny13}, @code{attiny13a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny43u}, @code{attiny4313}, @code{attiny44}, @code{attiny44a}, @code{attiny441}, @code{attiny45}, @code{attiny461}, @code{attiny461a}, @code{attiny48}, @code{attiny828}, @code{attiny84}, @code{attiny84a}, @code{attiny841}, @code{attiny85}, @code{attiny861}, @code{attiny861a}, @code{attiny87}, @code{attiny88}, @code{at86rf401}.
 
 @item avr3
 ``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of  program memory.
@@ -30,27 +30,27 @@
 
 @item avr35
 ``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory and with the @code{MOVW} instruction.
-@*@var{mcu}@tie{}= @code{ata5505}, @code{atmega16u2}, @code{atmega32u2}, @code{atmega8u2}, @code{attiny1634}, @code{attiny167}, @code{at90usb162}, @code{at90usb82}.
+@*@var{mcu}@tie{}= @code{ata5505}, @code{ata6617c}, @code{ata664251}, @code{atmega16u2}, @code{atmega32u2}, @code{atmega8u2}, @code{attiny1634}, @code{attiny167}, @code{at90usb162}, @code{at90usb82}.
 
 @item avr4
 ``Enhanced'' devices with up to 8@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{ata6285}, @code{ata6286}, @code{atmega48}, @code{atmega48a}, @code{atmega48p}, @code{atmega48pa}, @code{atmega8}, @code{atmega8a}, @code{atmega8hva}, @code{atmega8515}, @code{atmega8535}, @code{atmega88}, @code{atmega88a}, @code{atmega88p}, @code{atmega88pa}, @code{at90pwm1}, @code{at90pwm2}, @code{at90pwm2b}, @code{at90pwm3}, @code{at90pwm3b}, @code{at90pwm81}.
+@*@var{mcu}@tie{}= @code{ata6285}, @code{ata6286}, @code{ata6289}, @code{ata6612c}, @code{atmega48}, @code{atmega48a}, @code{atmega48p}, @code{atmega48pa}, @code{atmega48pb}, @code{atmega8}, @code{atmega8a}, @code{atmega8hva}, @code{atmega8515}, @code{atmega8535}, @code{atmega88}, @code{atmega88a}, @code{atmega88p}, @code{atmega88pa}, @code{atmega88pb}, @code{at90pwm1}, @code{at90pwm2}, @code{at90pwm2b}, @code{at90pwm3}, @code{at90pwm3b}, @code{at90pwm81}.
 
 @item avr5
 ``Enhanced'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{ata5790}, @code{ata5790n}, @code{ata5795}, @code{atmega16}, @code{atmega16a}, @code{atmega16hva}, @code{atmega16hva2}, @code{atmega16hvb}, @code{atmega16hvbrevb}, @code{atmega16m1}, @code{atmega16u4}, @code{atmega161}, @code{atmega162}, @code{atmega163}, @code{atmega164a}, @code{atmega164p}, @code{atmega164pa}, @code{atmega165}, @code{atmega165a}, @code{atmega165p}, @code{atmega165pa}, @code{atmega168}, @code{atmega168a}, @code{atmega168p}, @code{atmega168pa}, @code{atmega169}, @code{atmega169a}, @code{atmega169p}, @code{atmega169pa}, @code{atmega26hvg}, @code{atmega32}, @code{atmega32a}, @code{atmega32c1}, @code{atmega32hvb}, @code{atmega32hvbrevb}, @code{atmega32m1}, @code{atmega32u4}, @code{atmega32u6}, @code{atmega323}, @code{atmega324a}, @code{atmega324p}, @code{atmega324pa}, @code{atmega325}, @code{atmega325a}, @code{atmega325p}, @code{atmega3250}, @code{atmega3250a}, @code{atmega3250p}, @code{atmega3250pa}, @code{atmega328}, @code{atmega328p}, @code{atmega329}, @code{atmega329a}, @code{atmega329p}, @code{atmega329pa}, @code{atmega3290}, @code{atmega3290a}, @code{atmega3290p}, @code{atmega3290pa}, @code{atmega406}, @code{atmega48hvf}, @code{atmega64}, @code{atmega64a}, @code{atmega64c1}, @code{atmega64hve}, @code{atmega64m1}, @code{atmega64rfa2}, @code{atmega64rfr2}, @code{atmega640}, @code{atmega644}, @code{atmega644a}, @code{atmega644p}, @code{atmega644pa}, @code{atmega645}, @code{atmega645a}, @code{atmega645p}, @code{atmega6450}, @code{atmega6450a}, @code{atmega6450p}, @code{atmega649}, @code{atmega649a}, @code{atmega649p}, @code{atmega6490}, @code{atmega6490a}, @code{atmega6490p}, @code{at90can32}, @code{at90can64}, @code{at90pwm161}, @code{at90pwm216}, @code{at90pwm316}, @code{at90scr100}, @code{at90usb646}, @code{at90usb647}, @code{at94k}, @code{m3000}.
+@*@var{mcu}@tie{}= @code{ata5702m322}, @code{ata5782}, @code{ata5790}, @code{ata5790n}, @code{ata5791}, @code{ata5795}, @code{ata5831}, @code{ata6613c}, @code{ata6614q}, @code{ata8210}, @code{ata8510}, @code{atmega16}, @code{atmega16a}, @code{atmega16hva}, @code{atmega16hva2}, @code{atmega16hvb}, @code{atmega16hvbrevb}, @code{atmega16m1}, @code{atmega16u4}, @code{atmega161}, @code{atmega162}, @code{atmega163}, @code{atmega164a}, @code{atmega164p}, @code{atmega164pa}, @code{atmega165}, @code{atmega165a}, @code{atmega165p}, @code{atmega165pa}, @code{atmega168}, @code{atmega168a}, @code{atmega168p}, @code{atmega168pa}, @code{atmega168pb}, @code{atmega169}, @code{atmega169a}, @code{atmega169p}, @code{atmega169pa}, @code{atmega32}, @code{atmega32a}, @code{atmega32c1}, @code{atmega32hvb}, @code{atmega32hvbrevb}, @code{atmega32m1}, @code{atmega32u4}, @code{atmega32u6}, @code{atmega323}, @code{atmega324a}, @code{atmega324p}, @code{atmega324pa}, @code{atmega325}, @code{atmega325a}, @code{atmega325p}, @code{atmega325pa}, @code{atmega3250}, @code{atmega3250a}, @code{atmega3250p}, @code{atmega3250pa}, @code{atmega328}, @code{atmega328p}, @code{atmega329}, @code{atmega329a}, @code{atmega329p}, @code{atmega329pa}, @code{atmega3290}, @code{atmega3290a}, @code{atmega3290p}, @code{atmega3290pa}, @code{atmega406}, @code{atmega64}, @code{atmega64a}, @code{atmega64c1}, @code{atmega64hve}, @code{atmega64hve2}, @code{atmega64m1}, @code{atmega64rfr2}, @code{atmega640}, @code{atmega644}, @code{atmega644a}, @code{atmega644p}, @code{atmega644pa}, @code{atmega644rfr2}, @code{atmega645}, @code{atmega645a}, @code{atmega645p}, @code{atmega6450}, @code{atmega6450a}, @code{atmega6450p}, @code{atmega649}, @code{atmega649a}, @code{atmega649p}, @code{atmega6490}, @code{atmega6490a}, @code{atmega6490p}, @code{at90can32}, @code{at90can64}, @code{at90pwm161}, @code{at90pwm216}, @code{at90pwm316}, @code{at90scr100}, @code{at90usb646}, @code{at90usb647}, @code{at94k}, @code{m3000}.
 
 @item avr51
 ``Enhanced'' devices with 128@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmega128}, @code{atmega128a}, @code{atmega128rfa1}, @code{atmega1280}, @code{atmega1281}, @code{atmega1284}, @code{atmega1284p}, @code{at90can128}, @code{at90usb1286}, @code{at90usb1287}.
+@*@var{mcu}@tie{}= @code{atmega128}, @code{atmega128a}, @code{atmega128rfa1}, @code{atmega128rfr2}, @code{atmega1280}, @code{atmega1281}, @code{atmega1284}, @code{atmega1284p}, @code{atmega1284rfr2}, @code{at90can128}, @code{at90usb1286}, @code{at90usb1287}.
 
 @item avr6
 ``Enhanced'' devices with 3-byte PC, i.e.@: with more than 128@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmega2560}, @code{atmega2561}.
+@*@var{mcu}@tie{}= @code{atmega256rfr2}, @code{atmega2560}, @code{atmega2561}, @code{atmega2564rfr2}.
 
 @item avrxmega2
 ``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmxt112sl}, @code{atmxt224}, @code{atmxt224e}, @code{atmxt336s}, @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c4}, @code{atxmega32d4}, @code{atxmega32e5}, @code{atxmega32x1}.
+@*@var{mcu}@tie{}= @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega16e5}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c3}, @code{atxmega32c4}, @code{atxmega32d3}, @code{atxmega32d4}, @code{atxmega32e5}, @code{atxmega8e5}.
 
 @item avrxmega4
 ``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB of program memory.
@@ -62,12 +62,16 @@
 
 @item avrxmega6
 ``XMEGA'' devices with more than 128@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmxt540s}, @code{atmxt540sreva}, @code{atxmega128a3}, @code{atxmega128a3u}, @code{atxmega128b1}, @code{atxmega128b3}, @code{atxmega128c3}, @code{atxmega128d3}, @code{atxmega128d4}, @code{atxmega192a3}, @code{atxmega192a3u}, @code{atxmega192c3}, @code{atxmega192d3}, @code{atxmega256a3}, @code{atxmega256a3b}, @code{atxmega256a3bu}, @code{atxmega256a3u}, @code{atxmega256c3}, @code{atxmega256d3}, @code{atxmega384c3}, @code{atxmega384d3}.
+@*@var{mcu}@tie{}= @code{atxmega128a3}, @code{atxmega128a3u}, @code{atxmega128b1}, @code{atxmega128b3}, @code{atxmega128c3}, @code{atxmega128d3}, @code{atxmega128d4}, @code{atxmega192a3}, @code{atxmega192a3u}, @code{atxmega192c3}, @code{atxmega192d3}, @code{atxmega256a3}, @code{atxmega256a3b}, @code{atxmega256a3bu}, @code{atxmega256a3u}, @code{atxmega256c3}, @code{atxmega256d3}, @code{atxmega384c3}, @code{atxmega384d3}.
 
 @item avrxmega7
 ``XMEGA'' devices with more than 128@tie{}KiB of program memory and more than 64@tie{}KiB of RAM.
 @*@var{mcu}@tie{}= @code{atxmega128a1}, @code{atxmega128a1u}, @code{atxmega128a4u}.
 
+@item avrtiny
+``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of program memory.
+@*@var{mcu}@tie{}= @code{attiny10}, @code{attiny20}, @code{attiny4}, @code{attiny40}, @code{attiny5}, @code{attiny9}.
+
 @item avr1
 This ISA is implemented by the minimal AVR core and supported for assembler only.
 @*@var{mcu}@tie{}= @code{attiny11}, @code{attiny12}, @code{attiny15}, @code{attiny28}, @code{at90s1200}.
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 10ad6e4..0ac6991 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -5219,6 +5219,47 @@ normally resides in the data memory (RAM).
 
 See also the @ref{AVR Named Address Spaces} section for
 an alternate way to locate and access data in flash memory.
+
+@item io
+@itemx io (@var{addr})
+Variables with the @code{io} attribute are used to address
+memory-mapped peripherals in the io address range.
+If an address is specified, the variable
+is assigned that address, and the value is interpreted as an
+address in the data address space.
+Example:
+
+@smallexample
+volatile int porta __attribute__((io (0x22)));
+@end smallexample
+
+The address specified in the address in the data address range.
+
+Otherwise, the variable it is not assigned an address, but the
+compiler will still use in/out instructions where applicable,
+assuming some other module assigns an address in the io address range.
+Example:
+
+@smallexample
+extern volatile int porta __attribute__((io));
+@end smallexample
+
+@item io_low
+@itemx io_low (@var{addr})
+This is like the @code{io} attribute, but additionally it informs the
+compiler that the object lies in the lower half of the I/O area,
+allowing the use of @code{cbi}, @code{sbi}, @code{sbic} and @code{sbis}
+instructions.
+
+@item address
+@itemx address (@var{addr})
+Variables with the @code{address} attribute are used to address
+memory-mapped peripherals that may lie outside the io address range.
+
+@smallexample
+volatile int porta __attribute__((address (0x600)));
+@end smallexample
+
 @end table
 
 @subsection Blackfin Variable Attributes
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index bea8be2..b008679 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -539,8 +539,8 @@ Objective-C and Objective-C++ Dialects}.
 
 @emph{AVR Options}
 @gccoptlist{-mmcu=@var{mcu} -maccumulate-args -mbranch-cost=@var{cost} @gol
--mcall-prologues -mint8 -mno-interrupts -mrelax @gol
--mstrict-X -mtiny-stack -Waddr-space-convert}
+-mcall-prologues -mint8 -mn_flash=@var{size} -mno-interrupts @gol
+-mrelax -mrmw -mstrict-X -mtiny-stack -nodevicelib -Waddr-space-convert}
 
 @emph{Blackfin Options}
 @gccoptlist{-mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]} @gol
@@ -12654,6 +12654,11 @@ and @code{long long} is 4 bytes.  Please note that this option does not
 conform to the C standards, but it results in smaller code
 size.
 
+@item -mn-flash=@var{num}
+@opindex mn-flash
+Assume that the flash memory has a size of 
+@var{num} times 64@tie{}KiB.
+
 @item -mno-interrupts
 @opindex mno-interrupts
 Generated code is not compatible with hardware interrupts.
@@ -12663,8 +12668,9 @@ Code size is smaller.
 @opindex mrelax
 Try to replace @code{CALL} resp.@: @code{JMP} instruction by the shorter
 @code{RCALL} resp.@: @code{RJMP} instruction if applicable.
-Setting @code{-mrelax} just adds the @code{--relax} option to the
-linker command line when the linker is called.
+Setting @option{-mrelax} just adds the @option{--mlink-relax} option to
+the assembler's command line and the @option{--relax} option to the
+linker's command line.
 
 Jump relaxing is performed by the linker because jump offsets are not
 known before code is located. Therefore, the assembler code generated by the
@@ -12674,6 +12680,11 @@ differ from instructions in the assembler code.
 Relaxing must be turned on if linker stubs are needed, see the
 section on @code{EIND} and linker stubs below.
 
+@item -mrmw
+@opindex mrmw
+Assume that the device supports the Read-Modify-Write
+instructions @code{XCH}, @code{LAC}, @code{LAS} and @code{LAT}.
+
 @item -msp8
 @opindex msp8
 Treat the stack pointer register as an 8-bit register,
@@ -12712,6 +12723,10 @@ sbiw r26, const   ; X -= const
 @opindex mtiny-stack
 Only change the lower 8@tie{}bits of the stack pointer.
 
+@item -nodevicelib
+@opindex nodevicelib
+Don't link against AVR-LibC's device specific library @code{libdev.a}.
+
 @item -Waddr-space-convert
 @opindex Waddr-space-convert
 Warn about conversions between address spaces in the case where the
@@ -12914,13 +12929,18 @@ architecture and depends on the @code{-mmcu=@var{mcu}} option.
 Possible values are:
 
 @code{2}, @code{25}, @code{3}, @code{31}, @code{35},
-@code{4}, @code{5}, @code{51}, @code{6}, @code{102}, @code{104},
+@code{4}, @code{5}, @code{51}, @code{6}
+
+for @var{mcu}=@code{avr2}, @code{avr25}, @code{avr3}, @code{avr31},
+@code{avr35}, @code{avr4}, @code{avr5}, @code{avr51}, @code{avr6},
+
+respectively and
+
+@code{100}, @code{102}, @code{104},
 @code{105}, @code{106}, @code{107}
 
-for @var{mcu}=@code{avr2}, @code{avr25}, @code{avr3},
-@code{avr31}, @code{avr35}, @code{avr4}, @code{avr5}, @code{avr51},
-@code{avr6}, @code{avrxmega2}, @code{avrxmega4}, @code{avrxmega5},
-@code{avrxmega6}, @code{avrxmega7}, respectively.
+for @var{mcu}=@code{avrtiny}, @code{avrxmega2}, @code{avrxmega4},
+@code{avrxmega5}, @code{avrxmega6}, @code{avrxmega7}, respectively.
 If @var{mcu} specifies a device, this built-in macro is set
 accordingly. For example, with @code{-mmcu=atmega8} the macro will be
 defined to @code{4}.
@@ -12940,6 +12960,14 @@ the device name as from the AVR user manual. The difference between
 If @var{device} is not a device but only a core architecture like
 @code{avr51}, this macro will not be defined.
 
+@item __AVR_DEVICE_NAME__
+Setting @option{-mmcu=@var{device}} defines this built-in macro to
+the device's name. For example, with @option{-mmcu=atmega8} the macro
+is defined to @code{atmega8}.
+
+If @var{device} is not a device but only a core architecture like
+@code{avr51}, this macro will not be defined.
+
 @item __AVR_XMEGA__
 The device / architecture belongs to the XMEGA family of devices.
 
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index cac2f59..7aa3b1a 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,26 @@
+2015-03-11  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/65296
+	* gcc.target/avr/tiny-memx: Use -mmcu instead of -march.
+	* gcc.target/avr/tiny-caller-save.c: Same.
+
+2015-03-03  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/64331
+	* gcc.target/avr/torture/pr64331.c: New test.
+
+2015-02-20  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2015-02-20 trunk r220847.
+
+	PR target/64452
+	* gcc.target/avr/torture/pr64452.c: New test.
+
+2014-10-30  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR63633
+	* gcc.target/avr/torture/pr63633-ice-mult.c: New test.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
diff --git a/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c b/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
index 17afe73..623a088 100644
--- a/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
+++ b/gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
@@ -53,4 +53,4 @@ LIM5 (X);
 REFERENCE references[] = {
   LIM5 (X)
   0
-};
+}; /* { dg-error "size of array is too large" "" { target avr-*-* } } */
diff --git a/gcc/testsuite/gcc.target/avr/misspelled-handler-warning.c b/gcc/testsuite/gcc.target/avr/misspelled-handler-warning.c
new file mode 100644
index 0000000..51be22b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/misspelled-handler-warning.c
@@ -0,0 +1,13 @@
+/* Test warning emitted for functions with nmi attribute that do
+ * not start with __vector */
+/* { dg-do compile } */
+
+
+void __attribute__((interrupt)) interrupt_fun() /* { dg-warning "'interrupt_fun' appears to be a misspelled interrupt handler" } */
+{}
+
+void __attribute__((signal)) signal_fun() /* { dg-warning "'signal_fun' appears to be a misspelled signal handler" } */
+{}
+
+void __attribute__((nmi)) nmi_fun() /* { dg-warning "'nmi_fun' appears to be a misspelled nmi handler" } */
+{}
diff --git a/gcc/testsuite/gcc.target/avr/pr52472.c b/gcc/testsuite/gcc.target/avr/pr52472.c
new file mode 100644
index 0000000..701cfb4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/pr52472.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -g -Wno-pointer-to-int-cast" } */
+
+/* This testcase exposes PR52472. expand_debug_expr mistakenly
+   considers the address space of data to be generic, and
+   asserts that PSImode pointers aren't valid in the generic 
+   address space. */
+
+extern const __memx unsigned data[][10];
+
+unsigned long ice (void)
+{
+  unsigned long addr32;
+
+  return addr32 = ((unsigned long) data);
+}
diff --git a/gcc/testsuite/gcc.target/avr/pr65210.c b/gcc/testsuite/gcc.target/avr/pr65210.c
new file mode 100644
index 0000000..1aed441
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/pr65210.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+
+/* This testcase exposes PR65210. Usage of the io_low attribute
+   causes assertion failure because code only looks for the io
+   attribute if SYMBOL_FLAG_IO is set. */
+
+volatile char q __attribute__((io_low,address(0x81)));
diff --git a/gcc/testsuite/gcc.target/avr/pr65657.c b/gcc/testsuite/gcc.target/avr/pr65657.c
new file mode 100644
index 0000000..d908fe3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/pr65657.c
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-options "-Os" } */
+
+/* When cfgexpand expands the call to foo, it
+   assigns registers R22:R23 to 0xABCD and R24
+   to *x. Because x is a __memx address space
+   pointer, the dereference results in an RTL
+   insn that clobbers R22 among other 
+   registers (xload<mode>_A).
+
+   Call expansion does not take this into account
+   and ends up clobbering R22 set previously to 
+   hold part of the second argument.
+*/
+
+#include <stdlib.h>
+
+void __attribute__((noinline))
+    __attribute__((noclone))
+foo (char c, volatile unsigned int d)
+{
+    if (d != 0xABCD)
+      abort();
+    if (c != 'A')
+        abort();
+}
+
+void __attribute__((noinline))
+    __attribute__((noclone))
+readx(const char __memx *x)
+{
+    foo (*x, 0xABCD);
+}
+
+const char __memx arr[] = { 'A' };
+int main()
+{
+   readx (arr); 
+}
diff --git a/gcc/testsuite/gcc.target/avr/tiny-caller-save.c b/gcc/testsuite/gcc.target/avr/tiny-caller-save.c
new file mode 100644
index 0000000..63fad3a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/tiny-caller-save.c
@@ -0,0 +1,78 @@
+/* { dg-do compile } */
+/* { dg-options "-mmcu=avrtiny -gdwarf -Os" } */
+
+/* This is a stripped down piece of libgcc2.c that triggerd an ICE for avr with
+   "-mmcu=avrtiny -g -Os"; replace_reg_with_saved_mem would generate:
+   (concatn:SI [
+                    (reg:SI 18 r18)
+                    (reg:SI 19 r19)
+                    (mem/c:QI (plus:HI (reg/f:HI 28 r28)
+                            (const_int 43 [0x2b])) [6  S1 A8])
+                    (mem/c:QI (plus:HI (reg/f:HI 28 r28)
+                            (const_int 44 [0x2c])) [6  S1 A8])
+                ]) */
+
+typedef int SItype __attribute__ ((mode (SI)));
+typedef unsigned int USItype __attribute__ ((mode (SI)));
+typedef int DItype __attribute__ ((mode (DI)));
+typedef unsigned int UDItype __attribute__ ((mode (DI)));
+struct DWstruct
+{
+  SItype low, high;
+};
+typedef union
+{
+  struct DWstruct s;
+  DItype ll;
+} DWunion;
+
+UDItype
+__udivmoddi4 (UDItype n, UDItype d)
+{
+  const DWunion nn = {.ll = n };
+  const DWunion dd = {.ll = d };
+  USItype d0, d1, n2;
+  USItype q0;
+
+  d0 = dd.s.low;
+  d1 = dd.s.high;
+  n2 = nn.s.high;
+
+      USItype m0;
+
+      do
+	{
+	  USItype __d1, __d0, __q1, __q0;
+	  USItype __r1, __m;
+	  __d1 = ((USItype) (d1) >> 16);
+	  __d0 = ((USItype) (d1) & (((USItype) 1 << 16) - 1));
+	  __r1 = (n2) % __d1;
+	  __q1 = (n2) / __d1;
+	  __m = (USItype) __q1 *__d0;
+	  __r1 -= __m;
+	  __q0 = __r1 / __d1;
+	  (q0) = (USItype) __q1 *((USItype) 1 << 16) | __q0;
+	}
+      while (0);
+      do
+	{
+	  USItype __x0, __x1, __x2;
+	  USItype __ul, __vl, __uh, __vh;
+	  __ul = ((USItype) (q0) & (((USItype) 1 << 16) - 1));
+	  __uh = ((USItype) (q0) >> 16);
+	  __vl = ((USItype) (d0) & (((USItype) 1 << 16) - 1));
+	  __vh = ((USItype) (d0) >> 16);
+	  __x0 = (USItype) __ul *__vl;
+	  __x1 = (USItype) __ul *__vh;
+	  __x2 = (USItype) __uh *__vl;
+	  __x1 += ((USItype) (__x0) >> 16);
+	  __x1 += __x2;
+	  (m0) =
+	    ((USItype) (__x1) & (((USItype) 1 << 16) - 1)) *
+	    ((USItype) 1 << 16) +
+	    ((USItype) (__x0) & (((USItype) 1 << 16) - 1));
+	}
+      while (0);
+
+return m0;
+}
diff --git a/gcc/testsuite/gcc.target/avr/tiny-memx.c b/gcc/testsuite/gcc.target/avr/tiny-memx.c
new file mode 100644
index 0000000..cdda86b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/tiny-memx.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-mmcu=avrtiny" } */
+
+const __memx char ascmonth[] = "Jan"; /* { dg-error "not supported" } */
diff --git a/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c b/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c
new file mode 100644
index 0000000..a523424
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+
+void ice_mult32 (int x)
+{
+  register long reg __asm ("22");
+  __asm volatile (" " :: "r" (reg = 0x12345 * x));
+}
+
+void ice_mult24 (int x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = 0x12345 * x));
+}
+
+void ice_sh24 (__int24 x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = x << 3));
+}
+
+void ice_sh24b (__int24 x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = x << 22));
+}
+
+void ice_s16s16 (int x)
+{
+  register long reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = (long) x*x));
+}
+
+void ice_u16s16 (int x)
+{
+  register long reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = (long) x*0x1234u));
+}
diff --git a/gcc/testsuite/gcc.target/avr/torture/pr64331.c b/gcc/testsuite/gcc.target/avr/torture/pr64331.c
new file mode 100644
index 0000000..1934ccf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/torture/pr64331.c
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+
+typedef struct
+{
+  unsigned a, b;
+} T2;
+
+
+__attribute__((__noinline__, __noclone__))
+void foo2 (T2 *t, int x)
+{
+  if (x != t->a)
+    {
+      t->a = x;
+  
+      if (x && x == t->b)
+	t->a = 20;
+    }
+}
+
+
+T2 t;
+
+int main (void)
+{
+  t.a = 1;
+  t.b = 1234;
+
+  foo2 (&t, 1234);
+
+  if (t.a != 20)
+    __builtin_abort();
+
+  __builtin_exit (0);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/avr/torture/pr64452.c b/gcc/testsuite/gcc.target/avr/torture/pr64452.c
new file mode 100644
index 0000000..44cb2e0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/torture/pr64452.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c99" } */
+
+struct A
+{
+    char str[8];
+    void* v;
+};
+
+int varf (char* fmt, ...);
+
+void foo (struct A a, struct A b)
+{
+    varf ("%s%s", b.str, b.str);
+}
+
+long long x64;
+
+void foo2 (long long j0,
+           struct A a, struct A b, struct A c, struct A d,
+           struct A e, struct A f, struct A g, struct A h, struct A i,
+           long long j1)
+{
+    varf ("%s%s", i.str, i.str, x64, j1+j0);
+}
+
+
+void foo3 (long long j0,
+           struct A a, struct A b, struct A c, struct A d,
+           struct A e, struct A f, struct A g, struct A h, struct A i,
+           long long j1)
+{
+    varf ("%s%s", &i.str, &b.str, x64, j1+j0);
+}
diff --git a/gcc/testsuite/gcc.target/avr/xmega_const_hi_io_address.c b/gcc/testsuite/gcc.target/avr/xmega_const_hi_io_address.c
new file mode 100644
index 0000000..3e83249
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/xmega_const_hi_io_address.c
@@ -0,0 +1,15 @@
+/* Verify that loading the contents of a constant int address in I/O range
+   uses two IN instructions with the correct SFR offset for XMEGA*/
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega*" } } */
+
+void func()
+{
+    volatile int val = *((int *)0x20);
+    *((int *)0x20) = 0xCAFE;
+
+}
+
+/* { dg-final { scan-assembler "\tin r\\d+,0x20\n\tin r\\d+,0x20\\+1" } } */
+/* { dg-final { scan-assembler "\tout 0x20,r\\d+\n\tout 0x20\\+1,r\\d+" } } */
diff --git a/gcc/testsuite/gcc.target/avr/xmega_const_qi_io_address.c b/gcc/testsuite/gcc.target/avr/xmega_const_qi_io_address.c
new file mode 100644
index 0000000..09352fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/xmega_const_qi_io_address.c
@@ -0,0 +1,14 @@
+/* Verify that loading the contents of a constant address in I/O range
+   uses the IN instruction with the correct SFR offset for XMEGA*/
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega*" } } */
+
+void func()
+{
+    volatile char val = *((char *)0x20);
+    *((char *)0x20) = 42;
+}
+
+/* { dg-final { scan-assembler "\tin r\\d+,0x20" } } */
+/* { dg-final { scan-assembler "\tout 0x20,r\\d+" } } */
diff --git a/gcc/testsuite/gcc.target/avr/xmega_interrupt_no_cli.c b/gcc/testsuite/gcc.target/avr/xmega_interrupt_no_cli.c
new file mode 100644
index 0000000..c2c3db1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/xmega_interrupt_no_cli.c
@@ -0,0 +1,14 @@
+/* Verify that XMEGA interrupts don't have a cli or sei
+   and that SPL is written before SPH*/
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega*" } } */
+
+void __attribute__((interrupt)) __vector_1()
+{
+    volatile int w = 19, x = 20, y = 30, z = 42;
+}
+
+/* { dg-final { scan-assembler-not "\tcli" } } */
+/* { dg-final { scan-assembler "\tout __SP_L__,r\\d+\n\tout __SP_H__,r\\d+" } } */
+
diff --git a/gcc/testsuite/gcc.target/avr/xmega_sfr_offsets.c b/gcc/testsuite/gcc.target/avr/xmega_sfr_offsets.c
new file mode 100644
index 0000000..68fd8ae
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/xmega_sfr_offsets.c
@@ -0,0 +1,18 @@
+/* Verify that SFR offsets for XMEGAs do not have the 0x20 offset 
+   and that they are saved on entry, restored on exit for an interrupt
+   function  */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega128a1" } } */
+
+void __attribute__((interrupt)) __vector_1()
+{
+}
+
+/* { dg-final { scan-assembler "__SREG__ = 0x3f" } } */
+/* { dg-final { scan-assembler "__RAMPD__ = 0x38" } } */
+/* { dg-final { scan-assembler "\tin r0,__SREG__" } } */
+/* { dg-final { scan-assembler "\tin r0,__RAMPD__" } } */
+/* { dg-final { scan-assembler "\tpop r0\n\tout __SREG__,r0" } } */
+/* { dg-final { scan-assembler "\tpop r0\n\tout __RAMPD__,r0" } } */
+
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index df187b1..7ff50ae 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,19 @@
+2014-10-22  Georg-Johann Lay  <avr@gjlay.de>
+
+	* config/avr/lib1funcs.S (__do_global_dtors): Fix wrong code
+	introduced with 2014-10-21 trunk r216525.
+
+2014-09-11  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/63223
+	* config/avr/libgcc.S (__tablejump2__): Rewrite to use RAMPZ, ELPM
+	and R24 as needed.  Make work for all devices and .text locations.
+	(__do_global_ctors, __do_global_dtors): Use word addresses.
+	(__tablejump__, __tablejump_elpm__): Remove functions.
+	* t-avr (LIB1ASMFUNCS): Remove _tablejump, _tablejump_elpm.
+	Add _tablejump2.
+	(XICALL, XIJMP): New macros.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
diff --git a/libgcc/config/avr/lib1funcs-fixed.S b/libgcc/config/avr/lib1funcs-fixed.S
index 8f3ed92..632db07 100644
--- a/libgcc/config/avr/lib1funcs-fixed.S
+++ b/libgcc/config/avr/lib1funcs-fixed.S
@@ -31,8 +31,18 @@
 ;; Fixed point library routines for AVR
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+#if defined __AVR_TINY__
+#define __zero_reg__ r17
+#define __tmp_reg__ r16
+#else 
+#define __zero_reg__ r1
+#define __tmp_reg__ r0
+#endif
+
 .section .text.libgcc.fixed, "ax", @progbits
 
+#ifndef __AVR_TINY__
+
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Conversions to float
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -1913,3 +1923,5 @@ DEFUN __ret
     ret
 ENDF  __ret
 #endif /* L_ret */
+
+#endif /* if not __AVR_TINY__ */
diff --git a/libgcc/config/avr/lib1funcs.S b/libgcc/config/avr/lib1funcs.S
index 5ad1e93..f9fbb70 100644
--- a/libgcc/config/avr/lib1funcs.S
+++ b/libgcc/config/avr/lib1funcs.S
@@ -21,8 +21,13 @@ a copy of the GCC Runtime Library Exception along with this program;
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
+#if defined (__AVR_TINY__)
+#define __zero_reg__ r17
+#define __tmp_reg__ r16
+#else
 #define __zero_reg__ r1
 #define __tmp_reg__ r0
+#endif
 #define __SREG__ 0x3f
 #if defined (__AVR_HAVE_SPH__)
 #define __SP_H__ 0x3e
@@ -126,6 +131,24 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 ;; Support function entry and exit for convenience
 
+.macro wsubi r_arg1, i_arg2
+#if defined (__AVR_TINY__)
+    subi \r_arg1,   lo8(\i_arg2)
+    sbci \r_arg1+1, hi8(\i_arg2)
+#else
+    sbiw \r_arg1, \i_arg2
+#endif
+.endm
+
+.macro waddi r_arg1, i_arg2
+#if defined (__AVR_TINY__)
+    subi \r_arg1, lo8(-\i_arg2)
+    sbci \r_arg1+1, hi8(-\i_arg2)
+#else
+    adiw \r_arg1, \i_arg2
+#endif
+.endm
+
 .macro DEFUN name
 .global \name
 .func \name
@@ -146,7 +169,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 .endm
 
 ;; Skip next instruction, typically a jump target
+#if defined(__AVR_TINY__)
 #define skip cpse 0,0
+#else
+#define skip cpse 16,16
+#endif
 
 ;; Negate a 2-byte value held in consecutive registers
 .macro NEG2  reg
@@ -219,16 +246,16 @@ ENDF __mulqi3
     Multiplication  16 x 16  without MUL
 *******************************************************/
 
-#define A0  r22
-#define A1  r23
-#define B0  r24
-#define BB0 r20
-#define B1  r25
+#define A0  22
+#define A1  23
+#define B0  24
+#define BB0 20
+#define B1  25
 ;; Output overlaps input, thus expand result in CC0/1
-#define C0  r24
-#define C1  r25
+#define C0  24
+#define C1  25
 #define CC0  __tmp_reg__
-#define CC1  R21
+#define CC1  21
 
 #if defined (L_umulqihi3)
 ;;; R25:R24 = (unsigned int) R22 * (unsigned int) R24
@@ -294,7 +321,7 @@ DEFUN __mulhi3
     rol     B1
 3:
     ;; If B == 0 we are ready
-    sbiw    B0, 0
+    wsubi   B0, 0
     breq 9f
 
     ;; Carry = n-th bit of A
@@ -402,6 +429,18 @@ ENDF __mulhisi3
 
 #if defined (L_mulsi3)
 DEFUN __mulsi3
+#if defined (__AVR_TINY__)
+    in     r26, __SP_L__ ; safe to use X, as it is CC0/CC1
+    in     r27, __SP_H__
+    subi   r26, lo8(-3)   ; Add 3 to point past return address
+    sbci   r27, hi8(-3)
+    push   B0    ; save callee saved regs
+    push   B1
+    ld     B0, X+   ; load from caller stack
+    ld     B1, X+
+    ld     B2, X+
+    ld     B3, X
+#endif
     ;; Clear result
     clr     CC2
     clr     CC3
@@ -427,12 +466,17 @@ DEFUN __mulsi3_helper
     ;; Only continue if  A != 0
     sbci    A1, 0
     brne 2b
-    sbiw    A2, 0
+    wsubi   A2, 0
     brne 2b
 
     ;; All bits of A are consumed:  Copy result to return register C
     wmov    C0, CC0
     wmov    C2, CC2
+#if defined (__AVR_TINY__)
+    pop     B1      ; restore callee saved regs
+    pop     B0
+#endif  /* defined (__AVR_TINY__) */
+
     ret
 ENDF __mulsi3_helper
 #endif /* L_mulsi3 */
@@ -682,9 +726,12 @@ ENDF __mulpsi3
 #undef C0
 
 #else /* !HAVE_MUL */
-
 ;; C[0..2]: Expand Result
+#if defined (__AVR_TINY__)
+#define C0  16
+#else
 #define C0  0
+#endif /* defined (__AVR_TINY__) */
 #define C1  C0+1
 #define C2  21
 
@@ -692,6 +739,17 @@ ENDF __mulpsi3
 ;; Clobbers: __tmp_reg__, R18, R19, R20, R21
 
 DEFUN __mulpsi3
+#if defined (__AVR_TINY__)
+    in r26,__SP_L__ 
+    in r27,__SP_H__
+    subi r26, lo8(-3)   ; Add 3 to point past return address
+    sbci r27, hi8(-3)
+    push B0    ; save callee saved regs
+    push B1
+    ld B0,X+   ; load from caller stack 
+    ld B1,X+
+    ld B2,X+
+#endif /* defined (__AVR_TINY__) */
 
     ;; C[] = 0
     clr     __tmp_reg__
@@ -718,6 +776,10 @@ DEFUN __mulpsi3
     mov     A2, C2
 
     clr     __zero_reg__
+#if defined (__AVR_TINY__)
+    pop B1
+    pop B0
+#endif /* (__AVR_TINY__) */
     ret
 ENDF __mulpsi3
 
@@ -809,8 +871,8 @@ ENDF __mulsqipsi3
 #define B6  B0+6
 #define B7  B0+7
 
+#ifndef __AVR_TINY__
 #if defined (__AVR_HAVE_MUL__)
-
 ;; Define C[] for convenience
 ;; Notice that parts of C[] overlap A[] respective B[]
 #define C0  16
@@ -1012,6 +1074,7 @@ ENDF __muldi3
 
 #endif /* L_muldi3 */
 #endif /* HAVE_MUL */
+#endif /* if not __AVR_TINY__ */
 
 #undef B7
 #undef B6
@@ -1169,7 +1232,7 @@ ENDF __mulsidi3
 /**********************************************************
     Widening Multiplication 64 = 32 x 32  without  MUL
 **********************************************************/
-
+#ifndef __AVR_TINY__ /* if not __AVR_TINY__ */
 #if defined (L_mulsidi3) && !defined (__AVR_HAVE_MUL__)
 #define A0 18
 #define A1 A0+1
@@ -1265,7 +1328,7 @@ ENDF __umulsidi3
 #undef BB3
 #undef Mask
 #endif /* L_mulsidi3 && !HAVE_MUL */
-
+#endif /* if not __AVR_TINY__ */
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 	
 
@@ -1437,7 +1500,7 @@ ENDF __divmodhi4
 #define r_cnt   21
 
 #if defined (L_udivmodpsi4)
-;; R24:R22 = R24:R22  udiv  R20:R18
+;; R24:R22 = R24:R24  udiv  R20:R18
 ;; R20:R18 = R24:R22  umod  R20:R18
 ;; Clobbers: R21, R25, R26
 
@@ -1672,6 +1735,10 @@ ENDF __negsi2
 #undef r_arg2L
 #undef r_cnt
 
+/* *di routines use registers below R19 and won't work with tiny arch
+   right now. */
+
+#if !defined (__AVR_TINY__)
 /*******************************************************
        Division 64 / 64
        Modulo   64 % 64
@@ -2087,12 +2154,15 @@ ENDF __negdi2
 #undef A1
 #undef A0
 
+#endif /* !defined (__AVR_TINY__) */
+
 
 .section .text.libgcc.prologue, "ax", @progbits
 
 /**********************************
  * This is a prologue subroutine
  **********************************/
+#if !defined (__AVR_TINY__)
 #if defined (L_prologue)
 
 ;; This function does not clobber T-flag; 64-bit division relies on it
@@ -2194,6 +2264,7 @@ DEFUN __epilogue_restores__
 	ret
 ENDF __epilogue_restores__
 #endif /* defined (L_epilogue) */
+#endif /* !defined (__AVR_TINY__) */
 
 #ifdef L_exit
 	.section .fini9,"ax",@progbits
@@ -2259,6 +2330,12 @@ DEFUN __tablejump2__
     lpm     r31, Z
     mov     r30, __tmp_reg__
     ijmp
+#elif defined (__AVR_TINY__)
+    wsubi 30, -(__AVR_TINY_PM_BASE_ADDRESS__) ; Add PM offset to Z
+    ld __tmp_reg__, Z+
+    ld r31, Z   ; Use ld instead of lpm to load Z
+    mov r30, __tmp_reg__    
+    ijmp
 #else
     lpm
     push    r0
@@ -2270,6 +2347,26 @@ DEFUN __tablejump2__
 ENDF __tablejump2__
 #endif /* L_tablejump2 */
 
+#if defined(__AVR_TINY__)
+#ifdef L_copy_data
+        .section .init4,"ax",@progbits
+        .global __do_copy_data
+__do_copy_data:
+        ldi     r18, hi8(__data_end)
+        ldi     r26, lo8(__data_start)
+        ldi     r27, hi8(__data_start)
+        ldi     r30, lo8(__data_load_start + __AVR_TINY_PM_BASE_ADDRESS__)
+        ldi     r31, hi8(__data_load_start + __AVR_TINY_PM_BASE_ADDRESS__)
+        rjmp    .L__do_copy_data_start
+.L__do_copy_data_loop:
+        ld      r19, z+
+        st      X+, r19
+.L__do_copy_data_start:
+        cpi     r26, lo8(__data_end)
+        cpc     r27, r18
+        brne    .L__do_copy_data_loop
+#endif
+#else
 #ifdef L_copy_data
 	.section .init4,"ax",@progbits
 DEFUN __do_copy_data
@@ -2335,13 +2432,14 @@ DEFUN __do_copy_data
 #endif /* ELPM && RAMPD */
 ENDF __do_copy_data
 #endif /* L_copy_data */
+#endif /* !defined (__AVR_TINY__) */
 
 /* __do_clear_bss is only necessary if there is anything in .bss section.  */
 
 #ifdef L_clear_bss
 	.section .init4,"ax",@progbits
 DEFUN __do_clear_bss
-	ldi	r17, hi8(__bss_end)
+	ldi	r18, hi8(__bss_end)
 	ldi	r26, lo8(__bss_start)
 	ldi	r27, hi8(__bss_start)
 	rjmp	.do_clear_bss_start
@@ -2349,7 +2447,7 @@ DEFUN __do_clear_bss
 	st	X+, __zero_reg__
 .do_clear_bss_start:
 	cpi	r26, lo8(__bss_end)
-	cpc	r27, r17
+	cpc	r27, r18
 	brne	.do_clear_bss_loop
 ENDF __do_clear_bss
 #endif /* L_clear_bss */
@@ -2357,10 +2455,16 @@ ENDF __do_clear_bss
 /* __do_global_ctors and __do_global_dtors are only necessary
    if there are any constructors/destructors.  */
 
+#if defined(__AVR_TINY__)
+#define cdtors_tst_reg r18
+#else
+#define cdtors_tst_reg r17
+#endif
+
 #ifdef L_ctors
 	.section .init6,"ax",@progbits
 DEFUN __do_global_ctors
-    ldi     r17, pm_hi8(__ctors_start)
+    ldi     cdtors_tst_reg, pm_hi8(__ctors_start)
     ldi     r28, pm_lo8(__ctors_end)
     ldi     r29, pm_hi8(__ctors_end)
 #ifdef __AVR_HAVE_EIJMP_EICALL__
@@ -2368,7 +2472,7 @@ DEFUN __do_global_ctors
 #endif /* HAVE_EIJMP */
     rjmp    .L__do_global_ctors_start
 .L__do_global_ctors_loop:
-    sbiw    r28, 1
+    wsubi   28, 1
 #ifdef __AVR_HAVE_EIJMP_EICALL__
     sbc     r16, __zero_reg__
     mov     r24, r16
@@ -2390,7 +2494,7 @@ ENDF __do_global_ctors
 #ifdef L_dtors
 	.section .fini6,"ax",@progbits
 DEFUN __do_global_dtors
-    ldi     r17, pm_hi8(__dtors_end)
+    ldi     cdtors_tst_reg, pm_hi8(__dtors_end)
     ldi     r28, pm_lo8(__dtors_start)
     ldi     r29, pm_hi8(__dtors_start)
 #ifdef __AVR_HAVE_EIJMP_EICALL__
@@ -2404,13 +2508,13 @@ DEFUN __do_global_dtors
     mov_h   r31, r29
     mov_l   r30, r28
     XCALL   __tablejump2__
-    adiw    r28, 1
+    waddi   28, 1
 #ifdef __AVR_HAVE_EIJMP_EICALL__
     adc     r16, __zero_reg__
 #endif /* HAVE_EIJMP */
 .L__do_global_dtors_start:
     cpi     r28, pm_lo8(__dtors_end)
-    cpc     r29, r17
+    cpc     r29, cdtors_tst_reg
 #ifdef __AVR_HAVE_EIJMP_EICALL__
     ldi     r24, pm_hh8(__dtors_end)
     cpc     r16, r24
@@ -2419,8 +2523,11 @@ DEFUN __do_global_dtors
 ENDF __do_global_dtors
 #endif /* L_dtors */
 
+#undef cdtors_tst_reg
+
 .section .text.libgcc, "ax", @progbits
 
+#if !defined (__AVR_TINY__)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Loading n bytes from Flash; n = 3,4
 ;; R22... = Flash[Z]
@@ -2466,7 +2573,9 @@ ENDF __load_4
 #endif /* L_load_4 */
 
 #endif /* L_load_3 || L_load_3 */
+#endif /* !defined (__AVR_TINY__) */
 
+#if !defined (__AVR_TINY__)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Loading n bytes from Flash or RAM;  n = 1,2,3,4
 ;; R22... = Flash[R21:Z] or RAM[Z] depending on R21.7
@@ -2592,7 +2701,9 @@ ENDF __xload_4
 #endif /* L_xload_4 */
 
 #endif /* L_xload_{1|2|3|4} */
+#endif /* if !defined (__AVR_TINY__) */
 
+#if !defined (__AVR_TINY__)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; memcopy from Address Space __pgmx to RAM
 ;; R23:Z = Source Address
@@ -2664,6 +2775,7 @@ ENDF __movmemx_hi
 #undef LOOP
 
 #endif /* L_movmemx */
+#endif /* !defined (__AVR_TINY__) */ 
 
 
 .section .text.libgcc.builtins, "ax", @progbits
diff --git a/libgcc/config/avr/t-avr b/libgcc/config/avr/t-avr
index 1f73569..d8a97d5 100644
--- a/libgcc/config/avr/t-avr
+++ b/libgcc/config/avr/t-avr
@@ -3,12 +3,7 @@ LIB1ASMFUNCS = \
 	_mulqi3 \
 	_mulhi3 \
 	_mulqihi3 _umulqihi3 \
-	_mulpsi3 _mulsqipsi3 \
-	_mulhisi3 \
-	_umulhisi3 \
-	_usmulhisi3 \
-	_muluhisi3 \
-	_mulshisi3 \
+	_mulpsi3 \
 	_mulsi3 \
 	_udivmodqi4 \
 	_divmodqi4 \
@@ -17,19 +12,10 @@ LIB1ASMFUNCS = \
 	_divmodpsi4 _udivmodpsi4 \
 	_udivmodsi4 \
 	_divmodsi4 \
-	_divdi3 _udivdi3 \
-	_muldi3 _muldi3_6 \
-	_mulsidi3 _umulsidi3 \
-	_udivmod64 \
-	_negsi2 _negdi2 \
-	_prologue \
-	_epilogue \
+	_negsi2 \
 	_exit \
 	_cleanup \
 	_tablejump2 \
-	_load_3 _load_4 \
-	_xload_1 _xload_2 _xload_3 _xload_4 \
-	_movmemx \
 	_copy_data \
 	_clear_bss \
 	_ctors \
@@ -39,24 +25,56 @@ LIB1ASMFUNCS = \
 	_loop_ffsqi2 \
 	_ctzsi2 \
 	_ctzhi2 \
-	_clzdi2 \
 	_clzsi2 \
 	_clzhi2 \
-	_paritydi2 \
 	_paritysi2 \
 	_parityhi2 \
 	_popcounthi2 \
 	_popcountsi2 \
-	_popcountdi2 \
 	_popcountqi2 \
 	_bswapsi2 \
+	_fmul _fmuls _fmulsu
+
+# The below functions either use registers that are not present
+# in tiny core, or use a different register conventions (don't save
+# callee saved regs, for example)
+# _mulhisi3 and variations - clobber R18, R19
+# All *di funcs - use regs < R16 or expect args in regs < R20
+# _prologue and _epilogue save registers < R16
+# _tablejump/_tablejump_elmp - expect lpm and elpm support
+# _load ad _xload variations - expect lpm and elpm support
+# _movmemx - expects elpm/lpm
+
+ifneq ($(MULTIFLAGS),-mmcu=avrtiny)
+LIB1ASMFUNCS += \
+    _mulsqipsi3 \
+	_mulhisi3 \
+	_umulhisi3 \
+	_usmulhisi3 \
+	_muluhisi3 \
+	_mulshisi3 \
+    _muldi3 _muldi3_6 \
+    _mulsidi3 _umulsidi3 \
+	_divdi3 _udivdi3 \
+	_udivmod64 \
+	_negdi2 \
+	_prologue \
+	_epilogue \
+	_tablejump_elpm \
+	_load_3 _load_4 \
+	_xload_1 _xload_2 _xload_3 _xload_4 \
+	_movmemx \
+	_clzdi2 \
+	_paritydi2 \
+	_popcountdi2 \
 	_bswapdi2 \
 	_ashldi3 _ashrdi3 _lshrdi3 _rotldi3 \
 	_adddi3 _adddi3_s8 _subdi3 \
-	_cmpdi2 _cmpdi2_s8 \
-	_fmul _fmuls _fmulsu
+	_cmpdi2 _cmpdi2_s8
+endif
 
 # Fixed point routines in avr/lib1funcs-fixed.S
+ifneq ($(MULTIFLAGS),-mmcu=avrtiny)
 LIB1ASMFUNCS += \
 	_fractqqsf _fractuqqsf \
 	_fracthqsf _fractuhqsf _fracthasf _fractuhasf \
@@ -87,8 +105,8 @@ LIB1ASMFUNCS += \
 	_round_x8 \
 	_rounddq3 _roundudq3 \
 	_roundda3 _rounduda3 \
-	_roundta3 _rounduta3 \
-
+	_roundta3 _rounduta3
+endif
 
 LIB2FUNCS_EXCLUDE = \
 	_moddi3 _umoddi3 \
